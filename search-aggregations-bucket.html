<!DOCTYPE html>
<html lang="en-us">
  <head>
    
<meta charset="UTF-8">
<title>Bucket aggregations | Elasticsearch Guide | Elastic</title>
<meta class="elastic" name="content" content="Bucket aggregations | Elasticsearch Guide">

<link rel="home" href="index.html" title="Elasticsearch Guide"/>
<link rel="up" href="search-aggregations.html" title="Aggregations"/>
<link rel="prev" href="search-aggregations.html" title="Aggregations"/>
<link rel="next" href="search-aggregations-metrics.html" title="Metrics aggregations"/>
<meta class="elastic" name="product_version" content=""/>
<meta class="elastic" name="product_name" content=""/>
<meta class="elastic" name="website_area" content="documentation"/>
<meta name="DC.type" content="Learn/Docs/"/>
<meta name="DC.subject" content=""/>
<meta name="DC.identifier" content=""/>

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://cdn.optimizely.com/js/18132920325.js"></script>
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-icon-180x180.png">
    <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/android-chrome-192x192.png" sizes="192x192">
    <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
    <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
    <link rel="manifest" href="/manifest.json">
    <meta name="apple-mobile-web-app-title" content="Elastic">
    <meta name="application-name" content="Elastic">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/mstile-144x144.png">
    <meta name="theme-color" content="#ffffff">
    <meta name="naver-site-verification" content="936882c1853b701b3cef3721758d80535413dbfd" />
    <meta name="yandex-verification" content="d8a47e95d0972434" />
    <meta name="localized" content="true" />
    <meta name="st:robots" content="follow,index" />
    <meta property="og:image" content="https://static-www.elastic.co/v3/assets/bltefdd0b53724fa2ce/blt280217a63b82a734/6202d3378b1f312528798412/elastic-logo.svg" />
    <meta property="og:image:width" content="500" />
    <meta property="og:image:height" content="172" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon-precomposed" sizes="64x64" href="/favicon_64x64_16bit.png">
    <link rel="apple-touch-icon-precomposed" sizes="32x32" href="/favicon_32x32.png">
    <link rel="apple-touch-icon-precomposed" sizes="16x16" href="/favicon_16x16.png">
    <!-- Give IE8 a fighting chance -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <link rel="stylesheet" type="text/css" href="/guide/static/styles.css" />
  </head>

  <!--© 2015-2022 Elasticsearch B.V. -->
  <!-- All Elastic documentation is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License. -->
  <!-- http://creativecommons.org/licenses/by-nc-nd/4.0/ -->

  <body>
    <!-- Google Tag Manager -->
    <script>dataLayer = [];</script><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-58RLH5" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0], j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src= '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f); })(window,document,'script','dataLayer','GTM-58RLH5');</script>
    <!-- End Google Tag Manager -->

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-12395217-16"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-12395217-16');
    </script>

    <!-- Google Tag Manager for GA4 -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0], j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-KNJMG2M');</script>
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KNJMG2M" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager for GA4-->

    <div id='elastic-nav' style="display:none;"></div>
    <script src='https://www.elastic.co/elastic-nav.js'></script>

    <div class="main-container">
      <section id="content" >
        <div class="content-wrapper">

          <section id="guide" lang="en">
            <div class="container-fluid">
              <div class="row pb-3">
                <div class="col-12 order-2 col-md-4 order-md-1 col-lg-3 h-almost-full-md sticky-top-md" id="left_col">
                  <!-- The TOC is appended here -->
                </div>

                <div class="col-12 order-1 col-md-8 order-md-2 col-lg-7 order-lg-2 guide-section" id="middle_col">
                  <!-- start body -->
                  
<div id="content">
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="/guide/">Elastic Docs</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="index.html">Elasticsearch Guide</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="search-aggregations.html">Aggregations</a></span>
</div>
<div class="navheader">
<span class="prev">
<a href="search-aggregations.html">« Aggregations</a>
</span>
<span class="next">
<a href="search-aggregations-metrics.html">Metrics aggregations »</a>
</span>
</div>
<div class="chapter">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket"></a>Bucket aggregations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket.asciidoc">edit</a></h2>
</div></div></div>
<p>Bucket aggregations don&#8217;t calculate metrics over fields like the metrics aggregations do, but instead, they create
buckets of documents. Each bucket is associated with a criterion (depending on the aggregation type) which determines
whether or not a document in the current context "falls" into it. In other words, the buckets effectively define document
sets. In addition to the buckets themselves, the <code class="literal">bucket</code> aggregations also compute and return the number of documents
that "fell into" each bucket.</p>
<p>Bucket aggregations, as opposed to <code class="literal">metrics</code> aggregations, can hold sub-aggregations. These sub-aggregations will be
aggregated for the buckets created by their "parent" bucket aggregation.</p>
<p>There are different bucket aggregators, each with a different "bucketing" strategy. Some define a single bucket, some
define fixed number of multiple buckets, and others dynamically create the buckets during the aggregation process.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>The maximum number of buckets allowed in a single response is limited by a
dynamic cluster setting named
<a class="xref" href="settings.html#search-settings-max-buckets"><code class="literal">search.max_buckets</code></a>. It defaults to 65,535.
Requests that try to return more than the limit will fail with an exception.</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-adjacency-matrix-aggregation"></a>Adjacency matrix aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/adjacency-matrix-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A bucket aggregation returning a form of <a href="https://en.wikipedia.org/wiki/Adjacency_matrix" class="ulink" target="_top">adjacency matrix</a>.
The request provides a collection of named filter expressions, similar to the <code class="literal">filters</code> aggregation
request.
Each bucket in the response represents a non-empty cell in the matrix of intersecting filters.</p>
<p>Given filters named <code class="literal">A</code>, <code class="literal">B</code> and <code class="literal">C</code> the response would return buckets with the following names:</p>
<div class="informaltable">
<table border="1" cellpadding="4px">
<colgroup>
<col class="col_1"/>
<col class="col_2"/>
<col class="col_3"/>
<col class="col_4"/>
</colgroup>
<thead>
<tr>
<th align="left" valign="top"></th>
<th align="left" valign="top">A</th>
<th align="left" valign="top">B</th>
<th align="left" valign="top">C</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p><span class="strong strong"><strong>A</strong></span></p></td>
<td align="left" valign="top"><p>A</p></td>
<td align="left" valign="top"><p>A&amp;B</p></td>
<td align="left" valign="top"><p>A&amp;C</p></td>
</tr>
<tr>
<td align="left" valign="top"><p><span class="strong strong"><strong>B</strong></span></p></td>
<td align="left" valign="top"><p></p></td>
<td align="left" valign="top"><p>B</p></td>
<td align="left" valign="top"><p>B&amp;C</p></td>
</tr>
<tr>
<td align="left" valign="top"><p><span class="strong strong"><strong>C</strong></span></p></td>
<td align="left" valign="top"><p></p></td>
<td align="left" valign="top"><p></p></td>
<td align="left" valign="top"><p>C</p></td>
</tr>
</tbody>
</table>
</div>
<p>The intersecting buckets e.g <code class="literal">A&amp;C</code> are labelled using a combination of the two filter names separated by
the ampersand character. Note that the response does not also include a "C&amp;A" bucket as this would be the
same set of documents as "A&amp;C". The matrix is said to be <em>symmetric</em> so we only return half of it. To do this we sort
the filter name strings and always use the lowest of a pair as the value to the left of the "&amp;" separator.</p>
<p>An alternative <code class="literal">separator</code> parameter can be passed in the request if clients wish to use a separator string
other than the default of the ampersand.</p>
<p>Example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /emails/_bulk?refresh
{ "index" : { "_id" : 1 } }
{ "accounts" : ["hillary", "sidney"]}
{ "index" : { "_id" : 2 } }
{ "accounts" : ["hillary", "donald"]}
{ "index" : { "_id" : 3 } }
{ "accounts" : ["vladimir", "donald"]}

GET emails/_search
{
  "size": 0,
  "aggs" : {
    "interactions" : {
      "adjacency_matrix" : {
        "filters" : {
          "grpA" : { "terms" : { "accounts" : ["hillary", "sidney"] }},
          "grpB" : { "terms" : { "accounts" : ["donald", "mitt"] }},
          "grpC" : { "terms" : { "accounts" : ["vladimir", "nigel"] }}
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/957.console"></div>
<p>In the above example, we analyse email messages to see which groups of individuals
have exchanged messages.
We will get counts for each group individually and also a count of messages for pairs
of groups that have recorded interactions.</p>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "took": 9,
  "timed_out": false,
  "_shards": ...,
  "hits": ...,
  "aggregations": {
    "interactions": {
      "buckets": [
        {
          "key":"grpA",
          "doc_count": 2
        },
        {
          "key":"grpA&amp;grpB",
          "doc_count": 1
        },
        {
          "key":"grpB",
          "doc_count": 2
        },
        {
          "key":"grpB&amp;grpC",
          "doc_count": 1
        },
        {
          "key":"grpC",
          "doc_count": 1
        }
      ]
    }
  }
}</pre>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_usage"></a>Usage<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/adjacency-matrix-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>On its own this aggregation can provide all of the data required to create an undirected weighted graph.
However, when used with child aggregations such as a <code class="literal">date_histogram</code> the results can provide the
additional levels of data required to perform <a href="https://en.wikipedia.org/wiki/Dynamic_network_analysis" class="ulink" target="_top">dynamic network analysis</a>
where examining interactions <em>over time</em> becomes important.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_limitations_4"></a>Limitations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/adjacency-matrix-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>For N filters the matrix of buckets produced can be N²/2 and so there is a default maximum
imposed of 100 filters . This setting can be changed using the <code class="literal">index.max_adjacency_matrix_filters</code> index-level setting
(note this setting is deprecated and will be repaced with <code class="literal">indices.query.bool.max_clause_count</code> in 8.0+).</p>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-autodatehistogram-aggregation"></a>Auto-interval date histogram aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/autodatehistogram-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A multi-bucket aggregation similar to the <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-datehistogram-aggregation" title="Date histogram aggregation">Date histogram</a> except
instead of providing an interval to use as the width of each bucket, a target number of buckets is provided
indicating the number of buckets needed and the interval of the buckets is automatically chosen to best achieve
that target. The number of buckets returned will always be less than or equal to this target number.</p>
<p>The buckets field is optional, and will default to 10 buckets if not specified.</p>
<p>Requesting a target of 10 buckets.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "sales_over_time": {
      "auto_date_histogram": {
        "field": "date",
        "buckets": 10
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/958.console"></div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_keys"></a>Keys<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/autodatehistogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Internally, a date is represented as a 64 bit number representing a timestamp
in milliseconds-since-the-epoch. These timestamps are returned as the bucket
<code class="literal">key</code>s. The <code class="literal">key_as_string</code> is the same timestamp converted to a formatted
date string using the format specified with the <code class="literal">format</code> parameter:</p>
<div class="tip admon">
<div class="icon"></div>
<div class="admon_content">
<p>If no <code class="literal">format</code> is specified, then it will use the first date
<a class="xref" href="mapping-params.html#mapping-date-format" title="format">format</a> specified in the field mapping.</p>
</div>
</div>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "sales_over_time": {
      "auto_date_histogram": {
        "field": "date",
        "buckets": 5,
        "format": "yyyy-MM-dd" <a id="CO227-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/959.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO227-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Supports expressive date <a class="xref" href="search-aggregations-bucket.html#date-format-pattern" title="Date Format/Pattern">format pattern</a></p>
</td>
</tr>
</table>
</div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "sales_over_time": {
      "buckets": [
        {
          "key_as_string": "2015-01-01",
          "key": 1420070400000,
          "doc_count": 3
        },
        {
          "key_as_string": "2015-02-01",
          "key": 1422748800000,
          "doc_count": 2
        },
        {
          "key_as_string": "2015-03-01",
          "key": 1425168000000,
          "doc_count": 2
        }
      ],
      "interval": "1M"
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_intervals"></a>Intervals<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/autodatehistogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The interval of the returned buckets is selected based on the data collected by the
aggregation so that the number of buckets returned is less than or equal to the number
requested. The possible intervals returned are:</p>
<div class="informaltable">
<table border="0" cellpadding="4px">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody valign="top">
<tr>
<td valign="top">
<p>
seconds
</p>
</td>
<td valign="top">
<p>
In multiples of 1, 5, 10 and 30
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
minutes
</p>
</td>
<td valign="top">
<p>
In multiples of 1, 5, 10 and 30
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
hours
</p>
</td>
<td valign="top">
<p>
In multiples of 1, 3 and 12
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
days
</p>
</td>
<td valign="top">
<p>
In multiples of 1, and 7
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
months
</p>
</td>
<td valign="top">
<p>
In multiples of 1, and 3
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
years
</p>
</td>
<td valign="top">
<p>
In multiples of 1, 5, 10, 20, 50 and 100
</p>
</td>
</tr>
</tbody>
</table>
</div>
<p>In the worst case, where the number of daily buckets are too many for the requested
number of buckets, the number of buckets returned will be 1/7th of the number of
buckets requested.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_time_zone"></a>Time Zone<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/autodatehistogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Date-times are stored in Elasticsearch in UTC.  By default, all bucketing and
rounding is also done in UTC. The <code class="literal">time_zone</code> parameter can be used to indicate
that bucketing should use a different time zone.</p>
<p>Time zones may either be specified as an ISO 8601 UTC offset (e.g. <code class="literal">+01:00</code> or
<code class="literal">-08:00</code>)  or as a timezone id, an identifier used in the TZ database like
<code class="literal">America/Los_Angeles</code>.</p>
<p>Consider the following example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT my-index-00001/log/1?refresh
{
  "date": "2015-10-01T00:30:00Z"
}

PUT my-index-00001/log/2?refresh
{
  "date": "2015-10-01T01:30:00Z"
}

PUT my-index-00001/log/3?refresh
{
  "date": "2015-10-01T02:30:00Z"
}

GET my-index-00001/_search?size=0
{
  "aggs": {
    "by_day": {
      "auto_date_histogram": {
        "field":     "date",
        "buckets" : 3
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/960.console"></div>
<p>UTC is used if no time zone is specified, three 1-hour buckets are returned
starting at midnight UTC on 1 October 2015:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "by_day": {
      "buckets": [
        {
          "key_as_string": "2015-10-01T00:00:00.000Z",
          "key": 1443657600000,
          "doc_count": 1
        },
        {
          "key_as_string": "2015-10-01T01:00:00.000Z",
          "key": 1443661200000,
          "doc_count": 1
        },
        {
          "key_as_string": "2015-10-01T02:00:00.000Z",
          "key": 1443664800000,
          "doc_count": 1
        }
      ],
      "interval": "1h"
    }
  }
}</pre>
</div>
<p>If a <code class="literal">time_zone</code> of <code class="literal">-01:00</code> is specified, then midnight starts at one hour before
midnight UTC:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET my-index-00001/_search?size=0
{
  "aggs": {
    "by_day": {
      "auto_date_histogram": {
        "field":     "date",
        "buckets" : 3,
        "time_zone": "-01:00"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/961.console"></div>
<p>Now three 1-hour buckets are still returned but the first bucket starts at
11:00pm on 30 September 2015 since that is the local time for the bucket in
the specified time zone.</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "by_day": {
      "buckets": [
        {
          "key_as_string": "2015-09-30T23:00:00.000-01:00", <a id="CO228-1"></a><i class="conum" data-value="1"></i>
          "key": 1443657600000,
          "doc_count": 1
        },
        {
          "key_as_string": "2015-10-01T00:00:00.000-01:00",
          "key": 1443661200000,
          "doc_count": 1
        },
        {
          "key_as_string": "2015-10-01T01:00:00.000-01:00",
          "key": 1443664800000,
          "doc_count": 1
        }
      ],
      "interval": "1h"
    }
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO228-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">key_as_string</code> value represents midnight on each day
in the specified time zone.</p>
</td>
</tr>
</table>
</div>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>When using time zones that follow DST (daylight savings time) changes,
buckets close to the moment when those changes happen can have slightly different
sizes than neighbouring buckets.
For example, consider a DST start in the <code class="literal">CET</code> time zone: on 27 March 2016 at 2am,
clocks were turned forward 1 hour to 3am local time. If the result of the aggregation
was daily buckets, the bucket covering that day will only hold data for 23 hours
instead of the usual 24 hours for other buckets. The same is true for shorter intervals
like e.g. 12h. Here, we will have only a 11h bucket on the morning of 27 March when the
DST shift happens.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_scripts"></a>Scripts<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/autodatehistogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Like with the normal <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-datehistogram-aggregation" title="Date histogram aggregation"><code class="literal">date_histogram</code></a>, both document level
scripts and value level scripts are supported. This aggregation does not however, support the <code class="literal">min_doc_count</code>,
<code class="literal">extended_bounds</code>, <code class="literal">hard_bounds</code> and <code class="literal">order</code> parameters.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_minimum_interval_parameter"></a>Minimum Interval parameter<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/autodatehistogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">minimum_interval</code> allows the caller to specify the minimum rounding interval that should be used.
This can make the collection process more efficient, as the aggregation will not attempt to round at
any interval lower than <code class="literal">minimum_interval</code>.</p>
<p>The accepted units for <code class="literal">minimum_interval</code> are:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
year
</li>
<li class="listitem">
month
</li>
<li class="listitem">
day
</li>
<li class="listitem">
hour
</li>
<li class="listitem">
minute
</li>
<li class="listitem">
second
</li>
</ul>
</div>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "sale_date": {
      "auto_date_histogram": {
        "field": "date",
        "buckets": 10,
        "minimum_interval": "minute"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/962.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_missing_value"></a>Missing value<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/autodatehistogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">missing</code> parameter defines how documents that are missing a value should be treated.
By default they will be ignored but it is also possible to treat them as if they
had a value.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "sale_date": {
      "auto_date_histogram": {
        "field": "date",
        "buckets": 10,
        "missing": "2000/01/01" <a id="CO229-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/963.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO229-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Documents without a value in the <code class="literal">publish_date</code> field will fall into the same bucket as documents that have the value <code class="literal">2000-01-01</code>.</p>
</td>
</tr>
</table>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-children-aggregation"></a>Children aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/children-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A special single bucket aggregation that selects child documents that have the specified type, as defined in a <a class="xref" href="mapping-types.html#parent-join" title="Join field type"><code class="literal">join</code> field</a>.</p>
<p>This aggregation has a single option:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<code class="literal">type</code> - The child type that should be selected.
</li>
</ul>
</div>
<p>For example, let&#8217;s say we have an index of questions and answers. The answer type has the following <code class="literal">join</code> field in the mapping:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT child_example
{
  "mappings": {
    "properties": {
      "join": {
        "type": "join",
        "relations": {
          "question": "answer"
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/964.console"></div>
<p>The <code class="literal">question</code> document contain a tag field and the <code class="literal">answer</code> documents contain an owner field. With the <code class="literal">children</code>
aggregation the tag buckets can be mapped to the owner buckets in a single request even though the two fields exist in
two different kinds of documents.</p>
<p>An example of a question document:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT child_example/_doc/1
{
  "join": {
    "name": "question"
  },
  "body": "&lt;p&gt;I have Windows 2003 server and i bought a new Windows 2008 server...",
  "title": "Whats the best way to file transfer my site from server to a newer one?",
  "tags": [
    "windows-server-2003",
    "windows-server-2008",
    "file-transfer"
  ]
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/965.console"></div>
<p>Examples of <code class="literal">answer</code> documents:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT child_example/_doc/2?routing=1
{
  "join": {
    "name": "answer",
    "parent": "1"
  },
  "owner": {
    "location": "Norfolk, United Kingdom",
    "display_name": "Sam",
    "id": 48
  },
  "body": "&lt;p&gt;Unfortunately you're pretty much limited to FTP...",
  "creation_date": "2009-05-04T13:45:37.030"
}

PUT child_example/_doc/3?routing=1&amp;refresh
{
  "join": {
    "name": "answer",
    "parent": "1"
  },
  "owner": {
    "location": "Norfolk, United Kingdom",
    "display_name": "Troll",
    "id": 49
  },
  "body": "&lt;p&gt;Use Linux...",
  "creation_date": "2009-05-05T13:45:37.030"
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/966.console"></div>
<p>The following request can be built that connects the two together:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST child_example/_search?size=0
{
  "aggs": {
    "top-tags": {
      "terms": {
        "field": "tags.keyword",
        "size": 10
      },
      "aggs": {
        "to-answers": {
          "children": {
            "type" : "answer" <a id="CO230-1"></a><i class="conum" data-value="1"></i>
          },
          "aggs": {
            "top-names": {
              "terms": {
                "field": "owner.display_name.keyword",
                "size": 10
              }
            }
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/967.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO230-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">type</code> points to type / mapping with the name <code class="literal">answer</code>.</p>
</td>
</tr>
</table>
</div>
<p>The above example returns the top question tags and per tag the top answer owners.</p>
<p>Possible response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "took": 25,
  "timed_out": false,
  "_shards": {
    "total": 1,
    "successful": 1,
    "skipped" : 0,
    "failed": 0
  },
  "hits": {
    "total" : {
      "value": 3,
      "relation": "eq"
    },
    "max_score": null,
    "hits": []
  },
  "aggregations": {
    "top-tags": {
      "doc_count_error_upper_bound": 0,
      "sum_other_doc_count": 0,
      "buckets": [
        {
          "key": "file-transfer",
          "doc_count": 1, <a id="CO231-1"></a><i class="conum" data-value="1"></i>
          "to-answers": {
            "doc_count": 2, <a id="CO231-2"></a><i class="conum" data-value="2"></i>
            "top-names": {
              "doc_count_error_upper_bound": 0,
              "sum_other_doc_count": 0,
              "buckets": [
                {
                  "key": "Sam",
                  "doc_count": 1
                },
                {
                  "key": "Troll",
                  "doc_count": 1
                }
              ]
            }
          }
        },
        {
          "key": "windows-server-2003",
          "doc_count": 1, <a id="CO231-3"></a><i class="conum" data-value="1"></i>
          "to-answers": {
            "doc_count": 2, <a id="CO231-4"></a><i class="conum" data-value="2"></i>
            "top-names": {
              "doc_count_error_upper_bound": 0,
              "sum_other_doc_count": 0,
              "buckets": [
                {
                  "key": "Sam",
                  "doc_count": 1
                },
                {
                  "key": "Troll",
                  "doc_count": 1
                }
              ]
            }
          }
        },
        {
          "key": "windows-server-2008",
          "doc_count": 1, <a id="CO231-5"></a><i class="conum" data-value="1"></i>
          "to-answers": {
            "doc_count": 2, <a id="CO231-6"></a><i class="conum" data-value="2"></i>
            "top-names": {
              "doc_count_error_upper_bound": 0,
              "sum_other_doc_count": 0,
              "buckets": [
                {
                  "key": "Sam",
                  "doc_count": 1
                },
                {
                  "key": "Troll",
                  "doc_count": 1
                }
              ]
            }
          }
        }
      ]
    }
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO231-1"><i class="conum" data-value="1"></i></a><a href="#CO231-3"></a><a href="#CO231-5"></a></p>
</td>
<td align="left" valign="top">
<p>The number of question documents with the tag <code class="literal">file-transfer</code>, <code class="literal">windows-server-2003</code>, etc.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO231-2"><i class="conum" data-value="2"></i></a><a href="#CO231-4"></a><a href="#CO231-6"></a></p>
</td>
<td align="left" valign="top">
<p>The number of answer documents that are related to question documents with the tag <code class="literal">file-transfer</code>, <code class="literal">windows-server-2003</code>, etc.</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-composite-aggregation"></a>Composite aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/composite-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A multi-bucket aggregation that creates composite buckets from different sources.</p>
<p>Unlike the other <code class="literal">multi-bucket</code> aggregations, you can use the <code class="literal">composite</code>
aggregation to paginate <span class="strong strong"><strong>all</strong></span> buckets from a multi-level aggregation
efficiently. This aggregation provides a way to stream <span class="strong strong"><strong>all</strong></span> buckets of a
specific aggregation, similar to what
<a class="xref" href="paginate-search-results.html#scroll-search-results" title="Scroll search results">scroll</a> does for documents.</p>
<p>The composite buckets are built from the combinations of the
values extracted/created for each document and each combination is considered as
a composite bucket.</p>
<p>For example, consider the following document:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "keyword": ["foo", "bar"],
  "number": [23, 65, 76]
}</pre>
</div>
<p>Using <code class="literal">keyword</code> and <code class="literal">number</code> as source fields for the aggregation results in
the following composite buckets:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{ "keyword": "foo", "number": 23 }
{ "keyword": "foo", "number": 65 }
{ "keyword": "foo", "number": 76 }
{ "keyword": "bar", "number": 23 }
{ "keyword": "bar", "number": 65 }
{ "keyword": "bar", "number": 76 }</pre>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_value_sources"></a>Value sources<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/composite-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">sources</code> parameter defines the source fields to use when building
composite buckets. The order that the <code class="literal">sources</code> are defined controls the order
that the keys are returned.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>You must use a unique name when defining <code class="literal">sources</code>.</p>
</div>
</div>
<p>The <code class="literal">sources</code> parameter can be any of the following types:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<a class="xref" href="search-aggregations-bucket.html#_terms" title="Terms">Terms</a>
</li>
<li class="listitem">
<a class="xref" href="search-aggregations-bucket.html#_histogram" title="Histogram">Histogram</a>
</li>
<li class="listitem">
<a class="xref" href="search-aggregations-bucket.html#_date_histogram" title="Date histogram">Date histogram</a>
</li>
<li class="listitem">
<a class="xref" href="search-aggregations-bucket.html#_geotile_grid" title="GeoTile grid">GeoTile grid</a>
</li>
</ul>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_terms"></a>Terms<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/composite-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>The <code class="literal">terms</code> value source is equivalent to a simple <code class="literal">terms</code> aggregation.
The values are extracted from a field or a script exactly like the <code class="literal">terms</code> aggregation.</p>
<p>Example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          { "product": { "terms": { "field": "product" } } }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/968.console"></div>
<p>Like the <code class="literal">terms</code> aggregation it is also possible to use a script to create the values for the composite buckets:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          {
            "product": {
              "terms": {
                "script": {
                  "source": "doc['product'].value",
                  "lang": "painless"
                }
              }
            }
          }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/969.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_histogram"></a>Histogram<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/composite-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>The <code class="literal">histogram</code> value source can be applied on numeric values to build fixed size
interval over the values. The <code class="literal">interval</code> parameter defines how the numeric values should be
transformed. For instance an <code class="literal">interval</code> set to 5 will translate any numeric values to its closest interval,
a value of <code class="literal">101</code> would be translated to <code class="literal">100</code> which is the key for the interval between 100 and 105.</p>
<p>Example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          { "histo": { "histogram": { "field": "price", "interval": 5 } } }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/970.console"></div>
<p>The values are built from a numeric field or a script that return numerical values:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          {
            "histo": {
              "histogram": {
                "interval": 5,
                "script": {
                  "source": "doc['price'].value",
                  "lang": "painless"
                }
              }
            }
          }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/971.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_date_histogram"></a>Date histogram<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/composite-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>The <code class="literal">date_histogram</code> is similar to the <code class="literal">histogram</code> value source except that the interval
is specified by date/time expression:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          { "date": { "date_histogram": { "field": "timestamp", "calendar_interval": "1d" } } }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/972.console"></div>
<p>The example above creates an interval per day and translates all <code class="literal">timestamp</code> values to the start of its closest intervals.
Available expressions for interval: <code class="literal">year</code>, <code class="literal">quarter</code>, <code class="literal">month</code>, <code class="literal">week</code>, <code class="literal">day</code>, <code class="literal">hour</code>, <code class="literal">minute</code>, <code class="literal">second</code></p>
<p>Time values can also be specified via abbreviations supported by <a class="xref" href="api-conventions.html#time-units" title="Time units">time units</a> parsing.
Note that fractional time values are not supported, but you can address this by shifting to another
time unit (e.g., <code class="literal">1.5h</code> could instead be specified as <code class="literal">90m</code>).</p>
<p><span class="strong strong"><strong>Format</strong></span></p>
<p>Internally, a date is represented as a 64 bit number representing a timestamp in milliseconds-since-the-epoch.
These timestamps are returned as the bucket keys. It is possible to return a formatted date string instead using
the format specified with the format parameter:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          {
            "date": {
              "date_histogram": {
                "field": "timestamp",
                "calendar_interval": "1d",
                "format": "yyyy-MM-dd"         <a id="CO232-1"></a><i class="conum" data-value="1"></i>
              }
            }
          }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/973.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO232-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Supports expressive date <a class="xref" href="search-aggregations-bucket.html#date-format-pattern" title="Date Format/Pattern">format pattern</a></p>
</td>
</tr>
</table>
</div>
<p><span class="strong strong"><strong>Time Zone</strong></span></p>
<p>Date-times are stored in Elasticsearch in UTC.  By default, all bucketing and
rounding is also done in UTC. The <code class="literal">time_zone</code> parameter can be used to indicate
that bucketing should use a different time zone.</p>
<p>Time zones may either be specified as an ISO 8601 UTC offset (e.g. <code class="literal">+01:00</code> or
<code class="literal">-08:00</code>)  or as a timezone id, an identifier used in the TZ database like
<code class="literal">America/Los_Angeles</code>.</p>
<p><span class="strong strong"><strong>Offset</strong></span></p>
<p>Use the <code class="literal">offset</code> parameter to change the start value of each bucket by the
specified positive (<code class="literal">+</code>) or negative offset (<code class="literal">-</code>) duration, such as <code class="literal">1h</code> for
an hour, or <code class="literal">1d</code> for a day. See <a class="xref" href="api-conventions.html#time-units" title="Time units">Time units</a> for more possible time
duration options.</p>
<p>For example, when using an interval of <code class="literal">day</code>, each bucket runs from midnight
to midnight. Setting the <code class="literal">offset</code> parameter to <code class="literal">+6h</code> changes each bucket
to run from 6am to 6am:</p>
<a id="composite-aggregation-datehistogram-offset-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT my-index-000001/_doc/1?refresh
{
  "date": "2015-10-01T05:30:00Z"
}

PUT my-index-000001/_doc/2?refresh
{
  "date": "2015-10-01T06:30:00Z"
}

GET my-index-000001/_search?size=0
{
  "aggs": {
    "my_buckets": {
      "composite" : {
        "sources" : [
          {
            "date": {
              "date_histogram" : {
                "field": "date",
                "calendar_interval": "day",
                "offset": "+6h",
                "format": "iso8601"
              }
            }
          }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/974.console"></div>
<p>Instead of a single bucket starting at midnight, the above request groups the
documents into buckets starting at 6am:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "my_buckets": {
      "after_key": { "date": "2015-10-01T06:00:00.000Z" },
      "buckets": [
        {
          "key": { "date": "2015-09-30T06:00:00.000Z" },
          "doc_count": 1
        },
        {
          "key": { "date": "2015-10-01T06:00:00.000Z" },
          "doc_count": 1
        }
      ]
    }
  }
}</pre>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>The start <code class="literal">offset</code> of each bucket is calculated after <code class="literal">time_zone</code>
adjustments have been made.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_geotile_grid"></a>GeoTile grid<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/composite-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>The <code class="literal">geotile_grid</code> value source works on <code class="literal">geo_point</code> fields and groups points into buckets that represent
cells in a grid. The resulting grid can be sparse and only contains cells
that have matching data. Each cell corresponds to a
<a href="https://en.wikipedia.org/wiki/Tiled_web_map" class="ulink" target="_top">map tile</a> as used by many online map
sites. Each cell is labeled using a "{zoom}/{x}/{y}" format, where zoom is equal
to the user-specified precision.</p>
<a id="composite-aggregation-geotilegrid-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          { "tile": { "geotile_grid": { "field": "location", "precision": 8 } } }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/975.console"></div>
<p><span class="strong strong"><strong>Precision</strong></span></p>
<p>The highest-precision geotile of length 29 produces cells that cover
less than 10cm by 10cm of land. This precision is uniquely suited for composite aggregations as each
tile does not have to be generated and loaded in memory.</p>
<p>See <a href="https://wiki.openstreetmap.org/wiki/Zoom_levels" class="ulink" target="_top">Zoom level documentation</a>
on how precision (zoom) correlates to size on the ground. Precision for this
aggregation can be between 0 and 29, inclusive.</p>
<p><span class="strong strong"><strong>Bounding box filtering</strong></span></p>
<p>The geotile source can optionally be constrained to a specific geo bounding box, which reduces
the range of tiles used. These bounds are useful when only a specific part of a geographical area needs high
precision tiling.</p>
<a id="composite-aggregation-geotilegrid-boundingbox-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          {
            "tile": {
              "geotile_grid": {
                "field": "location",
                "precision": 22,
                "bounds": {
                  "top_left": "52.4, 4.9",
                  "bottom_right": "52.3, 5.0"
                }
              }
            }
          }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/976.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_mixing_different_value_sources"></a>Mixing different value sources<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/composite-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>The <code class="literal">sources</code> parameter accepts an array of value sources.
It is possible to mix different value sources to create composite buckets.
For example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          { "date": { "date_histogram": { "field": "timestamp", "calendar_interval": "1d" } } },
          { "product": { "terms": { "field": "product" } } }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/977.console"></div>
<p>This will create composite buckets from the values created by two value sources, a <code class="literal">date_histogram</code> and a <code class="literal">terms</code>.
Each bucket is composed of two values, one for each value source defined in the aggregation.
Any type of combinations is allowed and the order in the array is preserved
in the composite buckets.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          { "shop": { "terms": { "field": "shop" } } },
          { "product": { "terms": { "field": "product" } } },
          { "date": { "date_histogram": { "field": "timestamp", "calendar_interval": "1d" } } }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/978.console"></div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_order"></a>Order<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/composite-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>By default the composite buckets are sorted by their natural ordering. Values are sorted
in ascending order of their values. When multiple value sources are requested, the ordering is done per value
source, the first value of the composite bucket is compared to the first value of the other composite bucket and if they are equals the
next values in the composite bucket are used for tie-breaking. This means that the composite bucket
 <code class="literal">[foo, 100]</code> is considered smaller than <code class="literal">[foobar, 0]</code> because <code class="literal">foo</code> is considered smaller than <code class="literal">foobar</code>.
It is possible to define the direction of the sort for each value source by setting <code class="literal">order</code> to <code class="literal">asc</code> (default value)
or <code class="literal">desc</code> (descending order) directly in the value source definition.
For example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          { "date": { "date_histogram": { "field": "timestamp", "calendar_interval": "1d", "order": "desc" } } },
          { "product": { "terms": { "field": "product", "order": "asc" } } }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/979.console"></div>
<p>... will sort the composite bucket in descending order when comparing values from the <code class="literal">date_histogram</code> source
and in ascending order when comparing values from the <code class="literal">terms</code> source.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_missing_bucket"></a>Missing bucket<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/composite-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>By default documents without a value for a given source are ignored.
It is possible to include them in the response by setting <code class="literal">missing_bucket</code> to
<code class="literal">true</code> (defaults to <code class="literal">false</code>):</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          { "product_name": { "terms": { "field": "product", "missing_bucket": true } } }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/980.console"></div>
<p>In the example above the source <code class="literal">product_name</code> will emit an explicit <code class="literal">null</code> value
for documents without a value for the field <code class="literal">product</code>.
The <code class="literal">order</code> specified in the source dictates whether the <code class="literal">null</code> values should rank
first (ascending order, <code class="literal">asc</code>) or last (descending order, <code class="literal">desc</code>).</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_size"></a>Size<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/composite-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">size</code> parameter can be set to define how many composite buckets should be returned.
Each composite bucket is considered as a single bucket, so setting a size of 10 will return the
first 10 composite buckets created from the value sources.
The response contains the values for each composite bucket in an array containing the values extracted
from each value source. Defaults to <code class="literal">10</code>.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_pagination"></a>Pagination<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/composite-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>If the number of composite buckets is too high (or unknown) to be returned in a single response
it is possible to split the retrieval in multiple requests.
Since the composite buckets are flat by nature, the requested <code class="literal">size</code> is exactly the number of composite buckets
that will be returned in the response (assuming that they are at least <code class="literal">size</code> composite buckets to return).
If all composite buckets should be retrieved it is preferable to use a small size (<code class="literal">100</code> or <code class="literal">1000</code> for instance)
and then use the <code class="literal">after</code> parameter to retrieve the next results.
For example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "size": 2,
        "sources": [
          { "date": { "date_histogram": { "field": "timestamp", "calendar_interval": "1d" } } },
          { "product": { "terms": { "field": "product" } } }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/981.console"></div>
<p>... returns:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "my_buckets": {
      "after_key": {
        "date": 1494288000000,
        "product": "mad max"
      },
      "buckets": [
        {
          "key": {
            "date": 1494201600000,
            "product": "rocky"
          },
          "doc_count": 1
        },
        {
          "key": {
            "date": 1494288000000,
            "product": "mad max"
          },
          "doc_count": 2
        }
      ]
    }
  }
}</pre>
</div>
<p>To get the next set of buckets, resend the same aggregation with the <code class="literal">after</code>
parameter set to the <code class="literal">after_key</code> value returned in the response.
For example, this request uses the <code class="literal">after_key</code> value provided in the previous response:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "size": 2,
        "sources": [
          { "date": { "date_histogram": { "field": "timestamp", "calendar_interval": "1d", "order": "desc" } } },
          { "product": { "terms": { "field": "product", "order": "asc" } } }
        ],
        "after": { "date": 1494288000000, "product": "mad max" } <a id="CO233-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/982.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO233-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Should restrict the aggregation to buckets that sort <span class="strong strong"><strong>after</strong></span> the provided values.</p>
</td>
</tr>
</table>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>The <code class="literal">after_key</code> is <span class="strong strong"><strong>usually</strong></span> the key to the last bucket returned in
the response, but that isn&#8217;t guaranteed. Always use the returned <code class="literal">after_key</code> instead
of derriving it from the buckets.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_early_termination"></a>Early termination<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/composite-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>For optimal performance the <a class="xref" href="index-modules-index-sorting.html" title="Index Sorting">index sort</a> should be set on the index so that it matches
parts or fully the source order in the composite aggregation.
For instance the following index sort:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT my-index-000001
{
  "settings": {
    "index": {
      "sort.field": [ "username", "timestamp" ],   <a id="CO234-1"></a><i class="conum" data-value="1"></i>
      "sort.order": [ "asc", "desc" ]              <a id="CO234-2"></a><i class="conum" data-value="2"></i>
    }
  },
  "mappings": {
    "properties": {
      "username": {
        "type": "keyword",
        "doc_values": true
      },
      "timestamp": {
        "type": "date"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/983.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO234-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>This index is sorted by <code class="literal">username</code> first then by <code class="literal">timestamp</code>.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO234-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>&#8230;&#8203; in ascending order for the <code class="literal">username</code> field and in descending order for the <code class="literal">timestamp</code> field.</p>
<div class="olist orderedlist">
<ol class="orderedlist">
<li class="listitem">
could be used to optimize these composite aggregations:
</li>
</ol>
</div>
</td>
</tr>
</table>
</div>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          { "user_name": { "terms": { "field": "user_name" } } }     <a id="CO235-1"></a><i class="conum" data-value="1"></i>
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/984.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO235-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p><code class="literal">user_name</code> is a prefix of the index sort and the order matches (<code class="literal">asc</code>).</p>
</td>
</tr>
</table>
</div>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          { "user_name": { "terms": { "field": "user_name" } } }, <a id="CO236-1"></a><i class="conum" data-value="1"></i>
          { "date": { "date_histogram": { "field": "timestamp", "calendar_interval": "1d", "order": "desc" } } } <a id="CO236-2"></a><i class="conum" data-value="2"></i>
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/985.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO236-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p><code class="literal">user_name</code> is a prefix of the index sort and the order matches (<code class="literal">asc</code>).</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO236-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p><code class="literal">timestamp</code> matches also the prefix and the order matches (<code class="literal">desc</code>).</p>
</td>
</tr>
</table>
</div>
<p>In order to optimize the early termination it is advised to set <code class="literal">track_total_hits</code> in the request
to <code class="literal">false</code>. The number of total hits that match the request can be retrieved on the first request
and it would be costly to compute this number on every page:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "size": 0,
  "track_total_hits": false,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          { "user_name": { "terms": { "field": "user_name" } } },
          { "date": { "date_histogram": { "field": "timestamp", "calendar_interval": "1d", "order": "desc" } } }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/986.console"></div>
<p>Note that the order of the source is important, in the example below switching the <code class="literal">user_name</code> with the <code class="literal">timestamp</code>
would deactivate the sort optimization since this configuration wouldn&#8217;t match the index sort specification.
If the order of sources do not matter for your use case you can follow these simple guidelines:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Put the fields with the highest cardinality first.
</li>
<li class="listitem">
Make sure that the order of the field matches the order of the index sort.
</li>
<li class="listitem">
Put multi-valued fields last since they cannot be used for early termination.
</li>
</ul>
</div>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p><a class="xref" href="index-modules-index-sorting.html" title="Index Sorting">index sort</a> can slowdown indexing, it is very important to test index sorting
with your specific use case and dataset to ensure that it matches your requirement. If it doesn&#8217;t note that <code class="literal">composite</code>
aggregations will also try to early terminate on non-sorted indices if the query matches all document (<code class="literal">match_all</code> query).</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_sub_aggregations"></a>Sub-aggregations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/composite-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Like any <code class="literal">multi-bucket</code> aggregations the <code class="literal">composite</code> aggregation can hold sub-aggregations.
These sub-aggregations can be used to compute other buckets or statistics on each composite bucket created by this
parent aggregation.
For instance the following example computes the average value of a field
per composite bucket:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          { "date": { "date_histogram": { "field": "timestamp", "calendar_interval": "1d", "order": "desc" } } },
          { "product": { "terms": { "field": "product" } } }
        ]
      },
      "aggregations": {
        "the_avg": {
          "avg": { "field": "price" }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/987.console"></div>
<p>... returns:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "my_buckets": {
      "after_key": {
        "date": 1494201600000,
        "product": "rocky"
      },
      "buckets": [
        {
          "key": {
            "date": 1494460800000,
            "product": "apocalypse now"
          },
          "doc_count": 1,
          "the_avg": {
            "value": 10.0
          }
        },
        {
          "key": {
            "date": 1494374400000,
            "product": "mad max"
          },
          "doc_count": 1,
          "the_avg": {
            "value": 27.0
          }
        },
        {
          "key": {
            "date": 1494288000000,
            "product": "mad max"
          },
          "doc_count": 2,
          "the_avg": {
            "value": 22.5
          }
        },
        {
          "key": {
            "date": 1494201600000,
            "product": "rocky"
          },
          "doc_count": 1,
          "the_avg": {
            "value": 10.0
          }
        }
      ]
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_pipeline_aggregations"></a>Pipeline aggregations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/composite-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The composite agg is not currently compatible with pipeline aggregations, nor does it make sense in most cases.
E.g. due to the paging nature of composite aggs, a single logical partition (one day for example) might be spread
over multiple pages.  Since pipeline aggregations are purely post-processing on the final list of buckets,
running something like a derivative on a composite page could lead to inaccurate results as it is only taking into
account a "partial" result on that page.</p>
<p>Pipeline aggs that are self contained to a single bucket (such as <code class="literal">bucket_selector</code>) might be supported in the future.</p>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-datehistogram-aggregation"></a>Date histogram aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/datehistogram-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>This multi-bucket aggregation is similar to the normal
<a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-histogram-aggregation" title="Histogram aggregation">histogram</a>, but it can
only be used with date or date range values. Because dates are represented internally in
Elasticsearch as long values, it is possible, but not as accurate, to use the
normal <code class="literal">histogram</code> on dates as well. The main difference in the two APIs is
that here the interval can be specified using date/time expressions. Time-based
data requires special support because time-based intervals are not always a
fixed length.</p>
<p>Like the histogram, values are rounded <span class="strong strong"><strong>down</strong></span> into the closest bucket. For
example, if the interval is a calendar day, <code class="literal">2020-01-03T07:00:01Z</code> is rounded to
<code class="literal">2020-01-03T00:00:00Z</code>. Values are rounded as follows:</p>
<div class="pre_wrapper lang-java">
<pre class="programlisting prettyprint lang-java">bucket_key = Math.floor(value / interval) * interval</pre>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="calendar_and_fixed_intervals"></a>Calendar and fixed intervals<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/datehistogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>When configuring a date histogram aggregation, the interval can be specified
in two manners: calendar-aware time intervals, and fixed time intervals.</p>
<p>Calendar-aware intervals understand that daylight savings changes the length
of specific days, months have different amounts of days, and leap seconds can
be tacked onto a particular year.</p>
<p>Fixed intervals are, by contrast, always multiples of SI units and do not change
based on calendaring context.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<h3>Combined <code class="literal">interval</code> field is deprecated</h3>
<p><span class="Admonishment Admonishment--change">
[<span class="Admonishment-version u-mono u-strikethrough">7.2</span>]
<span class="Admonishment-detail">
Deprecated in 7.2. <code class="literal">interval</code> field is deprecated
</span>
</span> Historically both calendar and fixed
intervals were configured in a single <code class="literal">interval</code> field, which led to confusing
semantics. Specifying <code class="literal">1d</code> would be assumed as a calendar-aware time,
whereas <code class="literal">2d</code> would be interpreted as fixed time. To get "one day" of fixed time,
the user would need to specify the next smaller unit (in this case, <code class="literal">24h</code>).</p>
<p>This combined behavior was often unknown to users, and even when knowledgeable about
the behavior it was difficult to use and confusing.</p>
<p>This behavior has been deprecated in favor of two new, explicit fields: <code class="literal">calendar_interval</code>
and <code class="literal">fixed_interval</code>.</p>
<p>By forcing a choice between calendar and intervals up front, the semantics of the interval
are clear to the user immediately and there is no ambiguity.  The old <code class="literal">interval</code> field
will be removed in the future.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="calendar_intervals"></a>Calendar intervals<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/datehistogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Calendar-aware intervals are configured with the <code class="literal">calendar_interval</code> parameter.
You can specify calendar intervals using the unit name, such as <code class="literal">month</code>, or as a
single unit quantity, such as <code class="literal">1M</code>. For example, <code class="literal">day</code> and <code class="literal">1d</code> are equivalent.
Multiple quantities, such as <code class="literal">2d</code>, are not supported.</p>
<p>The accepted calendar intervals are:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">minute</code>, <code class="literal">1m</code>
</span>
</dt>
<dd>
All minutes begin at 00 seconds.
One minute is the interval between 00 seconds of the first minute and 00
seconds of the following minute in the specified time zone, compensating for any
intervening leap seconds, so that the number of minutes and seconds past the
hour is the same at the start and end.
</dd>
<dt>
<span class="term">
<code class="literal">hour</code>, <code class="literal">1h</code>
</span>
</dt>
<dd>
All hours begin at 00 minutes and 00 seconds.
One hour (1h) is the interval between 00:00 minutes of the first hour and 00:00
minutes of the following hour in the specified time zone, compensating for any
intervening leap seconds, so that the number of minutes and seconds past the hour
is the same at the start and end.
</dd>
<dt>
<span class="term">
<code class="literal">day</code>, <code class="literal">1d</code>
</span>
</dt>
<dd>
All days begin at the earliest possible time, which is usually 00:00:00
(midnight).
One day (1d) is the interval between the start of the day and the start of
of the following day in the specified time zone, compensating for any intervening
time changes.
</dd>
<dt>
<span class="term">
<code class="literal">week</code>, <code class="literal">1w</code>
</span>
</dt>
<dd>
One week is the interval between the start day_of_week:hour:minute:second
and the same day of the week and time of the following week in the specified
time zone.
</dd>
<dt>
<span class="term">
<code class="literal">month</code>, <code class="literal">1M</code>
</span>
</dt>
<dd>
One month is the interval between the start day of the month and time of
day and the same day of the month and time of the following month in the specified
time zone, so that the day of the month and time of day are the same at the start
and end.
</dd>
<dt>
<span class="term">
<code class="literal">quarter</code>, <code class="literal">1q</code>
</span>
</dt>
<dd>
One quarter is the interval between the start day of the month and
time of day and the same day of the month and time of day three months later,
so that the day of the month and time of day are the same at the start and end.<br>
</dd>
<dt>
<span class="term">
<code class="literal">year</code>, <code class="literal">1y</code>
</span>
</dt>
<dd>
One year is the interval between the start day of the month and time of
day and the same day of the month and time of day the following year in the
specified time zone, so that the date and time are the same at the start and end.<br>
</dd>
</dl>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="calendar_interval_examples"></a>Calendar interval examples<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/datehistogram-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>As an example, here is an aggregation requesting bucket intervals of a month in calendar time:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "sales_over_time": {
      "date_histogram": {
        "field": "date",
        "calendar_interval": "month"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/988.console"></div>
<p>If you attempt to use multiples of calendar units, the aggregation will fail because only
singular calendar units are supported:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "sales_over_time": {
      "date_histogram": {
        "field": "date",
        "calendar_interval": "2d"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/989.console"></div>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "error" : {
    "root_cause" : [...],
    "type" : "x_content_parse_exception",
    "reason" : "[1:82] [date_histogram] failed to parse field [calendar_interval]",
    "caused_by" : {
      "type" : "illegal_argument_exception",
      "reason" : "The supplied interval [2d] could not be parsed as a calendar interval.",
      "stack_trace" : "java.lang.IllegalArgumentException: The supplied interval [2d] could not be parsed as a calendar interval."
    }
  }
}</pre>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="fixed_intervals"></a>Fixed intervals<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/datehistogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Fixed intervals are configured with the <code class="literal">fixed_interval</code> parameter.</p>
<p>In contrast to calendar-aware intervals, fixed intervals are a fixed number of SI
units and never deviate, regardless of where they fall on the calendar. One second
is always composed of <code class="literal">1000ms</code>. This allows fixed intervals to be specified in
any multiple of the supported units.</p>
<p>However, it means fixed intervals cannot express other units such as months,
since the duration of a month is not a fixed quantity. Attempting to specify
a calendar interval like month or quarter will throw an exception.</p>
<p>The accepted units for fixed intervals are:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
milliseconds (<code class="literal">ms</code>)
</span>
</dt>
<dd>
A single millisecond. This is a very, very small interval.
</dd>
<dt>
<span class="term">
seconds (<code class="literal">s</code>)
</span>
</dt>
<dd>
Defined as 1000 milliseconds each.
</dd>
<dt>
<span class="term">
minutes (<code class="literal">m</code>)
</span>
</dt>
<dd>
Defined as 60 seconds each (60,000 milliseconds).
All minutes begin at 00 seconds.
</dd>
<dt>
<span class="term">
hours (<code class="literal">h</code>)
</span>
</dt>
<dd>
Defined as 60 minutes each (3,600,000 milliseconds).
All hours begin at 00 minutes and 00 seconds.
</dd>
<dt>
<span class="term">
days (<code class="literal">d</code>)
</span>
</dt>
<dd>
Defined as 24 hours (86,400,000 milliseconds).
All days begin at the earliest possible time, which is usually 00:00:00
(midnight).
</dd>
</dl>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="fixed_interval_examples"></a>Fixed interval examples<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/datehistogram-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>If we try to recreate the "month" <code class="literal">calendar_interval</code> from earlier, we can approximate that with
30 fixed days:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "sales_over_time": {
      "date_histogram": {
        "field": "date",
        "fixed_interval": "30d"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/990.console"></div>
<p>But if we try to use a calendar unit that is not supported, such as weeks, we&#8217;ll get an exception:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "sales_over_time": {
      "date_histogram": {
        "field": "date",
        "fixed_interval": "2w"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/991.console"></div>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "error" : {
    "root_cause" : [...],
    "type" : "x_content_parse_exception",
    "reason" : "[1:82] [date_histogram] failed to parse field [fixed_interval]",
    "caused_by" : {
      "type" : "illegal_argument_exception",
      "reason" : "failed to parse setting [date_histogram.fixedInterval] with value [2w] as a time value: unit is missing or unrecognized",
      "stack_trace" : "java.lang.IllegalArgumentException: failed to parse setting [date_histogram.fixedInterval] with value [2w] as a time value: unit is missing or unrecognized"
    }
  }
}</pre>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="datehistogram-aggregation-notes"></a>Date histogram usage notes<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/datehistogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>In all cases, when the specified end time does not exist, the actual end time is
the closest available time after the specified end.</p>
<p>Widely distributed applications must also consider vagaries such as countries that
start and stop daylight savings time at 12:01 A.M., so end up with one minute of
Sunday followed by an additional 59 minutes of Saturday once a year, and countries
that decide to move across the international date line. Situations like
that can make irregular time zone offsets seem easy.</p>
<p>As always, rigorous testing, especially around time-change events, will ensure
that your time interval specification is
what you intend it to be.</p>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>To avoid unexpected results, all connected servers and clients must
sync to a reliable network time service.</p>
</div>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>Fractional time values are not supported, but you can address this by
shifting to another time unit (e.g., <code class="literal">1.5h</code> could instead be specified as <code class="literal">90m</code>).</p>
</div>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>You can also specify time values using abbreviations supported by
<a class="xref" href="api-conventions.html#time-units" title="Time units">time units</a> parsing.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="datehistogram-aggregation-keys"></a>Keys<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/datehistogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Internally, a date is represented as a 64 bit number representing a timestamp
in milliseconds-since-the-epoch (01/01/1970 midnight UTC). These timestamps are
returned as the <code class="literal">key</code> name of the bucket. The <code class="literal">key_as_string</code> is the same
timestamp converted to a formatted
date string using the <code class="literal">format</code> parameter specification:</p>
<div class="tip admon">
<div class="icon"></div>
<div class="admon_content">
<p>If you don&#8217;t specify <code class="literal">format</code>, the first date
<a class="xref" href="mapping-params.html#mapping-date-format" title="format">format</a> specified in the field mapping is used.</p>
</div>
</div>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "sales_over_time": {
      "date_histogram": {
        "field": "date",
        "calendar_interval": "1M",
        "format": "yyyy-MM-dd" <a id="CO237-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/992.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO237-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Supports expressive date <a class="xref" href="search-aggregations-bucket.html#date-format-pattern" title="Date Format/Pattern">format pattern</a></p>
</td>
</tr>
</table>
</div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "sales_over_time": {
      "buckets": [
        {
          "key_as_string": "2015-01-01",
          "key": 1420070400000,
          "doc_count": 3
        },
        {
          "key_as_string": "2015-02-01",
          "key": 1422748800000,
          "doc_count": 2
        },
        {
          "key_as_string": "2015-03-01",
          "key": 1425168000000,
          "doc_count": 2
        }
      ]
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="datehistogram-aggregation-time-zone"></a>Time zone<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/datehistogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Elasticsearch stores date-times in Coordinated Universal Time (UTC). By default, all bucketing and
rounding is also done in UTC. Use the <code class="literal">time_zone</code> parameter to indicate
that bucketing should use a different time zone.</p>
<p>For example, if the interval is a calendar day and the time zone is
<code class="literal">America/New_York</code> then <code class="literal">2020-01-03T01:00:01Z</code> is :
# Converted to <code class="literal">2020-01-02T18:00:01</code>
# Rounded down to <code class="literal">2020-01-02T00:00:00</code>
# Then converted back to UTC to produce <code class="literal">2020-01-02T05:00:00:00Z</code>
# Finally, when the bucket is turned into a string key it is printed in
  <code class="literal">America/New_York</code> so it&#8217;ll display as <code class="literal">"2020-01-02T00:00:00"</code>.</p>
<p>It looks like:</p>
<div class="pre_wrapper lang-java">
<pre class="programlisting prettyprint lang-java">bucket_key = localToUtc(Math.floor(utcToLocal(value) / interval) * interval))</pre>
</div>
<p>You can specify time zones as an ISO 8601 UTC offset (e.g. <code class="literal">+01:00</code> or
<code class="literal">-08:00</code>) or as an IANA time zone ID,
such as <code class="literal">America/Los_Angeles</code>.</p>
<p>Consider the following example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT my-index-000001/_doc/1?refresh
{
  "date": "2015-10-01T00:30:00Z"
}

PUT my-index-000001/_doc/2?refresh
{
  "date": "2015-10-01T01:30:00Z"
}

GET my-index-000001/_search?size=0
{
  "aggs": {
    "by_day": {
      "date_histogram": {
        "field":     "date",
        "calendar_interval":  "day"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/993.console"></div>
<p>If you don&#8217;t specify a time zone, UTC is used. This would result in both of these
documents being placed into the same day bucket, which starts at midnight UTC
on 1 October 2015:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "by_day": {
      "buckets": [
        {
          "key_as_string": "2015-10-01T00:00:00.000Z",
          "key":           1443657600000,
          "doc_count":     2
        }
      ]
    }
  }
}</pre>
</div>
<p>If you specify a <code class="literal">time_zone</code> of <code class="literal">-01:00</code>, midnight in that time zone is one hour
before midnight UTC:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET my-index-000001/_search?size=0
{
  "aggs": {
    "by_day": {
      "date_histogram": {
        "field":     "date",
        "calendar_interval":  "day",
        "time_zone": "-01:00"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/994.console"></div>
<p>Now the first document falls into the bucket for 30 September 2015, while the
second document falls into the bucket for 1 October 2015:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "by_day": {
      "buckets": [
        {
          "key_as_string": "2015-09-30T00:00:00.000-01:00", <a id="CO238-1"></a><i class="conum" data-value="1"></i>
          "key": 1443574800000,
          "doc_count": 1
        },
        {
          "key_as_string": "2015-10-01T00:00:00.000-01:00", <a id="CO238-2"></a><i class="conum" data-value="1"></i>
          "key": 1443661200000,
          "doc_count": 1
        }
      ]
    }
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO238-1"><i class="conum" data-value="1"></i></a><a href="#CO238-2"></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">key_as_string</code> value represents midnight on each day
in the specified time zone.</p>
</td>
</tr>
</table>
</div>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>Many time zones shift their clocks for daylight savings time. Buckets
close to the moment when those changes happen can have slightly different sizes
than you would expect from the <code class="literal">calendar_interval</code> or <code class="literal">fixed_interval</code>.
For example, consider a DST start in the <code class="literal">CET</code> time zone: on 27 March 2016 at 2am,
clocks were turned forward 1 hour to 3am local time. If you use <code class="literal">day</code> as the
<code class="literal">calendar_interval</code>, the bucket covering that day will only hold data for 23
hours instead of the usual 24 hours for other buckets. The same is true for
shorter intervals, like a <code class="literal">fixed_interval</code> of <code class="literal">12h</code>, where you&#8217;ll have only a 11h
bucket on the morning of 27 March when the DST shift happens.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-bucket-datehistogram-offset"></a>Offset<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/datehistogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Use the <code class="literal">offset</code> parameter to change the start value of each bucket by the
specified positive (<code class="literal">+</code>) or negative offset (<code class="literal">-</code>) duration, such as <code class="literal">1h</code> for
an hour, or <code class="literal">1d</code> for a day. See <a class="xref" href="api-conventions.html#time-units" title="Time units">Time units</a> for more possible time
duration options.</p>
<p>For example, when using an interval of <code class="literal">day</code>, each bucket runs from midnight
to midnight. Setting the <code class="literal">offset</code> parameter to <code class="literal">+6h</code> changes each bucket
to run from 6am to 6am:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT my-index-000001/_doc/1?refresh
{
  "date": "2015-10-01T05:30:00Z"
}

PUT my-index-000001/_doc/2?refresh
{
  "date": "2015-10-01T06:30:00Z"
}

GET my-index-000001/_search?size=0
{
  "aggs": {
    "by_day": {
      "date_histogram": {
        "field":     "date",
        "calendar_interval":  "day",
        "offset":    "+6h"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/995.console"></div>
<p>Instead of a single bucket starting at midnight, the above request groups the
documents into buckets starting at 6am:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "by_day": {
      "buckets": [
        {
          "key_as_string": "2015-09-30T06:00:00.000Z",
          "key": 1443592800000,
          "doc_count": 1
        },
        {
          "key_as_string": "2015-10-01T06:00:00.000Z",
          "key": 1443679200000,
          "doc_count": 1
        }
      ]
    }
  }
}</pre>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>The start <code class="literal">offset</code> of each bucket is calculated after <code class="literal">time_zone</code>
adjustments have been made.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="date-histogram-keyed-response"></a>Keyed Response<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/datehistogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Setting the <code class="literal">keyed</code> flag to <code class="literal">true</code> associates a unique string key with each
bucket and returns the ranges as a hash rather than an array:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "sales_over_time": {
      "date_histogram": {
        "field": "date",
        "calendar_interval": "1M",
        "format": "yyyy-MM-dd",
        "keyed": true
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/996.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "sales_over_time": {
      "buckets": {
        "2015-01-01": {
          "key_as_string": "2015-01-01",
          "key": 1420070400000,
          "doc_count": 3
        },
        "2015-02-01": {
          "key_as_string": "2015-02-01",
          "key": 1422748800000,
          "doc_count": 2
        },
        "2015-03-01": {
          "key_as_string": "2015-03-01",
          "key": 1425168000000,
          "doc_count": 2
        }
      }
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="date-histogram-scripts"></a>Scripts<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/datehistogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>As with the normal <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-histogram-aggregation" title="Histogram aggregation">histogram</a>,
both document-level scripts and
value-level scripts are supported. You can control the order of the returned
buckets using the <code class="literal">order</code>
settings and filter the returned buckets based on a <code class="literal">min_doc_count</code> setting
(by default all buckets between the first
bucket that matches documents and the last one are returned). This histogram
also supports the <code class="literal">extended_bounds</code>
setting, which enables extending the bounds of the histogram beyond the data
itself, and <code class="literal">hard_bounds</code> that limits the histogram to specified bounds.
For more information, see
<a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-histogram-aggregation-extended-bounds"><code class="literal">Extended Bounds</code></a> and
<a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-histogram-aggregation-hard-bounds"><code class="literal">Hard Bounds</code></a>.</p>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="date-histogram-missing-value"></a>Missing value<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/datehistogram-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>The <code class="literal">missing</code> parameter defines how to treat documents that are missing a value.
By default, they are ignored, but it is also possible to treat them as if they
have a value.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "sale_date": {
      "date_histogram": {
        "field": "date",
        "calendar_interval": "year",
        "missing": "2000/01/01" <a id="CO239-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/997.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO239-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Documents without a value in the <code class="literal">publish_date</code> field will fall into the
same bucket as documents that have the value <code class="literal">2000-01-01</code>.</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="date-histogram-order"></a>Order<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/datehistogram-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>By default the returned buckets are sorted by their <code class="literal">key</code> ascending, but you can
control the order using
the <code class="literal">order</code> setting. This setting supports the same <code class="literal">order</code> functionality as
<a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation-order" title="Order"><code class="literal">Terms Aggregation</code></a>.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="date-histogram-aggregate-scripts"></a>Using a script to aggregate by day of the week<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/datehistogram-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>When you need to aggregate the results by day of the week, use a script that
returns the day of the week:</p>
<a id="datehistogram-aggregation-script-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "dayOfWeek": {
      "terms": {
        "script": {
          "lang": "painless",
          "source": "doc['date'].value.dayOfWeekEnum.value"
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/998.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "dayOfWeek": {
      "doc_count_error_upper_bound": 0,
      "sum_other_doc_count": 0,
      "buckets": [
        {
          "key": "7",
          "doc_count": 4
        },
        {
          "key": "4",
          "doc_count": 3
        }
      ]
    }
  }
}</pre>
</div>
<p>The response will contain all the buckets having the relative day of
the week as key : 1 for Monday, 2 for Tuesday&#8230;&#8203; 7 for Sunday.</p>
</div>

</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-daterange-aggregation"></a>Date range aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/daterange-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A range aggregation that is dedicated for date values. The main difference
between this aggregation and the normal
<a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-range-aggregation" title="Range aggregation">range</a>
aggregation is that the <code class="literal">from</code> and <code class="literal">to</code> values can be expressed in
<a class="xref" href="api-conventions.html#date-math" title="Date Math">Date Math</a> expressions, and it is also possible to specify a date
format by which the <code class="literal">from</code> and <code class="literal">to</code> response fields will be returned.
Note that this aggregation includes the <code class="literal">from</code> value and excludes the <code class="literal">to</code> value
for each range.</p>
<p>Example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "range": {
      "date_range": {
        "field": "date",
        "format": "MM-yyyy",
        "ranges": [
          { "to": "now-10M/M" },  <a id="CO240-1"></a><i class="conum" data-value="1"></i>
          { "from": "now-10M/M" } <a id="CO240-2"></a><i class="conum" data-value="2"></i>
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/999.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO240-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>&lt; now minus 10 months, rounded down to the start of the month.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO240-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>&gt;= now minus 10 months, rounded down to the start of the month.</p>
</td>
</tr>
</table>
</div>
<p>In the example above, we created two range buckets, the first will "bucket" all
documents dated prior to 10 months ago and the second will "bucket" all
documents dated since 10 months ago</p>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "range": {
      "buckets": [
        {
          "to": 1.4436576E12,
          "to_as_string": "10-2015",
          "doc_count": 7,
          "key": "*-10-2015"
        },
        {
          "from": 1.4436576E12,
          "from_as_string": "10-2015",
          "doc_count": 0,
          "key": "10-2015-*"
        }
      ]
    }
  }
}</pre>
</div>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>If a format or date value is incomplete, the date range aggregation
replaces any missing components with default values. See
<a class="xref" href="term-level-queries.html#missing-date-components" title="Missing date components">Missing date components</a>.</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_missing_values_2"></a>Missing Values<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/daterange-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">missing</code> parameter defines how documents that are missing a value should
be treated. By default they will be ignored but it is also possible to treat
them as if they had a value. This is done by adding a set of fieldname :
value mappings to specify default values per field.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
   "aggs": {
       "range": {
           "date_range": {
               "field": "date",
               "missing": "1976/11/30",
               "ranges": [
                  {
                    "key": "Older",
                    "to": "2016/02/01"
                  }, <a id="CO241-1"></a><i class="conum" data-value="1"></i>
                  {
                    "key": "Newer",
                    "from": "2016/02/01",
                    "to" : "now/d"
                  }
              ]
          }
      }
   }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1000.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO241-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Documents without a value in the <code class="literal">date</code> field will be added to the "Older"
bucket, as if they had a date value of "1976-11-30".</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="date-format-pattern"></a>Date Format/Pattern<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/daterange-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>this information was copied from
<a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html" class="ulink" target="_top">DateTimeFormatter</a></p>
</div>
</div>
<p>All ASCII letters are reserved as format pattern letters, which are defined
as follows:</p>
<div class="informaltable">
<table border="1" cellpadding="4px">
<colgroup>
<col class="col_1"/>
<col class="col_2"/>
<col class="col_3"/>
<col class="col_4"/>
</colgroup>
<thead>
<tr>
<th align="left" valign="top">Symbol</th>
<th align="left" valign="top">Meaning</th>
<th align="left" valign="top">Presentation</th>
<th align="left" valign="top">Examples</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p>G</p></td>
<td align="left" valign="top"><p>era</p></td>
<td align="left" valign="top"><p>text</p></td>
<td align="left" valign="top"><p>AD; Anno Domini; A</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>u</p></td>
<td align="left" valign="top"><p>year</p></td>
<td align="left" valign="top"><p>year</p></td>
<td align="left" valign="top"><p>2004; 04</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>y</p></td>
<td align="left" valign="top"><p>year-of-era</p></td>
<td align="left" valign="top"><p>year</p></td>
<td align="left" valign="top"><p>2004; 04</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>D</p></td>
<td align="left" valign="top"><p>day-of-year</p></td>
<td align="left" valign="top"><p>number</p></td>
<td align="left" valign="top"><p>189</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>M/L</p></td>
<td align="left" valign="top"><p>month-of-year</p></td>
<td align="left" valign="top"><p>number/text</p></td>
<td align="left" valign="top"><p>7; 07; Jul; July; J</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>d</p></td>
<td align="left" valign="top"><p>day-of-month</p></td>
<td align="left" valign="top"><p>number</p></td>
<td align="left" valign="top"><p>10</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>Q/q</p></td>
<td align="left" valign="top"><p>quarter-of-year</p></td>
<td align="left" valign="top"><p>number/text</p></td>
<td align="left" valign="top"><p>3; 03; Q3; 3rd quarter</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>Y</p></td>
<td align="left" valign="top"><p>week-based-year</p></td>
<td align="left" valign="top"><p>year</p></td>
<td align="left" valign="top"><p>1996; 96</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>w</p></td>
<td align="left" valign="top"><p>week-of-week-based-year</p></td>
<td align="left" valign="top"><p>number</p></td>
<td align="left" valign="top"><p>27</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>W</p></td>
<td align="left" valign="top"><p>week-of-month</p></td>
<td align="left" valign="top"><p>number</p></td>
<td align="left" valign="top"><p>4</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>E</p></td>
<td align="left" valign="top"><p>day-of-week</p></td>
<td align="left" valign="top"><p>text</p></td>
<td align="left" valign="top"><p>Tue; Tuesday; T</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>e/c</p></td>
<td align="left" valign="top"><p>localized day-of-week</p></td>
<td align="left" valign="top"><p>number/text</p></td>
<td align="left" valign="top"><p>2; 02; Tue; Tuesday; T</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>F</p></td>
<td align="left" valign="top"><p>week-of-month</p></td>
<td align="left" valign="top"><p>number</p></td>
<td align="left" valign="top"><p>3</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>a</p></td>
<td align="left" valign="top"><p>am-pm-of-day</p></td>
<td align="left" valign="top"><p>text</p></td>
<td align="left" valign="top"><p>PM</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>h</p></td>
<td align="left" valign="top"><p>clock-hour-of-am-pm (1-12)</p></td>
<td align="left" valign="top"><p>number</p></td>
<td align="left" valign="top"><p>12</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>K</p></td>
<td align="left" valign="top"><p>hour-of-am-pm (0-11)</p></td>
<td align="left" valign="top"><p>number</p></td>
<td align="left" valign="top"><p>0</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>k</p></td>
<td align="left" valign="top"><p>clock-hour-of-am-pm (1-24)</p></td>
<td align="left" valign="top"><p>number</p></td>
<td align="left" valign="top"><p>0</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>H</p></td>
<td align="left" valign="top"><p>hour-of-day (0-23)</p></td>
<td align="left" valign="top"><p>number</p></td>
<td align="left" valign="top"><p>0</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>m</p></td>
<td align="left" valign="top"><p>minute-of-hour</p></td>
<td align="left" valign="top"><p>number</p></td>
<td align="left" valign="top"><p>30</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>s</p></td>
<td align="left" valign="top"><p>second-of-minute</p></td>
<td align="left" valign="top"><p>number</p></td>
<td align="left" valign="top"><p>55</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>S</p></td>
<td align="left" valign="top"><p>fraction-of-second</p></td>
<td align="left" valign="top"><p>fraction</p></td>
<td align="left" valign="top"><p>978</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>A</p></td>
<td align="left" valign="top"><p>milli-of-day</p></td>
<td align="left" valign="top"><p>number</p></td>
<td align="left" valign="top"><p>1234</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>n</p></td>
<td align="left" valign="top"><p>nano-of-second</p></td>
<td align="left" valign="top"><p>number</p></td>
<td align="left" valign="top"><p>987654321</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>N</p></td>
<td align="left" valign="top"><p>nano-of-day</p></td>
<td align="left" valign="top"><p>number</p></td>
<td align="left" valign="top"><p>1234000000</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>V</p></td>
<td align="left" valign="top"><p>time-zone ID</p></td>
<td align="left" valign="top"><p>zone-id</p></td>
<td align="left" valign="top"><p>America/Los_Angeles; Z; -08:30</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>z</p></td>
<td align="left" valign="top"><p>time-zone name</p></td>
<td align="left" valign="top"><p>zone-name</p></td>
<td align="left" valign="top"><p>Pacific Standard Time; PST</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>O</p></td>
<td align="left" valign="top"><p>localized zone-offset</p></td>
<td align="left" valign="top"><p>offset-O</p></td>
<td align="left" valign="top"><p>GMT+8; GMT+08:00; UTC-08:00;</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>X</p></td>
<td align="left" valign="top"><p>zone-offset <em>Z</em> for zero</p></td>
<td align="left" valign="top"><p>offset-X</p></td>
<td align="left" valign="top"><p>Z; -08; -0830; -08:30; -083015; -08:30:15;</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>x</p></td>
<td align="left" valign="top"><p>zone-offset</p></td>
<td align="left" valign="top"><p>offset-x</p></td>
<td align="left" valign="top"><p>+0000; -08; -0830; -08:30; -083015; -08:30:15;</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>Z</p></td>
<td align="left" valign="top"><p>zone-offset</p></td>
<td align="left" valign="top"><p>offset-Z</p></td>
<td align="left" valign="top"><p>+0000; -0800; -08:00;</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>p</p></td>
<td align="left" valign="top"><p>pad next</p></td>
<td align="left" valign="top"><p>pad modifier</p></td>
<td align="left" valign="top"><p>1</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>'</p></td>
<td align="left" valign="top"><p>escape for text</p></td>
<td align="left" valign="top"><p>delimiter</p></td>
<td align="left" valign="top"><p>''</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>single quote</p></td>
<td align="left" valign="top"><p>literal</p></td>
<td align="left" valign="top"><p>'</p></td>
<td align="left" valign="top"><p>[</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>optional section start</p></td>
<td align="left" valign="top"><p>]</p></td>
<td align="left" valign="top"><p>optional section end</p></td>
<td align="left" valign="top"><p>#</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>reserved for future use</p></td>
<td align="left" valign="top"><p>{</p></td>
<td align="left" valign="top"><p>reserved for future use</p></td>
<td align="left" valign="top"><p>}</p></td>
</tr>
</tbody>
</table>
</div>
<p>The count of pattern letters determines the format.</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
Text
</span>
</dt>
<dd>
The text style is determined based on the number of pattern letters
used. Less than 4 pattern letters will use the short form. Exactly 4
pattern letters will use the full form. Exactly 5 pattern letters will use
the narrow form. Pattern letters <code class="literal">L</code>, <code class="literal">c</code>, and <code class="literal">q</code> specify the stand-alone
form of the text styles.
</dd>
<dt>
<span class="term">
Number
</span>
</dt>
<dd>
If the count of letters is one, then the value is output using
the minimum number of digits and without padding. Otherwise, the count of
digits is used as the width of the output field, with the value
zero-padded as necessary. The following pattern letters have constraints
on the count of letters. Only one letter of <code class="literal">c</code> and <code class="literal">F</code> can be specified.
Up to two letters of <code class="literal">d</code>, <code class="literal">H</code>, <code class="literal">h</code>, <code class="literal">K</code>, <code class="literal">k</code>, <code class="literal">m</code>, and <code class="literal">s</code> can be
specified. Up to three letters of <code class="literal">D</code> can be specified.
</dd>
<dt>
<span class="term">
Number/Text
</span>
</dt>
<dd>
If the count of pattern letters is 3 or greater, use the
Text rules above. Otherwise use the Number rules above.
</dd>
<dt>
<span class="term">
Fraction
</span>
</dt>
<dd>
Outputs the nano-of-second field as a fraction-of-second. The
nano-of-second value has nine digits, thus the count of pattern letters is
from 1 to 9. If it is less than 9, then the nano-of-second value is
truncated, with only the most significant digits being output.
</dd>
<dt>
<span class="term">
Year
</span>
</dt>
<dd>
The count of letters determines the minimum field width below which
padding is used. If the count of letters is two, then a reduced two digit
form is used. For printing, this outputs the rightmost two digits. For
parsing, this will parse using the base value of 2000, resulting in a year
within the range 2000 to 2099 inclusive. If the count of letters is less
than four (but not two), then the sign is only output for negative years
as per <code class="literal">SignStyle.NORMAL</code>. Otherwise, the sign is output if the pad width is
exceeded, as per <code class="literal">SignStyle.EXCEEDS_PAD</code>.
</dd>
<dt>
<span class="term">
ZoneId
</span>
</dt>
<dd>
This outputs the time-zone ID, such as <code class="literal">Europe/Paris</code>. If the
count of letters is two, then the time-zone ID is output. Any other count
of letters throws <code class="literal">IllegalArgumentException</code>.
</dd>
<dt>
<span class="term">
Zone names
</span>
</dt>
<dd>
This outputs the display name of the time-zone ID. If the
count of letters is one, two or three, then the short name is output. If
the count of letters is four, then the full name is output. Five or more
letters throws <code class="literal">IllegalArgumentException</code>.
</dd>
<dt>
<span class="term">
Offset X and x
</span>
</dt>
<dd>
This formats the offset based on the number of pattern
letters. One letter outputs just the hour, such as <code class="literal">+01</code>, unless the
minute is non-zero in which case the minute is also output, such as
<code class="literal">+0130</code>. Two letters outputs the hour and minute, without a colon, such as
<code class="literal">+0130</code>. Three letters outputs the hour and minute, with a colon, such as
<code class="literal">+01:30</code>. Four letters outputs the hour and minute and optional second,
without a colon, such as <code class="literal">+013015</code>. Five letters outputs the hour and
minute and optional second, with a colon, such as <code class="literal">+01:30:15</code>. Six or
more letters throws <code class="literal">IllegalArgumentException</code>. Pattern letter <code class="literal">X</code> (upper
case) will output <code class="literal">Z</code> when the offset to be output would be zero,
whereas pattern letter <code class="literal">x</code> (lower case) will output <code class="literal">+00</code>, <code class="literal">+0000</code>, or
<code class="literal">+00:00</code>.
</dd>
<dt>
<span class="term">
Offset O
</span>
</dt>
<dd>
This formats the localized offset based on the number of
pattern letters. One letter outputs the short form of the localized
offset, which is localized offset text, such as <code class="literal">GMT</code>, with hour without
leading zero, optional 2-digit minute and second if non-zero, and colon,
for example <code class="literal">GMT+8</code>. Four letters outputs the full form, which is
localized offset text, such as <code class="literal">GMT, with 2-digit hour and minute
field, optional second field if non-zero, and colon, for example
`GMT+08:00</code>. Any other count of letters throws
<code class="literal">IllegalArgumentException</code>.
</dd>
<dt>
<span class="term">
Offset Z
</span>
</dt>
<dd>
This formats the offset based on the number of pattern letters.
One, two or three letters outputs the hour and minute, without a colon,
such as <code class="literal">+0130</code>. The output will be <code class="literal">+0000</code> when the offset is zero.
Four letters outputs the full form of localized offset, equivalent to
four letters of Offset-O. The output will be the corresponding localized
offset text if the offset is zero. Five letters outputs the hour,
minute, with optional second if non-zero, with colon. It outputs <code class="literal">Z</code> if
the offset is zero. Six or more letters throws IllegalArgumentException.
</dd>
<dt>
<span class="term">
Optional section
</span>
</dt>
<dd>
The optional section markers work exactly like calling
<code class="literal">DateTimeFormatterBuilder.optionalStart()</code> and
<code class="literal">DateTimeFormatterBuilder.optionalEnd()</code>.
</dd>
<dt>
<span class="term">
Pad modifier
</span>
</dt>
<dd>
Modifies the pattern that immediately follows to be padded
with spaces. The pad width is determined by the number of pattern letters.
This is the same as calling <code class="literal">DateTimeFormatterBuilder.padNext(int)</code>.
</dd>
</dl>
</div>
<p>For example, <code class="literal">ppH</code> outputs the hour-of-day padded on the left with spaces to a width of 2.</p>
<p>Any unrecognized letter is an error. Any non-letter character, other than
<code class="literal">[</code>, <code class="literal">]</code>, <code class="literal">{</code>, <code class="literal">}</code>, <code class="literal">#</code> and the single quote will be output directly.
Despite this, it is recommended to use single quotes around all characters
that you want to output directly to ensure that future changes do not
break your application.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="time-zones"></a>Time zone in date range aggregations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/daterange-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Dates can be converted from another time zone to UTC by specifying the
<code class="literal">time_zone</code> parameter.</p>
<p>Time zones may either be specified as an ISO 8601 UTC offset (e.g. +01:00 or
-08:00) or as one of the time zone ids from the TZ database.</p>
<p>The <code class="literal">time_zone</code> parameter is also applied to rounding in date math expressions.
As an example, to round to the beginning of the day in the CET time zone, you
can do the following:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
   "aggs": {
       "range": {
           "date_range": {
               "field": "date",
               "time_zone": "CET",
               "ranges": [
                  { "to": "2016/02/01" }, <a id="CO242-1"></a><i class="conum" data-value="1"></i>
                  { "from": "2016/02/01", "to" : "now/d" }, <a id="CO242-2"></a><i class="conum" data-value="2"></i>
                  { "from": "now/d" }
              ]
          }
      }
   }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1001.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO242-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>This date will be converted to <code class="literal">2016-02-01T00:00:00.000+01:00</code>.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO242-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p><code class="literal">now/d</code> will be rounded to the beginning of the day in the CET time zone.</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_keyed_response"></a>Keyed Response<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/daterange-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Setting the <code class="literal">keyed</code> flag to <code class="literal">true</code> will associate a unique string key with each
bucket and return the ranges as a hash rather than an array:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "range": {
      "date_range": {
        "field": "date",
        "format": "MM-yyy",
        "ranges": [
          { "to": "now-10M/M" },
          { "from": "now-10M/M" }
        ],
        "keyed": true
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1002.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "range": {
      "buckets": {
        "*-10-2015": {
          "to": 1.4436576E12,
          "to_as_string": "10-2015",
          "doc_count": 7
        },
        "10-2015-*": {
          "from": 1.4436576E12,
          "from_as_string": "10-2015",
          "doc_count": 0
        }
      }
    }
  }
}</pre>
</div>
<p>It is also possible to customize the key for each range:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "range": {
      "date_range": {
        "field": "date",
        "format": "MM-yyy",
        "ranges": [
          { "from": "01-2015", "to": "03-2015", "key": "quarter_01" },
          { "from": "03-2015", "to": "06-2015", "key": "quarter_02" }
        ],
        "keyed": true
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1003.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "range": {
      "buckets": {
        "quarter_01": {
          "from": 1.4200704E12,
          "from_as_string": "01-2015",
          "to": 1.425168E12,
          "to_as_string": "03-2015",
          "doc_count": 5
        },
        "quarter_02": {
          "from": 1.425168E12,
          "from_as_string": "03-2015",
          "to": 1.4331168E12,
          "to_as_string": "06-2015",
          "doc_count": 2
        }
      }
    }
  }
}</pre>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-diversified-sampler-aggregation"></a>Diversified sampler aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/diversified-sampler-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>Like the <code class="literal">sampler</code> aggregation this is a filtering aggregation used to limit any sub aggregations' processing to a sample of the top-scoring documents.
The <code class="literal">diversified_sampler</code> aggregation adds the ability to limit the number of matches that share a common value such as an "author".</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>Any good market researcher will tell you that when working with samples of data it is important
that the sample represents a healthy variety of opinions rather than being skewed by any single voice.
The same is true with aggregations and sampling with these diversify settings can offer a way to remove the bias in your content (an over-populated geography,
a large spike in a timeline or an over-active forum spammer).</p>
</div>
</div>
<div class="ulist itemizedlist">
<p class="title"><strong>Example use cases:</strong></p>
<ul class="itemizedlist">
<li class="listitem">
Tightening the focus of analytics to high-relevance matches rather than the potentially very long tail of low-quality matches
</li>
<li class="listitem">
Removing bias from analytics by ensuring fair representation of content from different sources
</li>
<li class="listitem">
Reducing the running cost of aggregations that can produce useful results using only samples e.g. <code class="literal">significant_terms</code>
</li>
</ul>
</div>
<p>A choice of <code class="literal">field</code> or <code class="literal">script</code> setting is used to provide values used for de-duplication and the <code class="literal">max_docs_per_value</code> setting controls the maximum
number of documents collected on any one shard which share a common value. The default setting for <code class="literal">max_docs_per_value</code> is 1.</p>
<p>The aggregation will throw an error if the choice of <code class="literal">field</code> or <code class="literal">script</code> produces multiple values for a single document (de-duplication using multi-valued fields is not supported due to efficiency concerns).</p>
<p>Example:</p>
<p>We might want to see which tags are strongly associated with <code class="literal">#elasticsearch</code> on StackOverflow
forum posts but ignoring the effects of some prolific users with a tendency to misspell #Kibana as #Cabana.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /stackoverflow/_search?size=0
{
  "query": {
    "query_string": {
      "query": "tags:elasticsearch"
    }
  },
  "aggs": {
    "my_unbiased_sample": {
      "diversified_sampler": {
        "shard_size": 200,
        "field": "author"
      },
      "aggs": {
        "keywords": {
          "significant_terms": {
            "field": "tags",
            "exclude": [ "elasticsearch" ]
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1004.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "my_unbiased_sample": {
      "doc_count": 151,           <a id="CO243-1"></a><i class="conum" data-value="1"></i>
      "keywords": {               <a id="CO243-2"></a><i class="conum" data-value="2"></i>
        "doc_count": 151,
        "bg_count": 650,
        "buckets": [
          {
            "key": "kibana",
            "doc_count": 150,
            "score": 2.213,
            "bg_count": 200
          }
        ]
      }
    }
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO243-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>151 documents were sampled in total.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO243-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>The results of the significant_terms aggregation are not skewed by any single author&#8217;s quirks because we asked for a maximum of one post from any one author in our sample.</p>
</td>
</tr>
</table>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_scripted_example"></a>Scripted example:<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/diversified-sampler-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>In this scenario we might want to diversify on a combination of field values. We can use a <code class="literal">script</code> to produce a hash of the
multiple values in a tags field to ensure we don&#8217;t have a sample that consists of the same repeated combinations of tags.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /stackoverflow/_search?size=0
{
  "query": {
    "query_string": {
      "query": "tags:kibana"
    }
  },
  "aggs": {
    "my_unbiased_sample": {
      "diversified_sampler": {
        "shard_size": 200,
        "max_docs_per_value": 3,
        "script": {
          "lang": "painless",
          "source": "doc['tags'].hashCode()"
        }
      },
      "aggs": {
        "keywords": {
          "significant_terms": {
            "field": "tags",
            "exclude": [ "kibana" ]
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1005.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "my_unbiased_sample": {
      "doc_count": 6,
      "keywords": {
        "doc_count": 6,
        "bg_count": 650,
        "buckets": [
          {
            "key": "logstash",
            "doc_count": 3,
            "score": 2.213,
            "bg_count": 50
          },
          {
            "key": "elasticsearch",
            "doc_count": 3,
            "score": 1.34,
            "bg_count": 200
          }
        ]
      }
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_shard_size"></a>shard_size<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/diversified-sampler-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">shard_size</code> parameter limits how many top-scoring documents are collected in the sample processed on each shard.
The default value is 100.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_max_docs_per_value"></a>max_docs_per_value<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/diversified-sampler-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">max_docs_per_value</code> is an optional parameter and limits how many documents are permitted per choice of de-duplicating value.
The default setting is "1".</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_execution_hint"></a>execution_hint<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/diversified-sampler-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The optional <code class="literal">execution_hint</code> setting can influence the management of the values used for de-duplication.
Each option will hold up to <code class="literal">shard_size</code> values in memory while performing de-duplication but the type of value held can be controlled as follows:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
hold field values directly (<code class="literal">map</code>)
</li>
<li class="listitem">
hold ordinals of the field as determined by the Lucene index (<code class="literal">global_ordinals</code>)
</li>
<li class="listitem">
hold hashes of the field values - with potential for hash collisions (<code class="literal">bytes_hash</code>)
</li>
</ul>
</div>
<p>The default setting is to use <a class="xref" href="mapping-params.html#eager-global-ordinals" title="eager_global_ordinals"><code class="literal">global_ordinals</code></a> if this information is available from the Lucene index and reverting to <code class="literal">map</code> if not.
The <code class="literal">bytes_hash</code> setting may prove faster in some cases but introduces the possibility of false positives in de-duplication logic due to the possibility of hash collisions.
Please note that Elasticsearch will ignore the choice of execution hint if it is not applicable and that there is no backward compatibility guarantee on these hints.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_limitations_5"></a>Limitations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/diversified-sampler-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="div-sampler-breadth-first-nested-agg"></a>Cannot be nested under <code class="literal">breadth_first</code> aggregations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/diversified-sampler-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>Being a quality-based filter the diversified_sampler aggregation needs access to the relevance score produced for each document.
It therefore cannot be nested under a <code class="literal">terms</code> aggregation which has the <code class="literal">collect_mode</code> switched from the default <code class="literal">depth_first</code> mode to <code class="literal">breadth_first</code> as this discards scores.
In this situation an error will be thrown.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_limited_de_dup_logic"></a>Limited de-dup logic.<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/diversified-sampler-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>The de-duplication logic applies only at a shard level so will not apply across shards.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="spec-syntax-geo-date-fields"></a>No specialized syntax for geo/date fields<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/diversified-sampler-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>Currently the syntax for defining the diversifying values is defined by a choice of <code class="literal">field</code> or
<code class="literal">script</code> - there is no added syntactical sugar for expressing geo or date units such as "7d" (7
days). This support may be added in a later release and users will currently have to create these
sorts of values using a script.</p>
</div>

</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-filter-aggregation"></a>Filter aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/filter-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>Defines a single bucket of all the documents in the current document set context that match a specified filter. Often this will be used to narrow down the current aggregation context to a specific set of documents.</p>
<p>Example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "t_shirts": {
      "filter": { "term": { "type": "t-shirt" } },
      "aggs": {
        "avg_price": { "avg": { "field": "price" } }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1006.console"></div>
<p>In the above example, we calculate the average price of all the products that are of type t-shirt.</p>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "t_shirts": {
      "doc_count": 3,
      "avg_price": { "value": 128.33333333333334 }
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-filters-aggregation"></a>Filters aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/filters-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>Defines a multi bucket aggregation where each bucket is associated with a
filter. Each bucket will collect all documents that match its associated
filter.</p>
<p>Example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /logs/_bulk?refresh
{ "index" : { "_id" : 1 } }
{ "body" : "warning: page could not be rendered" }
{ "index" : { "_id" : 2 } }
{ "body" : "authentication error" }
{ "index" : { "_id" : 3 } }
{ "body" : "warning: connection timed out" }

GET logs/_search
{
  "size": 0,
  "aggs" : {
    "messages" : {
      "filters" : {
        "filters" : {
          "errors" :   { "match" : { "body" : "error"   }},
          "warnings" : { "match" : { "body" : "warning" }}
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1007.console"></div>
<p>In the above example, we analyze log messages. The aggregation will build two
collection (buckets) of log messages - one for all those containing an error,
and another for all those containing a warning.</p>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "took": 9,
  "timed_out": false,
  "_shards": ...,
  "hits": ...,
  "aggregations": {
    "messages": {
      "buckets": {
        "errors": {
          "doc_count": 1
        },
        "warnings": {
          "doc_count": 2
        }
      }
    }
  }
}</pre>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_anonymous_filters"></a>Anonymous filters<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/filters-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The filters field can also be provided as an array of filters, as in the
following request:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET logs/_search
{
  "size": 0,
  "aggs" : {
    "messages" : {
      "filters" : {
        "filters" : [
          { "match" : { "body" : "error"   }},
          { "match" : { "body" : "warning" }}
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1008.console"></div>
<p>The filtered buckets are returned in the same order as provided in the
request.  The response for this example would be:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "took": 4,
  "timed_out": false,
  "_shards": ...,
  "hits": ...,
  "aggregations": {
    "messages": {
      "buckets": [
        {
          "doc_count": 1
        },
        {
          "doc_count": 2
        }
      ]
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="other-bucket"></a><code class="literal">Other</code> Bucket<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/filters-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">other_bucket</code> parameter can be set to add a bucket to the response which will contain all documents that do
not match any of the given filters. The value of this parameter can be as follows:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">false</code>
</span>
</dt>
<dd>
Does not compute the <code class="literal">other</code> bucket
</dd>
<dt>
<span class="term">
<code class="literal">true</code>
</span>
</dt>
<dd>
Returns the <code class="literal">other</code> bucket either in a bucket (named <code class="literal">_other_</code> by default) if named filters are being used,
or as the last bucket if anonymous filters are being used
</dd>
</dl>
</div>
<p>The <code class="literal">other_bucket_key</code> parameter can be used to set the key for the <code class="literal">other</code> bucket to a value other than the default <code class="literal">_other_</code>. Setting
this parameter will implicitly set the <code class="literal">other_bucket</code> parameter to <code class="literal">true</code>.</p>
<p>The following snippet shows a response where the <code class="literal">other</code> bucket is requested to be named <code class="literal">other_messages</code>.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT logs/_doc/4?refresh
{
  "body": "info: user Bob logged out"
}

GET logs/_search
{
  "size": 0,
  "aggs" : {
    "messages" : {
      "filters" : {
        "other_bucket_key": "other_messages",
        "filters" : {
          "errors" :   { "match" : { "body" : "error"   }},
          "warnings" : { "match" : { "body" : "warning" }}
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1009.console"></div>
<p>The response would be something like the following:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "took": 3,
  "timed_out": false,
  "_shards": ...,
  "hits": ...,
  "aggregations": {
    "messages": {
      "buckets": {
        "errors": {
          "doc_count": 1
        },
        "warnings": {
          "doc_count": 2
        },
        "other_messages": {
          "doc_count": 1
        }
      }
    }
  }
}</pre>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-geodistance-aggregation"></a>Geo-distance aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/geodistance-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A multi-bucket aggregation that works on <code class="literal">geo_point</code> fields and conceptually works very similar to the <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-range-aggregation" title="Range aggregation">range</a> aggregation. The user can define a point of origin and a set of distance range buckets. The aggregation evaluate the distance of each document value from the origin point and determines the buckets it belongs to based on the ranges (a document belongs to a bucket if the distance between the document and the origin falls within the distance range of the bucket).</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /museums
{
  "mappings": {
    "properties": {
      "location": {
        "type": "geo_point"
      }
    }
  }
}

POST /museums/_bulk?refresh
{"index":{"_id":1}}
{"location": "52.374081,4.912350", "name": "NEMO Science Museum"}
{"index":{"_id":2}}
{"location": "52.369219,4.901618", "name": "Museum Het Rembrandthuis"}
{"index":{"_id":3}}
{"location": "52.371667,4.914722", "name": "Nederlands Scheepvaartmuseum"}
{"index":{"_id":4}}
{"location": "51.222900,4.405200", "name": "Letterenhuis"}
{"index":{"_id":5}}
{"location": "48.861111,2.336389", "name": "Musée du Louvre"}
{"index":{"_id":6}}
{"location": "48.860000,2.327000", "name": "Musée d'Orsay"}

POST /museums/_search?size=0
{
  "aggs": {
    "rings_around_amsterdam": {
      "geo_distance": {
        "field": "location",
        "origin": "52.3760, 4.894",
        "ranges": [
          { "to": 100000 },
          { "from": 100000, "to": 300000 },
          { "from": 300000 }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1010.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "rings_around_amsterdam": {
      "buckets": [
        {
          "key": "*-100000.0",
          "from": 0.0,
          "to": 100000.0,
          "doc_count": 3
        },
        {
          "key": "100000.0-300000.0",
          "from": 100000.0,
          "to": 300000.0,
          "doc_count": 1
        },
        {
          "key": "300000.0-*",
          "from": 300000.0,
          "doc_count": 2
        }
      ]
    }
  }
}</pre>
</div>
<p>The specified field must be of type <code class="literal">geo_point</code> (which can only be set explicitly in the mappings). And it can also hold an array of <code class="literal">geo_point</code> fields, in which case all will be taken into account during aggregation. The origin point can accept all formats supported by the <a class="xref" href="mapping-types.html#geo-point" title="Geo-point field type"><code class="literal">geo_point</code> type</a>:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Object format: <code class="literal">{ "lat" : 52.3760, "lon" : 4.894 }</code> - this is the safest format as it is the most explicit about the <code class="literal">lat</code> &amp; <code class="literal">lon</code> values
</li>
<li class="listitem">
String format: <code class="literal">"52.3760, 4.894"</code> - where the first number is the <code class="literal">lat</code> and the second is the <code class="literal">lon</code>
</li>
<li class="listitem">
Array format: <code class="literal">[4.894, 52.3760]</code> - which is based on the <code class="literal">GeoJson</code> standard and where the first number is the <code class="literal">lon</code> and the second one is the <code class="literal">lat</code>
</li>
</ul>
</div>
<p>By default, the distance unit is <code class="literal">m</code> (meters) but it can also accept: <code class="literal">mi</code> (miles), <code class="literal">in</code> (inches), <code class="literal">yd</code> (yards), <code class="literal">km</code> (kilometers), <code class="literal">cm</code> (centimeters), <code class="literal">mm</code> (millimeters).</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /museums/_search?size=0
{
  "aggs": {
    "rings": {
      "geo_distance": {
        "field": "location",
        "origin": "52.3760, 4.894",
        "unit": "km", <a id="CO244-1"></a><i class="conum" data-value="1"></i>
        "ranges": [
          { "to": 100 },
          { "from": 100, "to": 300 },
          { "from": 300 }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1011.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO244-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The distances will be computed in kilometers</p>
</td>
</tr>
</table>
</div>
<p>There are two distance calculation modes: <code class="literal">arc</code> (the default), and <code class="literal">plane</code>. The <code class="literal">arc</code> calculation is the most accurate. The <code class="literal">plane</code> is the fastest but least accurate. Consider using <code class="literal">plane</code> when your search context is "narrow", and spans smaller geographical areas (~5km). <code class="literal">plane</code> will return higher error margins for searches across very large areas (e.g. cross continent search). The distance calculation type can be set using the <code class="literal">distance_type</code> parameter:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /museums/_search?size=0
{
  "aggs": {
    "rings": {
      "geo_distance": {
        "field": "location",
        "origin": "52.3760, 4.894",
        "unit": "km",
        "distance_type": "plane",
        "ranges": [
          { "to": 100 },
          { "from": 100, "to": 300 },
          { "from": 300 }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1012.console"></div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_keyed_response_2"></a>Keyed Response<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/geodistance-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Setting the <code class="literal">keyed</code> flag to <code class="literal">true</code> will associate a unique string key with each bucket and return the ranges as a hash rather than an array:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /museums/_search?size=0
{
  "aggs": {
    "rings_around_amsterdam": {
      "geo_distance": {
        "field": "location",
        "origin": "52.3760, 4.894",
        "ranges": [
          { "to": 100000 },
          { "from": 100000, "to": 300000 },
          { "from": 300000 }
        ],
        "keyed": true
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1013.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "rings_around_amsterdam": {
      "buckets": {
        "*-100000.0": {
          "from": 0.0,
          "to": 100000.0,
          "doc_count": 3
        },
        "100000.0-300000.0": {
          "from": 100000.0,
          "to": 300000.0,
          "doc_count": 1
        },
        "300000.0-*": {
          "from": 300000.0,
          "doc_count": 2
        }
      }
    }
  }
}</pre>
</div>
<p>It is also possible to customize the key for each range:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /museums/_search?size=0
{
  "aggs": {
    "rings_around_amsterdam": {
      "geo_distance": {
        "field": "location",
        "origin": "52.3760, 4.894",
        "ranges": [
          { "to": 100000, "key": "first_ring" },
          { "from": 100000, "to": 300000, "key": "second_ring" },
          { "from": 300000, "key": "third_ring" }
        ],
        "keyed": true
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1014.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "rings_around_amsterdam": {
      "buckets": {
        "first_ring": {
          "from": 0.0,
          "to": 100000.0,
          "doc_count": 3
        },
        "second_ring": {
          "from": 100000.0,
          "to": 300000.0,
          "doc_count": 1
        },
        "third_ring": {
          "from": 300000.0,
          "doc_count": 2
        }
      }
    }
  }
}</pre>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-geohashgrid-aggregation"></a>Geohash grid aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/geohashgrid-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A multi-bucket aggregation that works on <code class="literal">geo_point</code> fields and groups points into buckets that represent cells in a grid.
The resulting grid can be sparse and only contains cells that have matching data. Each cell is labeled using a <a href="https://en.wikipedia.org/wiki/Geohash" class="ulink" target="_top">geohash</a> which is of user-definable precision.</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
High precision geohashes have a long string length and represent cells that cover only a small area.
</li>
<li class="listitem">
Low precision geohashes have a short string length and represent cells that each cover a large area.
</li>
</ul>
</div>
<p>Geohashes used in this aggregation can have a choice of precision between 1 and 12.</p>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>The highest-precision geohash of length 12 produces cells that cover less than a square metre of land and so high-precision requests can be very costly in terms of RAM and result sizes.
Please see the example below on how to first filter the aggregation to a smaller geographic area before requesting high-levels of detail.</p>
</div>
</div>
<p>The specified field must be of type <code class="literal">geo_point</code> (which can only be set explicitly in the mappings) and it can also hold an array of <code class="literal">geo_point</code> fields, in which case all points will be taken into account during aggregation.</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_simple_low_precision_request"></a>Simple low-precision request<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/geohashgrid-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /museums
{
  "mappings": {
    "properties": {
      "location": {
        "type": "geo_point"
      }
    }
  }
}

POST /museums/_bulk?refresh
{"index":{"_id":1}}
{"location": "52.374081,4.912350", "name": "NEMO Science Museum"}
{"index":{"_id":2}}
{"location": "52.369219,4.901618", "name": "Museum Het Rembrandthuis"}
{"index":{"_id":3}}
{"location": "52.371667,4.914722", "name": "Nederlands Scheepvaartmuseum"}
{"index":{"_id":4}}
{"location": "51.222900,4.405200", "name": "Letterenhuis"}
{"index":{"_id":5}}
{"location": "48.861111,2.336389", "name": "Musée du Louvre"}
{"index":{"_id":6}}
{"location": "48.860000,2.327000", "name": "Musée d'Orsay"}

POST /museums/_search?size=0
{
  "aggregations": {
    "large-grid": {
      "geohash_grid": {
        "field": "location",
        "precision": 3
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1015.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
  "large-grid": {
    "buckets": [
      {
        "key": "u17",
        "doc_count": 3
      },
      {
        "key": "u09",
        "doc_count": 2
      },
      {
        "key": "u15",
        "doc_count": 1
      }
    ]
  }
}
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_high_precision_requests"></a>High-precision requests<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/geohashgrid-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>When requesting detailed buckets (typically for displaying a "zoomed in" map) a filter like <a class="xref" href="geo-queries.html#query-dsl-geo-bounding-box-query" title="Geo-bounding box query">geo_bounding_box</a> should be applied to narrow the subject area otherwise potentially millions of buckets will be created and returned.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /museums/_search?size=0
{
  "aggregations": {
    "zoomed-in": {
      "filter": {
        "geo_bounding_box": {
          "location": {
            "top_left": "52.4, 4.9",
            "bottom_right": "52.3, 5.0"
          }
        }
      },
      "aggregations": {
        "zoom1": {
          "geohash_grid": {
            "field": "location",
            "precision": 8
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1016.console"></div>
<p>The geohashes returned by the <code class="literal">geohash_grid</code> aggregation can be also used for zooming in. To zoom into the
first geohash <code class="literal">u17</code> returned in the previous example, it should be specified as both <code class="literal">top_left</code> and <code class="literal">bottom_right</code> corner:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /museums/_search?size=0
{
  "aggregations": {
    "zoomed-in": {
      "filter": {
        "geo_bounding_box": {
          "location": {
            "top_left": "u17",
            "bottom_right": "u17"
          }
        }
      },
      "aggregations": {
        "zoom1": {
          "geohash_grid": {
            "field": "location",
            "precision": 8
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1017.console"></div>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "zoomed-in": {
      "doc_count": 3,
      "zoom1": {
        "buckets": [
          {
            "key": "u173zy3j",
            "doc_count": 1
          },
          {
            "key": "u173zvfz",
            "doc_count": 1
          },
          {
            "key": "u173zt90",
            "doc_count": 1
          }
        ]
      }
    }
  }
}</pre>
</div>
<p>For "zooming in" on the system that don&#8217;t support geohashes, the bucket keys should be translated into bounding boxes using
one of available geohash libraries. For example, for javascript the <a href="https://github.com/sunng87/node-geohash" class="ulink" target="_top">node-geohash</a> library
can be used:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">var geohash = require('ngeohash');

// bbox will contain [ 52.03125, 4.21875, 53.4375, 5.625 ]
//                   [   minlat,  minlon,  maxlat, maxlon]
var bbox = geohash.decode_bbox('u17');</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_requests_with_additional_bounding_box_filtering"></a>Requests with additional bounding box filtering<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/geohashgrid-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">geohash_grid</code> aggregation supports an optional <code class="literal">bounds</code> parameter
that restricts the points considered to those that fall within the
bounds provided. The <code class="literal">bounds</code> parameter accepts the bounding box in
all the same <a class="xref" href="geo-queries.html#query-dsl-geo-bounding-box-query-accepted-formats" title="Accepted Formats">accepted formats</a> of the
bounds specified in the Geo Bounding Box Query. This bounding box can be used with or
without an additional <code class="literal">geo_bounding_box</code> query filtering the points prior to aggregating.
It is an independent bounding box that can intersect with, be equal to, or be disjoint
to any additional <code class="literal">geo_bounding_box</code> queries defined in the context of the aggregation.</p>
<a id="geohashgrid-aggregation-with-bounds"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /museums/_search?size=0
{
  "aggregations": {
    "tiles-in-bounds": {
      "geohash_grid": {
        "field": "location",
        "precision": 8,
        "bounds": {
          "top_left": "53.4375, 4.21875",
          "bottom_right": "52.03125, 5.625"
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1018.console"></div>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "tiles-in-bounds": {
      "buckets": [
        {
          "key": "u173zy3j",
          "doc_count": 1
        },
        {
          "key": "u173zvfz",
          "doc_count": 1
        },
        {
          "key": "u173zt90",
          "doc_count": 1
        }
      ]
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_cell_dimensions_at_the_equator"></a>Cell dimensions at the equator<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/geohashgrid-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The table below shows the metric dimensions for cells covered by various string lengths of geohash.
Cell dimensions vary with latitude and so the table is for the worst-case scenario at the equator.</p>
<div class="informaltable">
<table border="0" cellpadding="4px">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody valign="top">
<tr>
<td valign="top">
<p>
<span class="strong strong"><strong>GeoHash length</strong></span>
</p>
</td>
<td valign="top">
<p>
<span class="strong strong"><strong>Area width x height</strong></span>
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
1
</p>
</td>
<td valign="top">
<p>
5,009.4km x 4,992.6km
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
2
</p>
</td>
<td valign="top">
<p>
1,252.3km x 624.1km
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
3
</p>
</td>
<td valign="top">
<p>
156.5km x 156km
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
4
</p>
</td>
<td valign="top">
<p>
39.1km x 19.5km
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
5
</p>
</td>
<td valign="top">
<p>
4.9km x 4.9km
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
6
</p>
</td>
<td valign="top">
<p>
1.2km x 609.4m
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
7
</p>
</td>
<td valign="top">
<p>
152.9m x 152.4m
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
8
</p>
</td>
<td valign="top">
<p>
38.2m x 19m
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
9
</p>
</td>
<td valign="top">
<p>
4.8m x 4.8m
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
10
</p>
</td>
<td valign="top">
<p>
1.2m x 59.5cm
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
11
</p>
</td>
<td valign="top">
<p>
14.9cm x 14.9cm
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
12
</p>
</td>
<td valign="top">
<p>
3.7cm x 1.9cm
</p>
</td>
</tr>
</tbody>
</table>
</div>
<h4 class="xpack"><a id="_aggregating_geo_shape_fields"></a>Aggregating <code class="literal">geo_shape</code> fields<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/geohashgrid-aggregation.asciidoc">edit</a><a class="xpack_tag" href="/subscriptions"></a></h4>
<p>Aggregating on <a class="xref" href="mapping-types.html#geo-shape" title="Geo-shape field type">Geo-shape</a> fields works just as it does for points, except that a single
shape can be counted for in multiple tiles. A shape will contribute to the count of matching values
if any part of its shape intersects with that tile. Below is an image that demonstrates this:</p>
<p><span class="image"><img src="images/spatial/geoshape_grid.png" alt="geoshape grid"></span></p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_options_3"></a>Options<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/geohashgrid-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<div class="informaltable">
<table border="0" cellpadding="4px">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody valign="top">
<tr>
<td valign="top">
<p>
field
</p>
</td>
<td valign="top">
<p>
Mandatory. The name of the field indexed with GeoPoints.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
precision
</p>
</td>
<td valign="top">
<p>
Optional. The string length of the geohashes used to define
cells/buckets in the results. Defaults to 5.
The precision can either be defined in terms of the integer
precision levels mentioned above. Values outside of [1,12] will
be rejected.
Alternatively, the precision level can be approximated from a
distance measure like "1km", "10m". The precision level is
calculate such that cells will not exceed the specified
size (diagonal) of the required precision. When this would lead
to precision levels higher than the supported 12 levels,
(e.g. for distances &lt;5.6cm) the value is rejected.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
bounds
</p>
</td>
<td valign="top">
<p>
Optional. The bounding box to filter the points in the bucket.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
size
</p>
</td>
<td valign="top">
<p>
Optional. The maximum number of geohash buckets to return
(defaults to 10,000). When results are trimmed, buckets are
prioritised based on the volumes of documents they contain.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
shard_size
</p>
</td>
<td valign="top">
<p>
Optional. To allow for more accurate counting of the top cells
returned in the final result the aggregation defaults to
returning <code class="literal">max(10,(size x number-of-shards))</code> buckets from each
shard. If this heuristic is undesirable, the number considered
from each shard can be over-ridden using this parameter.
</p>
</td>
</tr>
</tbody>
</table>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-geotilegrid-aggregation"></a>Geotile grid aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/geotilegrid-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A multi-bucket aggregation that works on <code class="literal">geo_point</code> fields and groups points into
buckets that represent cells in a grid. The resulting grid can be sparse and only
contains cells that have matching data. Each cell corresponds to a
<a href="https://en.wikipedia.org/wiki/Tiled_web_map" class="ulink" target="_top">map tile</a> as used by many online map
sites. Each cell is labeled using a "{zoom}/{x}/{y}" format, where zoom is equal
to the user-specified precision.</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
High precision keys have a larger range for x and y, and represent tiles that
cover only a small area.
</li>
<li class="listitem">
Low precision keys have a smaller range for x and y, and represent tiles that
each cover a large area.
</li>
</ul>
</div>
<p>See <a href="https://wiki.openstreetmap.org/wiki/Zoom_levels" class="ulink" target="_top">Zoom level documentation</a>
on how precision (zoom) correlates to size on the ground. Precision for this
aggregation can be between 0 and 29, inclusive.</p>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>The highest-precision geotile of length 29 produces cells that cover
less than a 10cm by 10cm of land and so high-precision requests can be very
costly in terms of RAM and result sizes. Please see the example below on how
to first filter the aggregation to a smaller geographic area before requesting
high-levels of detail.</p>
</div>
</div>
<p>The specified field must be of type <code class="literal">geo_point</code> (which can only be set
explicitly in the mappings) and it can also hold an array of <code class="literal">geo_point</code>
fields, in which case all points will be taken into account during aggregation.</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_simple_low_precision_request_2"></a>Simple low-precision request<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/geotilegrid-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /museums
{
  "mappings": {
    "properties": {
      "location": {
        "type": "geo_point"
      }
    }
  }
}

POST /museums/_bulk?refresh
{"index":{"_id":1}}
{"location": "52.374081,4.912350", "name": "NEMO Science Museum"}
{"index":{"_id":2}}
{"location": "52.369219,4.901618", "name": "Museum Het Rembrandthuis"}
{"index":{"_id":3}}
{"location": "52.371667,4.914722", "name": "Nederlands Scheepvaartmuseum"}
{"index":{"_id":4}}
{"location": "51.222900,4.405200", "name": "Letterenhuis"}
{"index":{"_id":5}}
{"location": "48.861111,2.336389", "name": "Musée du Louvre"}
{"index":{"_id":6}}
{"location": "48.860000,2.327000", "name": "Musée d'Orsay"}

POST /museums/_search?size=0
{
  "aggregations": {
    "large-grid": {
      "geotile_grid": {
        "field": "location",
        "precision": 8
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1019.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "large-grid": {
      "buckets": [
        {
          "key": "8/131/84",
          "doc_count": 3
        },
        {
          "key": "8/129/88",
          "doc_count": 2
        },
        {
          "key": "8/131/85",
          "doc_count": 1
        }
      ]
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_high_precision_requests_2"></a>High-precision requests<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/geotilegrid-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>When requesting detailed buckets (typically for displaying a "zoomed in" map)
a filter like <a class="xref" href="geo-queries.html#query-dsl-geo-bounding-box-query" title="Geo-bounding box query">geo_bounding_box</a> should be
applied to narrow the subject area otherwise potentially millions of buckets
will be created and returned.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /museums/_search?size=0
{
  "aggregations": {
    "zoomed-in": {
      "filter": {
        "geo_bounding_box": {
          "location": {
            "top_left": "52.4, 4.9",
            "bottom_right": "52.3, 5.0"
          }
        }
      },
      "aggregations": {
        "zoom1": {
          "geotile_grid": {
            "field": "location",
            "precision": 22
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1020.console"></div>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "zoomed-in": {
      "doc_count": 3,
      "zoom1": {
        "buckets": [
          {
            "key": "22/2154412/1378379",
            "doc_count": 1
          },
          {
            "key": "22/2154385/1378332",
            "doc_count": 1
          },
          {
            "key": "22/2154259/1378425",
            "doc_count": 1
          }
        ]
      }
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_requests_with_additional_bounding_box_filtering_2"></a>Requests with additional bounding box filtering<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/geotilegrid-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">geotile_grid</code> aggregation supports an optional <code class="literal">bounds</code> parameter
that restricts the points considered to those that fall within the
bounds provided. The <code class="literal">bounds</code> parameter accepts the bounding box in
all the same <a class="xref" href="geo-queries.html#query-dsl-geo-bounding-box-query-accepted-formats" title="Accepted Formats">accepted formats</a> of the
bounds specified in the Geo Bounding Box Query. This bounding box can be used with or
without an additional <code class="literal">geo_bounding_box</code> query filtering the points prior to aggregating.
It is an independent bounding box that can intersect with, be equal to, or be disjoint
to any additional <code class="literal">geo_bounding_box</code> queries defined in the context of the aggregation.</p>
<a id="geotilegrid-aggregation-with-bounds"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /museums/_search?size=0
{
  "aggregations": {
    "tiles-in-bounds": {
      "geotile_grid": {
        "field": "location",
        "precision": 22,
        "bounds": {
          "top_left": "52.4, 4.9",
          "bottom_right": "52.3, 5.0"
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1021.console"></div>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "tiles-in-bounds": {
      "buckets": [
        {
          "key": "22/2154412/1378379",
          "doc_count": 1
        },
        {
          "key": "22/2154385/1378332",
          "doc_count": 1
        },
        {
          "key": "22/2154259/1378425",
          "doc_count": 1
        }
      ]
    }
  }
}</pre>
</div>
<h4 class="xpack"><a id="_aggregating_geo_shape_fields_2"></a>Aggregating <code class="literal">geo_shape</code> fields<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/geotilegrid-aggregation.asciidoc">edit</a><a class="xpack_tag" href="/subscriptions"></a></h4>
<p>Aggregating on <a class="xref" href="mapping-types.html#geo-shape" title="Geo-shape field type">Geo-shape</a> fields works just as it does for points, except that a single
shape can be counted for in multiple tiles. A shape will contribute to the count of matching values
if any part of its shape intersects with that tile. Below is an image that demonstrates this:</p>
<p><span class="image"><img src="images/spatial/geoshape_grid.png" alt="geoshape grid"></span></p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_options_4"></a>Options<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/geotilegrid-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<div class="informaltable">
<table border="0" cellpadding="4px">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody valign="top">
<tr>
<td valign="top">
<p>
field
</p>
</td>
<td valign="top">
<p>
Mandatory. The name of the field indexed with GeoPoints.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
precision
</p>
</td>
<td valign="top">
<p>
Optional. The integer zoom of the key used to define
cells/buckets in the results. Defaults to 7.
Values outside of [0,29] will be rejected.
</p>
</td>
</tr>
</tbody>
</table>
</div>
<p>bounds:         Optional. The bounding box to filter the points in the bucket.</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
size
</span>
</dt>
<dd>
Optional. The maximum number of geohash buckets to return
(defaults to 10,000). When results are trimmed, buckets are
prioritised based on the volumes of documents they contain.
</dd>
<dt>
<span class="term">
shard_size
</span>
</dt>
<dd>
Optional. To allow for more accurate counting of the top cells
returned in the final result the aggregation defaults to
returning <code class="literal">max(10,(size x number-of-shards))</code> buckets from each
shard. If this heuristic is undesirable, the number considered
from each shard can be over-ridden using this parameter.
</dd>
</dl>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-global-aggregation"></a>Global aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/global-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>Defines a single bucket of all the documents within the search execution
context. This context is defined by the indices and the document types you&#8217;re
searching on, but is <span class="strong strong"><strong>not</strong></span> influenced by the search query itself.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>Global aggregators can only be placed as top level aggregators because
        it doesn&#8217;t make sense to embed a global aggregator within another
        bucket aggregator.</p>
</div>
</div>
<p>Example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "query": {
    "match": { "type": "t-shirt" }
  },
  "aggs": {
    "all_products": {
      "global": {}, <a id="CO245-1"></a><i class="conum" data-value="1"></i>
      "aggs": {     <a id="CO245-2"></a><i class="conum" data-value="2"></i>
      "avg_price": { "avg": { "field": "price" } }
      }
    },
    "t_shirts": { "avg": { "field": "price" } }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1022.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO245-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">global</code> aggregation has an empty body</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO245-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>The sub-aggregations that are registered for this <code class="literal">global</code> aggregation</p>
</td>
</tr>
</table>
</div>
<p>The above aggregation demonstrates how one would compute aggregations
(<code class="literal">avg_price</code> in this example) on all the documents in the search context,
regardless of the query (in our example, it will compute the average price over
all products in our catalog, not just on the "shirts").</p>
<p>The response for the above aggregation:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "all_products": {
      "doc_count": 7, <a id="CO246-1"></a><i class="conum" data-value="1"></i>
      "avg_price": {
        "value": 140.71428571428572 <a id="CO246-2"></a><i class="conum" data-value="2"></i>
      }
    },
    "t_shirts": {
      "value": 128.33333333333334 <a id="CO246-3"></a><i class="conum" data-value="3"></i>
    }
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO246-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The number of documents that were aggregated (in our case, all documents
within the search context)</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO246-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>The average price of all products in the index</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO246-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>The average price of all t-shirts</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-histogram-aggregation"></a>Histogram aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/histogram-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A multi-bucket values source based aggregation that can be applied on numeric values or numeric range values extracted
from the documents. It dynamically builds fixed size (a.k.a. interval) buckets over the values. For example, if the
documents have a field that holds a price (numeric), we can configure this aggregation to dynamically build buckets with
interval <code class="literal">5</code> (in case of price it may represent $5). When the aggregation executes, the price field of every document
will be evaluated and will be rounded down to its closest bucket - for example, if the price is <code class="literal">32</code> and the bucket size
is <code class="literal">5</code> then the rounding will yield <code class="literal">30</code> and thus the document will "fall" into the bucket that is associated with the
key <code class="literal">30</code>.
To make this more formal, here is the rounding function that is used:</p>
<div class="pre_wrapper lang-java">
<pre class="programlisting prettyprint lang-java">bucket_key = Math.floor((value - offset) / interval) * interval + offset</pre>
</div>
<p>For range values, a document can fall into multiple buckets. The first bucket is computed from the lower
bound of the range in the same way as a bucket for a single value is computed.  The final bucket is computed in the same
way from the upper bound of the range, and the range is counted in all buckets in between and including those two.</p>
<p>The <code class="literal">interval</code> must be a positive decimal, while the <code class="literal">offset</code> must be a decimal in <code class="literal">[0, interval)</code>
(a decimal greater than or equal to <code class="literal">0</code> and less than <code class="literal">interval</code>)</p>
<p>The following snippet "buckets" the products based on their <code class="literal">price</code> by interval of <code class="literal">50</code>:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "prices": {
      "histogram": {
        "field": "price",
        "interval": 50
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1023.console"></div>
<p>And the following may be the response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "prices": {
      "buckets": [
        {
          "key": 0.0,
          "doc_count": 1
        },
        {
          "key": 50.0,
          "doc_count": 1
        },
        {
          "key": 100.0,
          "doc_count": 0
        },
        {
          "key": 150.0,
          "doc_count": 2
        },
        {
          "key": 200.0,
          "doc_count": 3
        }
      ]
    }
  }
}</pre>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_minimum_document_count"></a>Minimum document count<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/histogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The response above show that no documents has a price that falls within the range of <code class="literal">[100, 150)</code>. By default the
response will fill gaps in the histogram with empty buckets. It is possible change that and request buckets with
a higher minimum count thanks to the <code class="literal">min_doc_count</code> setting:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "prices": {
      "histogram": {
        "field": "price",
        "interval": 50,
        "min_doc_count": 1
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1024.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "prices": {
      "buckets": [
        {
          "key": 0.0,
          "doc_count": 1
        },
        {
          "key": 50.0,
          "doc_count": 1
        },
        {
          "key": 150.0,
          "doc_count": 2
        },
        {
          "key": 200.0,
          "doc_count": 3
        }
      ]
    }
  }
}</pre>
</div>
<p><a id="search-aggregations-bucket-histogram-aggregation-extended-bounds"></a>By default the <code class="literal">histogram</code> returns all the buckets within the range of the data itself, that is, the documents with
the smallest values (on which with histogram) will determine the min bucket (the bucket with the smallest key) and the
documents with the highest values will determine the max bucket (the bucket with the highest key). Often, when
requesting empty buckets, this causes a confusion, specifically, when the data is also filtered.</p>
<p>To understand why, let&#8217;s look at an example:</p>
<p>Lets say the you&#8217;re filtering your request to get all docs with values between <code class="literal">0</code> and <code class="literal">500</code>, in addition you&#8217;d like
to slice the data per price using a histogram with an interval of <code class="literal">50</code>. You also specify <code class="literal">"min_doc_count" : 0</code> as you&#8217;d
like to get all buckets even the empty ones. If it happens that all products (documents) have prices higher than <code class="literal">100</code>,
the first bucket you&#8217;ll get will be the one with <code class="literal">100</code> as its key. This is confusing, as many times, you&#8217;d also like
to get those buckets between <code class="literal">0 - 100</code>.</p>
<p>With <code class="literal">extended_bounds</code> setting, you now can "force" the histogram aggregation to start building buckets on a specific
<code class="literal">min</code> value and also keep on building buckets up to a <code class="literal">max</code> value (even if there are no documents anymore). Using
<code class="literal">extended_bounds</code> only makes sense when <code class="literal">min_doc_count</code> is 0 (the empty buckets will never be returned if <code class="literal">min_doc_count</code>
is greater than 0).</p>
<p>Note that (as the name suggest) <code class="literal">extended_bounds</code> is <span class="strong strong"><strong>not</strong></span> filtering buckets. Meaning, if the <code class="literal">extended_bounds.min</code> is higher
than the values extracted from the documents, the documents will still dictate what the first bucket will be (and the
same goes for the <code class="literal">extended_bounds.max</code> and the last bucket). For filtering buckets, one should nest the histogram aggregation
under a range <code class="literal">filter</code> aggregation with the appropriate <code class="literal">from</code>/<code class="literal">to</code> settings.</p>
<p>Example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "query": {
    "constant_score": { "filter": { "range": { "price": { "to": "500" } } } }
  },
  "aggs": {
    "prices": {
      "histogram": {
        "field": "price",
        "interval": 50,
        "extended_bounds": {
          "min": 0,
          "max": 500
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1025.console"></div>
<p>When aggregating ranges, buckets are based on the values of the returned documents.  This means the response may include
buckets outside of a query&#8217;s range. For example, if your query looks for values greater than 100, and you have a range
covering 50 to 150, and an interval of 50, that document will land in 3 buckets - 50, 100, and 150. In general, it&#8217;s
best to think of the query and aggregation steps as independent - the query selects a set of documents, and then the
aggregation buckets those documents without regard to how they were selected.
See <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-range-field-note" title="Subtleties of bucketing range fields">note on bucketing range
fields</a> for more information and an example.</p>
<p><a id="search-aggregations-bucket-histogram-aggregation-hard-bounds"></a>The <code class="literal">hard_bounds</code> is a counterpart of <code class="literal">extended_bounds</code> and can limit the range of buckets in the histogram. It is
particularly useful in the case of open <a class="xref" href="mapping-types.html#range" title="Range field types">data ranges</a> that can result in a very large number of buckets.</p>
<p>Example:</p>
<a id="histogram-aggregation-hard-bounds-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "query": {
    "constant_score": { "filter": { "range": { "price": { "to": "500" } } } }
  },
  "aggs": {
    "prices": {
      "histogram": {
        "field": "price",
        "interval": 50,
        "hard_bounds": {
          "min": 100,
          "max": 200
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1026.console"></div>
<p>In this example even though the range specified in the query is up to 500, the histogram will only have 2 buckets starting at 100 and 150.
All other buckets will be omitted even if documents that should go to this buckets are present in the results.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_order_2"></a>Order<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/histogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>By default the returned buckets are sorted by their <code class="literal">key</code> ascending, though the order behaviour can be controlled using
the <code class="literal">order</code> setting. Supports the same <code class="literal">order</code> functionality as the <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation-order" title="Order"><code class="literal">Terms Aggregation</code></a>.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_offset"></a>Offset<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/histogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>By default the bucket keys start with 0 and then continue in even spaced steps
of <code class="literal">interval</code>, e.g. if the interval is <code class="literal">10</code>, the first three buckets (assuming
there is data inside them) will be <code class="literal">[0, 10)</code>, <code class="literal">[10, 20)</code>, <code class="literal">[20, 30)</code>. The bucket
boundaries can be shifted by using the <code class="literal">offset</code> option.</p>
<p>This can be best illustrated with an example. If there are 10 documents with values ranging from 5 to 14, using interval <code class="literal">10</code> will result in
two buckets with 5 documents each. If an additional offset <code class="literal">5</code> is used, there will be only one single bucket <code class="literal">[5, 15)</code> containing all the 10
documents.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_response_format"></a>Response Format<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/histogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>By default, the buckets are returned as an ordered array. It is also possible to request the response as a hash
instead keyed by the buckets keys:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "prices": {
      "histogram": {
        "field": "price",
        "interval": 50,
        "keyed": true
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1027.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "prices": {
      "buckets": {
        "0.0": {
          "key": 0.0,
          "doc_count": 1
        },
        "50.0": {
          "key": 50.0,
          "doc_count": 1
        },
        "100.0": {
          "key": 100.0,
          "doc_count": 0
        },
        "150.0": {
          "key": 150.0,
          "doc_count": 2
        },
        "200.0": {
          "key": 200.0,
          "doc_count": 3
        }
      }
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_missing_value_2"></a>Missing value<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/histogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">missing</code> parameter defines how documents that are missing a value should be treated.
By default they will be ignored but it is also possible to treat them as if they
had a value.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "quantity": {
      "histogram": {
        "field": "quantity",
        "interval": 10,
        "missing": 0 <a id="CO247-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1028.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO247-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Documents without a value in the <code class="literal">quantity</code> field will fall into the same bucket as documents that have the value <code class="literal">0</code>.</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-bucket-histogram-aggregation-histogram-fields"></a>Histogram fields<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/histogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Running a histogram aggregation over histogram fields computes the total number of counts for each interval.</p>
<p>For example, executing a histogram aggregation against the following index that stores pre-aggregated histograms
with latency metrics (in milliseconds) for different networks:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT metrics_index/_doc/1
{
  "network.name" : "net-1",
  "latency_histo" : {
      "values" : [1, 3, 8, 12, 15],
      "counts" : [3, 7, 23, 12, 6]
   }
}

PUT metrics_index/_doc/2
{
  "network.name" : "net-2",
  "latency_histo" : {
      "values" : [1, 6, 8, 12, 14],
      "counts" : [8, 17, 8, 7, 6]
   }
}

POST /metrics_index/_search?size=0
{
  "aggs": {
    "latency_buckets": {
      "histogram": {
        "field": "latency_histo",
        "interval": 5
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1029.console"></div>
<p>The <code class="literal">histogram</code> aggregation will sum the counts of each interval computed based on the <code class="literal">values</code> and
return the following output:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "prices": {
      "buckets": [
        {
          "key": 0.0,
          "doc_count": 18
        },
        {
          "key": 5.0,
          "doc_count": 48
        },
        {
          "key": 10.0,
          "doc_count": 25
        },
        {
          "key": 15.0,
          "doc_count": 6
        }
      ]
    }
  }
}</pre>
</div>
<div class="important admon">
<div class="icon"></div>
<div class="admon_content">
<p>Histogram aggregation is a bucket aggregation, which partitions documents into buckets rather than calculating metrics over fields like
metrics aggregations do. Each bucket represents a collection of documents which sub-aggregations can run on.
On the other hand, a histogram field is a pre-aggregated field representing multiple values inside a single field:
buckets of numerical data and a count of items/documents for each bucket. This mismatch between the histogram aggregations expected input
(expecting raw documents) and the histogram field (that provides summary information) limits the outcome of the aggregation
to only the doc counts for each bucket.</p>
<p><span class="strong strong"><strong>Consequently, when executing a histogram aggregation over a histogram field, no sub-aggregations are allowed.</strong></span></p>
</div>
</div>
<p>Also, when running histogram aggregation over histogram field the <code class="literal">missing</code> parameter is not supported.</p>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-iprange-aggregation"></a>IP range aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/iprange-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>Just like the dedicated <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-daterange-aggregation" title="Date range aggregation">date</a> range aggregation, there is also a dedicated range aggregation for IP typed fields:</p>
<p>Example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /ip_addresses/_search
{
  "size": 10,
  "aggs": {
    "ip_ranges": {
      "ip_range": {
        "field": "ip",
        "ranges": [
          { "to": "10.0.0.5" },
          { "from": "10.0.0.5" }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1030.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...

  "aggregations": {
    "ip_ranges": {
      "buckets": [
        {
          "key": "*-10.0.0.5",
          "to": "10.0.0.5",
          "doc_count": 10
        },
        {
          "key": "10.0.0.5-*",
          "from": "10.0.0.5",
          "doc_count": 260
        }
      ]
    }
  }
}</pre>
</div>
<p>IP ranges can also be defined as CIDR masks:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /ip_addresses/_search
{
  "size": 0,
  "aggs": {
    "ip_ranges": {
      "ip_range": {
        "field": "ip",
        "ranges": [
          { "mask": "10.0.0.0/25" },
          { "mask": "10.0.0.127/25" }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1031.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...

  "aggregations": {
    "ip_ranges": {
      "buckets": [
        {
          "key": "10.0.0.0/25",
          "from": "10.0.0.0",
          "to": "10.0.0.128",
          "doc_count": 128
        },
        {
          "key": "10.0.0.127/25",
          "from": "10.0.0.0",
          "to": "10.0.0.128",
          "doc_count": 128
        }
      ]
    }
  }
}</pre>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_keyed_response_3"></a>Keyed Response<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/iprange-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Setting the <code class="literal">keyed</code> flag to <code class="literal">true</code> will associate a unique string key with each bucket and return the ranges as a hash rather than an array:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /ip_addresses/_search
{
  "size": 0,
  "aggs": {
    "ip_ranges": {
      "ip_range": {
        "field": "ip",
        "ranges": [
          { "to": "10.0.0.5" },
          { "from": "10.0.0.5" }
        ],
        "keyed": true
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1032.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...

  "aggregations": {
    "ip_ranges": {
      "buckets": {
        "*-10.0.0.5": {
          "to": "10.0.0.5",
          "doc_count": 10
        },
        "10.0.0.5-*": {
          "from": "10.0.0.5",
          "doc_count": 260
        }
      }
    }
  }
}</pre>
</div>
<p>It is also possible to customize the key for each range:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /ip_addresses/_search
{
  "size": 0,
  "aggs": {
    "ip_ranges": {
      "ip_range": {
        "field": "ip",
        "ranges": [
          { "key": "infinity", "to": "10.0.0.5" },
          { "key": "and-beyond", "from": "10.0.0.5" }
        ],
        "keyed": true
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1033.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...

  "aggregations": {
    "ip_ranges": {
      "buckets": {
        "infinity": {
          "to": "10.0.0.5",
          "doc_count": 10
        },
        "and-beyond": {
          "from": "10.0.0.5",
          "doc_count": 260
        }
      }
    }
  }
}</pre>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-missing-aggregation"></a>Missing aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/missing-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A field data based single bucket aggregation, that creates a bucket of all documents in the current document set context that are missing a field value (effectively, missing a field or having the configured NULL value set). This aggregator will often be used in conjunction with other field data bucket aggregators (such as ranges) to return information for all the documents that could not be placed in any of the other buckets due to missing field data values.</p>
<p>Example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "products_without_a_price": {
      "missing": { "field": "price" }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1034.console"></div>
<p>In the above example, we get the total number of products that do not have a price.</p>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "products_without_a_price": {
      "doc_count": 00
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-nested-aggregation"></a>Nested aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/nested-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A special single bucket aggregation that enables aggregating nested documents.</p>
<p>For example, lets say we have an index of products, and each product holds the list of resellers - each having its own
price for the product. The mapping could look like:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /products
{
  "mappings": {
    "properties": {
      "resellers": { <a id="CO248-1"></a><i class="conum" data-value="1"></i>
        "type": "nested",
        "properties": {
          "reseller": { "type": "text" },
          "price": { "type": "double" }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1035.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO248-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p><code class="literal">resellers</code> is an array that holds nested documents.</p>
</td>
</tr>
</table>
</div>
<p>The following request adds a product with two resellers:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /products/_doc/0
{
  "name": "LED TV", <a id="CO249-1"></a><i class="conum" data-value="1"></i>
  "resellers": [
    {
      "reseller": "companyA",
      "price": 350
    },
    {
      "reseller": "companyB",
      "price": 500
    }
  ]
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1036.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO249-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>We are using a dynamic mapping for the <code class="literal">name</code> attribute.</p>
</td>
</tr>
</table>
</div>
<p>The following request returns the minimum price a product can be purchased for:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /products/_search
{
  "query": {
    "match": { "name": "led tv" }
  },
  "aggs": {
    "resellers": {
      "nested": {
        "path": "resellers"
      },
      "aggs": {
        "min_price": { "min": { "field": "resellers.price" } }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1037.console"></div>
<p>As you can see above, the nested aggregation requires the <code class="literal">path</code> of the nested documents within the top level documents.
Then one can define any type of aggregation over these nested documents.</p>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "resellers": {
      "doc_count": 2,
      "min_price": {
        "value": 350
      }
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-parent-aggregation"></a>Parent aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/parent-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A special single bucket aggregation that selects parent documents that have the specified type, as defined in a <a class="xref" href="mapping-types.html#parent-join" title="Join field type"><code class="literal">join</code> field</a>.</p>
<p>This aggregation has a single option:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<code class="literal">type</code> - The child type that should be selected.
</li>
</ul>
</div>
<p>For example, let&#8217;s say we have an index of questions and answers. The answer type has the following <code class="literal">join</code> field in the mapping:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT parent_example
{
  "mappings": {
     "properties": {
       "join": {
         "type": "join",
         "relations": {
           "question": "answer"
         }
       }
     }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1038.console"></div>
<p>The <code class="literal">question</code> document contain a tag field and the <code class="literal">answer</code> documents contain an owner field. With the <code class="literal">parent</code>
aggregation the owner buckets can be mapped to the tag buckets in a single request even though the two fields exist in
two different kinds of documents.</p>
<p>An example of a question document:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT parent_example/_doc/1
{
  "join": {
    "name": "question"
  },
  "body": "&lt;p&gt;I have Windows 2003 server and i bought a new Windows 2008 server...",
  "title": "Whats the best way to file transfer my site from server to a newer one?",
  "tags": [
    "windows-server-2003",
    "windows-server-2008",
    "file-transfer"
  ]
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1039.console"></div>
<p>Examples of <code class="literal">answer</code> documents:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT parent_example/_doc/2?routing=1
{
  "join": {
    "name": "answer",
    "parent": "1"
  },
  "owner": {
    "location": "Norfolk, United Kingdom",
    "display_name": "Sam",
    "id": 48
  },
  "body": "&lt;p&gt;Unfortunately you're pretty much limited to FTP...",
  "creation_date": "2009-05-04T13:45:37.030"
}

PUT parent_example/_doc/3?routing=1&amp;refresh
{
  "join": {
    "name": "answer",
    "parent": "1"
  },
  "owner": {
    "location": "Norfolk, United Kingdom",
    "display_name": "Troll",
    "id": 49
  },
  "body": "&lt;p&gt;Use Linux...",
  "creation_date": "2009-05-05T13:45:37.030"
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1040.console"></div>
<p>The following request can be built that connects the two together:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST parent_example/_search?size=0
{
  "aggs": {
    "top-names": {
      "terms": {
        "field": "owner.display_name.keyword",
        "size": 10
      },
      "aggs": {
        "to-questions": {
          "parent": {
            "type" : "answer" <a id="CO250-1"></a><i class="conum" data-value="1"></i>
          },
          "aggs": {
            "top-tags": {
              "terms": {
                "field": "tags.keyword",
                "size": 10
              }
            }
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1041.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO250-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">type</code> points to type / mapping with the name <code class="literal">answer</code>.</p>
</td>
</tr>
</table>
</div>
<p>The above example returns the top answer owners and per owner the top question tags.</p>
<p>Possible response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "took": 9,
  "timed_out": false,
  "_shards": {
    "total": 1,
    "successful": 1,
    "skipped": 0,
    "failed": 0
  },
  "hits": {
    "total" : {
      "value": 3,
      "relation": "eq"
    },
    "max_score": null,
    "hits": []
  },
  "aggregations": {
    "top-names": {
      "doc_count_error_upper_bound": 0,
      "sum_other_doc_count": 0,
      "buckets": [
        {
          "key": "Sam",
          "doc_count": 1, <a id="CO251-1"></a><i class="conum" data-value="1"></i>
          "to-questions": {
            "doc_count": 1, <a id="CO251-2"></a><i class="conum" data-value="2"></i>
            "top-tags": {
              "doc_count_error_upper_bound": 0,
              "sum_other_doc_count": 0,
              "buckets": [
                {
                  "key": "file-transfer",
                  "doc_count": 1
                },
                {
                  "key": "windows-server-2003",
                  "doc_count": 1
                },
                {
                  "key": "windows-server-2008",
                  "doc_count": 1
                }
              ]
            }
          }
        },
        {
          "key": "Troll",
          "doc_count": 1,
          "to-questions": {
            "doc_count": 1,
            "top-tags": {
              "doc_count_error_upper_bound": 0,
              "sum_other_doc_count": 0,
              "buckets": [
                {
                  "key": "file-transfer",
                  "doc_count": 1
                },
                {
                  "key": "windows-server-2003",
                  "doc_count": 1
                },
                {
                  "key": "windows-server-2008",
                  "doc_count": 1
                }
              ]
            }
          }
        }
      ]
    }
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO251-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The number of answer documents with the tag <code class="literal">Sam</code>, <code class="literal">Troll</code>, etc.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO251-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>The number of question documents that are related to answer documents with the tag <code class="literal">Sam</code>, <code class="literal">Troll</code>, etc.</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-range-aggregation"></a>Range aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/range-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A multi-bucket value source based aggregation that enables the user to define a set of ranges - each representing a bucket. During the aggregation process, the values extracted from each document will be checked against each bucket range and "bucket" the relevant/matching document.
Note that this aggregation includes the <code class="literal">from</code> value and excludes the <code class="literal">to</code> value for each range.</p>
<p>Example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "price_ranges": {
      "range": {
        "field": "price",
        "ranges": [
          { "to": 100.0 },
          { "from": 100.0, "to": 200.0 },
          { "from": 200.0 }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1042.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "price_ranges": {
      "buckets": [
        {
          "key": "*-100.0",
          "to": 100.0,
          "doc_count": 2
        },
        {
          "key": "100.0-200.0",
          "from": 100.0,
          "to": 200.0,
          "doc_count": 2
        },
        {
          "key": "200.0-*",
          "from": 200.0,
          "doc_count": 3
        }
      ]
    }
  }
}</pre>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_keyed_response_4"></a>Keyed Response<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/range-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Setting the <code class="literal">keyed</code> flag to <code class="literal">true</code> will associate a unique string key with each bucket and return the ranges as a hash rather than an array:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "price_ranges": {
      "range": {
        "field": "price",
        "keyed": true,
        "ranges": [
          { "to": 100 },
          { "from": 100, "to": 200 },
          { "from": 200 }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1043.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "price_ranges": {
      "buckets": {
        "*-100.0": {
          "to": 100.0,
          "doc_count": 2
        },
        "100.0-200.0": {
          "from": 100.0,
          "to": 200.0,
          "doc_count": 2
        },
        "200.0-*": {
          "from": 200.0,
          "doc_count": 3
        }
      }
    }
  }
}</pre>
</div>
<p>It is also possible to customize the key for each range:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "price_ranges": {
      "range": {
        "field": "price",
        "keyed": true,
        "ranges": [
          { "key": "cheap", "to": 100 },
          { "key": "average", "from": 100, "to": 200 },
          { "key": "expensive", "from": 200 }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1044.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "price_ranges": {
      "buckets": {
        "cheap": {
          "to": 100.0,
          "doc_count": 2
        },
        "average": {
          "from": 100.0,
          "to": 200.0,
          "doc_count": 2
        },
        "expensive": {
          "from": 200.0,
          "doc_count": 3
        }
      }
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_script"></a>Script<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/range-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Range aggregation accepts a <code class="literal">script</code> parameter. This parameter allows to defined an inline <code class="literal">script</code> that
will be executed during aggregation execution.</p>
<p>The following example shows how to use an <code class="literal">inline</code> script with the <code class="literal">painless</code> script language and no script parameters:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "price_ranges": {
      "range": {
        "script": {
          "lang": "painless",
          "source": "doc['price'].value"
        },
        "ranges": [
          { "to": 100 },
          { "from": 100, "to": 200 },
          { "from": 200 }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1045.console"></div>
<p>It is also possible to use stored scripts. Here is a simple stored script:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /_scripts/convert_currency
{
  "script": {
    "lang": "painless",
    "source": "doc[params.field].value * params.conversion_rate"
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1046.console"></div>
<p>And this new stored script can be used in the range aggregation like this:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "price_ranges": {
      "range": {
        "script": {
          "id": "convert_currency",       <a id="CO252-1"></a><i class="conum" data-value="1"></i>
          "params": {                     <a id="CO252-2"></a><i class="conum" data-value="2"></i>
            "field": "price",
            "conversion_rate": 0.835526591
          }
        },
        "ranges": [
          { "from": 0, "to": 100 },
          { "from": 100 }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1047.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO252-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Id of the stored script</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO252-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>Parameters to use when executing the stored script</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_value_script"></a>Value Script<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/range-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Lets say the product prices are in USD but we would like to get the price ranges in EURO. We can use value script to convert the prices prior the aggregation (assuming conversion rate of 0.8)</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /sales/_search
{
  "aggs": {
    "price_ranges": {
      "range": {
        "field": "price",
        "script": {
          "source": "_value * params.conversion_rate",
          "params": {
            "conversion_rate": 0.8
          }
        },
        "ranges": [
          { "to": 35 },
          { "from": 35, "to": 70 },
          { "from": 70 }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1048.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_sub_aggregations_2"></a>Sub Aggregations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/range-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The following example, not only "bucket" the documents to the different buckets but also computes statistics over the prices in each price range</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "price_ranges": {
      "range": {
        "field": "price",
        "ranges": [
          { "to": 100 },
          { "from": 100, "to": 200 },
          { "from": 200 }
        ]
      },
      "aggs": {
        "price_stats": {
          "stats": { "field": "price" }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1049.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "price_ranges": {
      "buckets": [
        {
          "key": "*-100.0",
          "to": 100.0,
          "doc_count": 2,
          "price_stats": {
            "count": 2,
            "min": 10.0,
            "max": 50.0,
            "avg": 30.0,
            "sum": 60.0
          }
        },
        {
          "key": "100.0-200.0",
          "from": 100.0,
          "to": 200.0,
          "doc_count": 2,
          "price_stats": {
            "count": 2,
            "min": 150.0,
            "max": 175.0,
            "avg": 162.5,
            "sum": 325.0
          }
        },
        {
          "key": "200.0-*",
          "from": 200.0,
          "doc_count": 3,
          "price_stats": {
            "count": 3,
            "min": 200.0,
            "max": 200.0,
            "avg": 200.0,
            "sum": 600.0
          }
        }
      ]
    }
  }
}</pre>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-rare-terms-aggregation"></a>Rare terms aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/rare-terms-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A multi-bucket value source based aggregation which finds "rare" terms&#8201;&#8212;&#8201;terms that are at the long-tail
of the distribution and are not frequent.  Conceptually, this is like a <code class="literal">terms</code> aggregation that is
sorted by <code class="literal">_count</code> ascending.  As noted in the <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation-order" title="Order">terms aggregation docs</a>,
actually ordering a <code class="literal">terms</code> agg by count ascending has unbounded error.  Instead, you should use the <code class="literal">rare_terms</code>
aggregation</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_syntax"></a>Syntax<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/rare-terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>A <code class="literal">rare_terms</code> aggregation looks like this in isolation:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "rare_terms": {
    "field": "the_field",
    "max_doc_count": 1
  }
}</pre>
</div>
<div class="table">
<p class="title"><strong>Table 40. <code class="literal">rare_terms</code> Parameters</strong></p>
<div class="table-contents">
<table border="1" cellpadding="4px" summary="rare_terms Parameters">
<colgroup>
<col class="col_1"/>
<col class="col_2"/>
<col class="col_3"/>
<col class="col_4"/>
</colgroup>
<tbody>
<tr>
<td align="left" valign="top"><p>Parameter Name</p></td>
<td align="left" valign="top"><p>Description</p></td>
<td align="left" valign="top"><p>Required</p></td>
<td align="left" valign="top"><p>Default Value</p></td>
</tr>
<tr>
<td align="left" valign="top"><p><code class="literal">field</code></p></td>
<td align="left" valign="top"><p>The field we wish to find rare terms in</p></td>
<td align="left" valign="top"><p>Required</p></td>
<td align="left" valign="top"><p></p></td>
</tr>
<tr>
<td align="left" valign="top"><p><code class="literal">max_doc_count</code></p></td>
<td align="left" valign="top"><p>The maximum number of documents a term should appear in.</p></td>
<td align="left" valign="top"><p>Optional</p></td>
<td align="left" valign="top"><p><code class="literal">1</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p><code class="literal">precision</code></p></td>
<td align="left" valign="top"><p>The precision of the internal CuckooFilters.  Smaller precision leads to
better approximation, but higher memory usage. Cannot be smaller than <code class="literal">0.00001</code></p></td>
<td align="left" valign="top"><p>Optional</p></td>
<td align="left" valign="top"><p><code class="literal">0.01</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p><code class="literal">include</code></p></td>
<td align="left" valign="top"><p>Terms that should be included in the aggregation</p></td>
<td align="left" valign="top"><p>Optional</p></td>
<td align="left" valign="top"><p></p></td>
</tr>
<tr>
<td align="left" valign="top"><p><code class="literal">exclude</code></p></td>
<td align="left" valign="top"><p>Terms that should be excluded from the aggregation</p></td>
<td align="left" valign="top"><p>Optional</p></td>
<td align="left" valign="top"><p></p></td>
</tr>
<tr>
<td align="left" valign="top"><p><code class="literal">missing</code></p></td>
<td align="left" valign="top"><p>The value that should be used if a document does not have the field being aggregated</p></td>
<td align="left" valign="top"><p>Optional</p></td>
<td align="left" valign="top"><p></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<p>Example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "genres": {
      "rare_terms": {
        "field": "genre"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1050.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "genres": {
      "buckets": [
        {
          "key": "swing",
          "doc_count": 1
        }
      ]
    }
  }
}</pre>
</div>
<p>In this example, the only bucket that we see is the "swing" bucket, because it is the only term that appears in
one document.  If we increase the <code class="literal">max_doc_count</code> to <code class="literal">2</code>, we&#8217;ll see some more buckets:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "genres": {
      "rare_terms": {
        "field": "genre",
        "max_doc_count": 2
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1051.console"></div>
<p>This now shows the "jazz" term which has a <code class="literal">doc_count</code> of 2":</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "genres": {
      "buckets": [
        {
          "key": "swing",
          "doc_count": 1
        },
        {
          "key": "jazz",
          "doc_count": 2
        }
      ]
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-bucket-rare-terms-aggregation-max-doc-count"></a>Maximum document count<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/rare-terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">max_doc_count</code> parameter is used to control the upper bound of document counts that a term can have.  There
is not a size limitation on the <code class="literal">rare_terms</code> agg like <code class="literal">terms</code> agg has.  This means that terms
which match the <code class="literal">max_doc_count</code> criteria will be returned.  The aggregation functions in this manner to avoid
the order-by-ascending issues that afflict the <code class="literal">terms</code> aggregation.</p>
<p>This does, however, mean that  a large number of results can be returned if chosen incorrectly.
To limit the danger of this setting, the maximum <code class="literal">max_doc_count</code> is 100.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-bucket-rare-terms-aggregation-max-buckets"></a>Max Bucket Limit<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/rare-terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The Rare Terms aggregation is more liable to trip the <code class="literal">search.max_buckets</code> soft limit than other aggregations due
to how it works.  The <code class="literal">max_bucket</code> soft-limit is evaluated on a per-shard basis while the aggregation is collecting
results.  It is possible for a term to be "rare" on a shard but become "not rare" once all the shard results are
merged together.  This means that individual shards tend to collect more buckets than are truly rare, because
they only have their own local view.  This list is ultimately pruned to the correct, smaller list of rare
terms on the coordinating node&#8230;&#8203; but a shard may have already tripped the <code class="literal">max_buckets</code> soft limit and aborted
the request.</p>
<p>When aggregating on fields that have potentially many "rare" terms, you may need to increase the <code class="literal">max_buckets</code> soft
limit.  Alternatively, you might need to find a way to filter the results to return fewer rare values (smaller time
span, filter by category, etc), or re-evaluate your definition of "rare" (e.g. if something
appears 100,000 times, is it truly "rare"?)</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-bucket-rare-terms-aggregation-approximate-counts"></a>Document counts are approximate<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/rare-terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The naive way to determine the "rare" terms in a dataset is to place all the values in a map, incrementing counts
as each document is visited, then return the bottom <code class="literal">n</code> rows.  This does not scale beyond even modestly sized data
sets.  A sharded approach where only the "top n" values are retained from each shard (ala the <code class="literal">terms</code> aggregation)
fails because the long-tail nature of the problem means it is impossible to find the "top n" bottom values without
simply collecting all the values from all shards.</p>
<p>Instead, the Rare Terms aggregation uses a different approximate algorithm:</p>
<div class="olist orderedlist">
<ol class="orderedlist">
<li class="listitem">
Values are placed in a map the first time they are seen.
</li>
<li class="listitem">
Each addition occurrence of the term increments a counter in the map
</li>
<li class="listitem">
If the counter &gt; the <code class="literal">max_doc_count</code> threshold, the term is removed from the map and placed in a
<a href="https://www.cs.cmu.edu/~dga/papers/cuckoo-conext2014.pdf" class="ulink" target="_top">CuckooFilter</a>
</li>
<li class="listitem">
The CuckooFilter is consulted on each term.  If the value is inside the filter, it is known to be above the
threshold already and skipped.
</li>
</ol>
</div>
<p>After execution, the map of values is the map of "rare" terms under the <code class="literal">max_doc_count</code> threshold.  This map and CuckooFilter
are then merged with all other shards.  If there are terms that are greater than the threshold (or appear in
a different shard&#8217;s CuckooFilter) the term is removed from the merged list.  The final map of values is returned
to the user as the "rare" terms.</p>
<p>CuckooFilters have the possibility of returning false positives (they can say a value exists in their collection when
it actually does not).  Since the CuckooFilter is being used to see if a term is over threshold, this means a false positive
from the CuckooFilter will mistakenly say a value is common when it is not (and thus exclude it from it final list of buckets).
Practically, this means the aggregations exhibits false-negative behavior since the filter is being used "in reverse"
of how people generally think of approximate set membership sketches.</p>
<p>CuckooFilters are described in more detail in the paper:</p>
<p><a href="https://www.cs.cmu.edu/~dga/papers/cuckoo-conext2014.pdf" class="ulink" target="_top">Fan, Bin, et al. "Cuckoo filter: Practically better than bloom."</a>
Proceedings of the 10th ACM International on Conference on emerging Networking Experiments and Technologies. ACM, 2014.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_precision"></a>Precision<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/rare-terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Although the internal CuckooFilter is approximate in nature, the false-negative rate can be controlled with a
<code class="literal">precision</code> parameter.  This allows the user to trade more runtime memory for more accurate results.</p>
<p>The default precision is <code class="literal">0.001</code>, and the smallest (e.g. most accurate and largest memory overhead) is <code class="literal">0.00001</code>.
Below are some charts which demonstrate how the accuracy of the aggregation is affected by precision and number
of distinct terms.</p>
<p>The X-axis shows the number of distinct values the aggregation has seen, and the Y-axis shows the percent error.
Each line series represents one "rarity" condition (ranging from one rare item to 100,000 rare items).  For example,
the orange "10" line means ten of the values were "rare" (<code class="literal">doc_count == 1</code>), out of 1-20m distinct values (where the
rest of the values had <code class="literal">doc_count &gt; 1</code>)</p>
<p>This first chart shows precision <code class="literal">0.01</code>:</p>
<p><span class="image"><img src="images/rare_terms/accuracy_01.png" alt="accuracy 01"></span></p>
<p>And precision <code class="literal">0.001</code> (the default):</p>
<p><span class="image"><img src="images/rare_terms/accuracy_001.png" alt="accuracy 001"></span></p>
<p>And finally <code class="literal">precision 0.0001</code>:</p>
<p><span class="image"><img src="images/rare_terms/accuracy_0001.png" alt="accuracy 0001"></span></p>
<p>The default precision of <code class="literal">0.001</code> maintains an accuracy of &lt; 2.5% for the tested conditions, and accuracy slowly
degrades in a controlled, linear fashion as the number of distinct values increases.</p>
<p>The default precision of <code class="literal">0.001</code> has a memory profile of <code class="literal">1.748⁻⁶ * n</code> bytes, where <code class="literal">n</code> is the number
of distinct values the aggregation has seen (it can also be roughly eyeballed, e.g. 20 million unique values is about
30mb of memory).  The memory usage is linear to the number of distinct values regardless of which precision is chosen,
the precision only affects the slope of the memory profile as seen in this chart:</p>
<p><span class="image"><img src="images/rare_terms/memory.png" alt="memory"></span></p>
<p>For comparison, an equivalent terms aggregation at 20 million buckets would be roughly
<code class="literal">20m * 69b == ~1.38gb</code> (with 69 bytes being a very optimistic estimate of an empty bucket cost, far lower than what
the circuit breaker accounts for).  So although the <code class="literal">rare_terms</code> agg is relatively heavy, it is still orders of
magnitude smaller than the equivalent terms aggregation</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_filtering_values"></a>Filtering Values<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/rare-terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>It is possible to filter the values for which buckets will be created. This can be done using the <code class="literal">include</code> and
<code class="literal">exclude</code> parameters which are based on regular expression strings or arrays of exact values. Additionally,
<code class="literal">include</code> clauses can filter using <code class="literal">partition</code> expressions.</p>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_filtering_values_with_regular_expressions"></a>Filtering Values with regular expressions<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/rare-terms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "genres": {
      "rare_terms": {
        "field": "genre",
        "include": "swi*",
        "exclude": "electro*"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1052.console"></div>
<p>In the above example, buckets will be created for all the tags that starts with <code class="literal">swi</code>, except those starting
with <code class="literal">electro</code> (so the tag <code class="literal">swing</code> will be aggregated but not <code class="literal">electro_swing</code>). The <code class="literal">include</code> regular expression will determine what
values are "allowed" to be aggregated, while the <code class="literal">exclude</code> determines the values that should not be aggregated. When
both are defined, the <code class="literal">exclude</code> has precedence, meaning, the <code class="literal">include</code> is evaluated first and only then the <code class="literal">exclude</code>.</p>
<p>The syntax is the same as <a class="xref" href="regexp-syntax.html" title="Regular expression syntax">regexp queries</a>.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_filtering_values_with_exact_values"></a>Filtering Values with exact values<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/rare-terms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>For matching based on exact values the <code class="literal">include</code> and <code class="literal">exclude</code> parameters can simply take an array of
strings that represent the terms as they are found in the index:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "genres": {
      "rare_terms": {
        "field": "genre",
        "include": [ "swing", "rock" ],
        "exclude": [ "jazz" ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1053.console"></div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_missing_value_3"></a>Missing value<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/rare-terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">missing</code> parameter defines how documents that are missing a value should be treated.
By default they will be ignored but it is also possible to treat them as if they
had a value.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "genres": {
      "rare_terms": {
        "field": "genre",
        "missing": "N/A" <a id="CO253-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1054.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO253-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Documents without a value in the <code class="literal">tags</code> field will fall into the same bucket as documents that have the value <code class="literal">N/A</code>.</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_nested_rareterms_and_scoring_sub_aggregations"></a>Nested, RareTerms, and scoring sub-aggregations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/rare-terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The RareTerms aggregation has to operate in <code class="literal">breadth_first</code> mode, since it needs to prune terms as doc count thresholds
are breached.  This requirement means the RareTerms aggregation is incompatible with certain combinations of aggregations
that require <code class="literal">depth_first</code>. In particular, scoring sub-aggregations that are inside a <code class="literal">nested</code> force the entire aggregation tree to run
in <code class="literal">depth_first</code> mode.  This will throw an exception since RareTerms is unable to process <code class="literal">depth_first</code>.</p>
<p>As a concrete example, if <code class="literal">rare_terms</code> aggregation is the child of a <code class="literal">nested</code> aggregation, and one of the child aggregations of <code class="literal">rare_terms</code>
needs document scores (like a <code class="literal">top_hits</code> aggregation), this will throw an exception.</p>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-reverse-nested-aggregation"></a>Reverse nested aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/reverse-nested-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A special single bucket aggregation that enables aggregating on parent docs from nested documents. Effectively this
aggregation can break out of the nested block structure and link to other nested structures or the root document,
which allows nesting other aggregations that aren&#8217;t part of the nested object in a nested aggregation.</p>
<p>The <code class="literal">reverse_nested</code> aggregation must be defined inside a <code class="literal">nested</code> aggregation.</p>
<div class="ulist itemizedlist">
<p class="title"><strong>Options:</strong></p>
<ul class="itemizedlist">
<li class="listitem">
<code class="literal">path</code> - Which defines to what nested object field should be joined back. The default is empty,
which means that it joins back to the root / main document level. The path cannot contain a reference to
a nested object field that falls outside the <code class="literal">nested</code> aggregation&#8217;s nested structure a <code class="literal">reverse_nested</code> is in.
</li>
</ul>
</div>
<p>For example, lets say we have an index for a ticket system with issues and comments. The comments are inlined into
the issue documents as nested documents. The mapping could look like:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /issues
{
  "mappings": {
    "properties": {
      "tags": { "type": "keyword" },
      "comments": {                            <a id="CO254-1"></a><i class="conum" data-value="1"></i>
        "type": "nested",
        "properties": {
          "username": { "type": "keyword" },
          "comment": { "type": "text" }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1055.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO254-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">comments</code> is an array that holds nested documents under the <code class="literal">issue</code> object.</p>
</td>
</tr>
</table>
</div>
<p>The following aggregations will return the top commenters' username that have commented and per top commenter the top
tags of the issues the user has commented on:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /issues/_search
{
  "query": {
    "match_all": {}
  },
  "aggs": {
    "comments": {
      "nested": {
        "path": "comments"
      },
      "aggs": {
        "top_usernames": {
          "terms": {
            "field": "comments.username"
          },
          "aggs": {
            "comment_to_issue": {
              "reverse_nested": {}, <a id="CO255-1"></a><i class="conum" data-value="1"></i>
              "aggs": {
                "top_tags_per_comment": {
                  "terms": {
                    "field": "tags"
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1056.console"></div>
<p>As you can see above, the <code class="literal">reverse_nested</code> aggregation is put in to a <code class="literal">nested</code> aggregation as this is the only place
in the dsl where the <code class="literal">reverse_nested</code> aggregation can be used. Its sole purpose is to join back to a parent doc higher
up in the nested structure.</p>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO255-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>A <code class="literal">reverse_nested</code> aggregation that joins back to the root / main document level, because no <code class="literal">path</code> has been defined.
Via the <code class="literal">path</code> option the <code class="literal">reverse_nested</code> aggregation can join back to a different level, if multiple layered nested
object types have been defined in the mapping</p>
</td>
</tr>
</table>
</div>
<p>Possible response snippet:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "aggregations": {
    "comments": {
      "doc_count": 1,
      "top_usernames": {
        "doc_count_error_upper_bound" : 0,
        "sum_other_doc_count" : 0,
        "buckets": [
          {
            "key": "username_1",
            "doc_count": 1,
            "comment_to_issue": {
              "doc_count": 1,
              "top_tags_per_comment": {
                "doc_count_error_upper_bound" : 0,
                "sum_other_doc_count" : 0,
                "buckets": [
                  {
                    "key": "tag_1",
                    "doc_count": 1
                  }
                  ...
                ]
              }
            }
          }
          ...
        ]
      }
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-sampler-aggregation"></a>Sampler aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/sampler-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A filtering aggregation used to limit any sub aggregations' processing to a sample of the top-scoring documents.</p>
<div class="ulist itemizedlist">
<p class="title"><strong>Example use cases:</strong></p>
<ul class="itemizedlist">
<li class="listitem">
Tightening the focus of analytics to high-relevance matches rather than the potentially very long tail of low-quality matches
</li>
<li class="listitem">
Reducing the running cost of aggregations that can produce useful results using only samples e.g. <code class="literal">significant_terms</code>
</li>
</ul>
</div>
<p>Example:</p>
<p>A query on StackOverflow data for the popular term <code class="literal">javascript</code> OR the rarer term
<code class="literal">kibana</code> will match many documents - most of them missing the word Kibana. To focus
the <code class="literal">significant_terms</code> aggregation on top-scoring documents that are more likely to match
the most interesting parts of our query we use a sample.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /stackoverflow/_search?size=0
{
  "query": {
    "query_string": {
      "query": "tags:kibana OR tags:javascript"
    }
  },
  "aggs": {
    "sample": {
      "sampler": {
        "shard_size": 200
      },
      "aggs": {
        "keywords": {
          "significant_terms": {
            "field": "tags",
            "exclude": [ "kibana", "javascript" ]
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1057.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "sample": {
      "doc_count": 200, <a id="CO256-1"></a><i class="conum" data-value="1"></i>
      "keywords": {
        "doc_count": 200,
        "bg_count": 650,
        "buckets": [
          {
            "key": "elasticsearch",
            "doc_count": 150,
            "score": 1.078125,
            "bg_count": 200
          },
          {
            "key": "logstash",
            "doc_count": 50,
            "score": 0.5625,
            "bg_count": 50
          }
        ]
      }
    }
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO256-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>200 documents were sampled in total. The cost of performing the nested significant_terms aggregation was
therefore limited rather than unbounded.</p>
</td>
</tr>
</table>
</div>
<p>Without the <code class="literal">sampler</code> aggregation the request query considers the full "long tail" of low-quality matches and therefore identifies
less significant terms such as <code class="literal">jquery</code> and <code class="literal">angular</code> rather than focusing on the more insightful Kibana-related terms.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /stackoverflow/_search?size=0
{
  "query": {
    "query_string": {
      "query": "tags:kibana OR tags:javascript"
    }
  },
  "aggs": {
    "low_quality_keywords": {
      "significant_terms": {
        "field": "tags",
        "size": 3,
        "exclude": [ "kibana", "javascript" ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1058.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "low_quality_keywords": {
      "doc_count": 600,
      "bg_count": 650,
      "buckets": [
        {
          "key": "angular",
          "doc_count": 200,
          "score": 0.02777,
          "bg_count": 200
        },
        {
          "key": "jquery",
          "doc_count": 200,
          "score": 0.02777,
          "bg_count": 200
        },
        {
          "key": "logstash",
          "doc_count": 50,
          "score": 0.0069,
          "bg_count": 50
        }
      ]
    }
  }
}</pre>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_shard_size_2"></a>shard_size<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/sampler-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">shard_size</code> parameter limits how many top-scoring documents are collected in the sample processed on each shard.
The default value is 100.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_limitations_6"></a>Limitations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/sampler-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="sampler-breadth-first-nested-agg"></a>Cannot be nested under <code class="literal">breadth_first</code> aggregations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/sampler-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>Being a quality-based filter the sampler aggregation needs access to the relevance score produced for each document.
It therefore cannot be nested under a <code class="literal">terms</code> aggregation which has the <code class="literal">collect_mode</code> switched from the default <code class="literal">depth_first</code> mode to <code class="literal">breadth_first</code> as this discards scores.
In this situation an error will be thrown.</p>
</div>

</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-significantterms-aggregation"></a>Significant terms aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>An aggregation that returns interesting or unusual occurrences of terms in a set.</p>
<div class="ulist itemizedlist">
<p class="title"><strong>Example use cases:</strong></p>
<ul class="itemizedlist">
<li class="listitem">
Suggesting "H5N1" when users search for "bird flu" in text
</li>
<li class="listitem">
Identifying the merchant that is the "common point of compromise" from the transaction history of credit card owners reporting loss
</li>
<li class="listitem">
Suggesting keywords relating to stock symbol $ATI for an automated news classifier
</li>
<li class="listitem">
Spotting the fraudulent doctor who is diagnosing more than their fair share of whiplash injuries
</li>
<li class="listitem">
Spotting the tire manufacturer who has a disproportionate number of blow-outs
</li>
</ul>
</div>
<p>In all these cases the terms being selected are not simply the most popular terms in a set.
They are the terms that have undergone a significant change in popularity measured between a <em>foreground</em> and <em>background</em> set.
If the term "H5N1" only exists in 5 documents in a 10 million document index and yet is found in 4 of the 100 documents that make up a user&#8217;s search results
that is significant and probably very relevant to their search. 5/10,000,000 vs 4/100 is a big swing in frequency.</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_single_set_analysis"></a>Single-set analysis<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>In the simplest case, the <em>foreground</em> set of interest is the search results matched by a query and the <em>background</em>
set used for statistical comparisons is the index or indices from which the results were gathered.</p>
<p>Example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "query": {
    "terms": { "force": [ "British Transport Police" ] }
  },
  "aggregations": {
    "significant_crime_types": {
      "significant_terms": { "field": "crime_type" }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1059.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "significant_crime_types": {
      "doc_count": 47347,
      "bg_count": 5064554,
      "buckets": [
        {
          "key": "Bicycle theft",
          "doc_count": 3640,
          "score": 0.371235374214817,
          "bg_count": 66799
        }
              ...
      ]
    }
  }
}</pre>
</div>
<p>When querying an index of all crimes from all police forces, what these results show is that the British Transport Police force
stand out as a force dealing with a disproportionately large number of bicycle thefts. Ordinarily, bicycle thefts represent only 1% of crimes (66799/5064554)
but for the British Transport Police, who handle crime on railways and stations, 7% of crimes (3640/47347) is
a bike theft. This is a significant seven-fold increase in frequency and so this anomaly was highlighted as the top crime type.</p>
<p>The problem with using a query to spot anomalies is it only gives us one subset to use for comparisons.
To discover all the other police forces' anomalies we would have to repeat the query for each of the different forces.</p>
<p>This can be a tedious way to look for unusual patterns in an index</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_multi_set_analysis"></a>Multi-set analysis<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>A simpler way to perform analysis across multiple categories is to use a parent-level aggregation to segment the data ready for analysis.</p>
<p>Example using a parent aggregation for segmentation:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggregations": {
    "forces": {
      "terms": { "field": "force" },
      "aggregations": {
        "significant_crime_types": {
          "significant_terms": { "field": "crime_type" }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1060.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
 ...
 "aggregations": {
    "forces": {
        "doc_count_error_upper_bound": 1375,
        "sum_other_doc_count": 7879845,
        "buckets": [
            {
                "key": "Metropolitan Police Service",
                "doc_count": 894038,
                "significant_crime_types": {
                    "doc_count": 894038,
                    "bg_count": 5064554,
                    "buckets": [
                        {
                            "key": "Robbery",
                            "doc_count": 27617,
                            "score": 0.0599,
                            "bg_count": 53182
                        }
                        ...
                    ]
                }
            },
            {
                "key": "British Transport Police",
                "doc_count": 47347,
                "significant_crime_types": {
                    "doc_count": 47347,
                    "bg_count": 5064554,
                    "buckets": [
                        {
                            "key": "Bicycle theft",
                            "doc_count": 3640,
                            "score": 0.371,
                            "bg_count": 66799
                        }
                        ...
                    ]
                }
            }
        ]
    }
  }
}</pre>
</div>
<p>Now we have anomaly detection for each of the police forces using a single request.</p>
<p>We can use other forms of top-level aggregations to segment our data, for example segmenting by geographic
area to identify unusual hot-spots of a particular crime type:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "hotspots": {
      "geohash_grid": {
        "field": "location",
        "precision": 5
      },
      "aggs": {
        "significant_crime_types": {
          "significant_terms": { "field": "crime_type" }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1061.console"></div>
<p>This example uses the <code class="literal">geohash_grid</code> aggregation to create result buckets that represent geographic areas, and inside each
bucket we can identify anomalous levels of a crime type in these tightly-focused areas e.g.</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Airports exhibit unusual numbers of weapon confiscations
</li>
<li class="listitem">
Universities show uplifts of bicycle thefts
</li>
</ul>
</div>
<p>At a higher geohash_grid zoom-level with larger coverage areas we would start to see where an entire police-force may be
tackling an unusual volume of a particular crime type.</p>
<p>Obviously a time-based top-level segmentation would help identify current trends for each point in time
where a simple <code class="literal">terms</code> aggregation would typically show the very popular "constants" that persist across all time slots.</p>
<div class="sidebar">
<div class="titlepage"><div><div>
<p class="title"><strong>How are the scores calculated?</strong></p>
</div></div></div>
<p>The numbers returned for scores are primarily intended for ranking different suggestions sensibly rather than something easily understood by end users. The scores are derived from the doc frequencies in <em>foreground</em> and <em>background</em> sets. In brief, a term is considered significant if there is a noticeable difference in the frequency in which a term appears in the subset and in the background. The way the terms are ranked can be configured, see "Parameters" section.</p>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_use_on_free_text_fields"></a>Use on free-text fields<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The significant_terms aggregation can be used effectively on tokenized free-text fields to suggest:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
keywords for refining end-user searches
</li>
<li class="listitem">
keywords for use in percolator queries
</li>
</ul>
</div>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>Picking a free-text field as the subject of a significant terms analysis can be expensive! It will attempt
to load every unique word into RAM. It is recommended to only use this on smaller indices.</p>
</div>
</div>
<div class="sidebar">
<div class="titlepage"><div><div>
<p class="title"><strong>Use the <em>"like this but not this"</em> pattern</strong></p>
</div></div></div>
<p>You can spot mis-categorized content by first searching a structured field e.g. <code class="literal">category:adultMovie</code> and use significant_terms on the
free-text "movie_description" field. Take the suggested words (I&#8217;ll leave them to your imagination) and then search for all movies NOT marked as category:adultMovie but containing these keywords.
You now have a ranked list of badly-categorized movies that you should reclassify or at least remove from the "familyFriendly" category.</p>
<p>The significance score from each term can also provide a useful <code class="literal">boost</code> setting to sort matches.
Using the <code class="literal">minimum_should_match</code> setting of the <code class="literal">terms</code> query with the keywords will help control the balance of precision/recall in the result set i.e
a high setting would have a small number of relevant results packed full of keywords and a setting of "1" would produce a more exhaustive results set with all documents containing <em>any</em> keyword.</p>
</div>
<div class="tip admon">
<div class="icon"></div>
<div class="admon_content">
<p><strong>Show significant_terms in context</strong>Free-text significant_terms are much more easily understood when viewed in context. Take the results of <code class="literal">significant_terms</code> suggestions from a
free-text field and use them in a <code class="literal">terms</code> query on the same field with a <code class="literal">highlight</code> clause to present users with example snippets of documents. When the terms
are presented unstemmed, highlighted, with the right case, in the right order and with some context, their significance/meaning is more readily apparent.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_custom_background_sets"></a>Custom background sets<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Ordinarily, the foreground set of documents is "diffed" against a background set of all the documents in your index.
However, sometimes it may prove useful to use a narrower background set as the basis for comparisons.
For example, a query on documents relating to "Madrid" in an index with content from all over the world might reveal that "Spanish"
was a significant term. This may be true but if you want some more focused terms you could use a <code class="literal">background_filter</code>
on the term <em>spain</em> to establish a narrower set of documents as context. With this as a background "Spanish" would now
be seen as commonplace and therefore not as significant as words like "capital" that relate more strongly with Madrid.
Note that using a background filter will slow things down - each term&#8217;s background frequency must now be derived on-the-fly from filtering posting lists rather than reading the index&#8217;s pre-computed count for a term.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_limitations_7"></a>Limitations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_significant_terms_must_be_indexed_values"></a>Significant terms must be indexed values<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>Unlike the terms aggregation it is currently not possible to use script-generated terms for counting purposes.
Because of the way the significant_terms aggregation must consider both <em>foreground</em> and <em>background</em> frequencies
it would be prohibitively expensive to use a script on the entire index to obtain background frequencies for comparisons.
Also DocValues are not supported as sources of term data for similar reasons.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_no_analysis_of_floating_point_fields"></a>No analysis of floating point fields<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>Floating point fields are currently not supported as the subject of significant_terms analysis.
While integer or long fields can be used to represent concepts like bank account numbers or category numbers which
can be interesting to track, floating point fields are usually used to represent quantities of something.
As such, individual floating point terms are not useful for this form of frequency analysis.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_use_as_a_parent_aggregation"></a>Use as a parent aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>If there is the equivalent of a <code class="literal">match_all</code> query or no query criteria providing a subset of the index the significant_terms aggregation should not be used as the
top-most aggregation - in this scenario the <em>foreground</em> set is exactly the same as the <em>background</em> set and
so there is no difference in document frequencies to observe and from which to make sensible suggestions.</p>
<p>Another consideration is that  the significant_terms aggregation produces many candidate results at shard level
that are only later pruned on the reducing node once all statistics from all shards are merged. As a result,
it can be inefficient and costly in terms of RAM to embed large child aggregations under a significant_terms
aggregation that later discards many candidate terms. It is advisable in these cases to perform two searches - the first to provide a rationalized list of
significant_terms and then add this shortlist of terms to a second query to go back and fetch the required child aggregations.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_approximate_counts"></a>Approximate counts<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>The counts of how many documents contain a term provided in results are based on summing the samples returned from each shard and
as such may be:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
low if certain shards did not provide figures for a given term in their top sample
</li>
<li class="listitem">
high when considering the background frequency as it may count occurrences found in deleted documents
</li>
</ul>
</div>
<p>Like most design decisions, this is the basis of a trade-off in which we have chosen to provide fast performance at the cost of some (typically small) inaccuracies.
However, the <code class="literal">size</code> and <code class="literal">shard size</code> settings covered in the next section provide tools to help control the accuracy levels.</p>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="significantterms-aggregation-parameters"></a>Parameters<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_jlh_score"></a>JLH score<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>The JLH score can be used as a significance score by adding the parameter</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">	 "jlh": {
	 }</pre>
</div>
<p>The scores are derived from the doc frequencies in <em>foreground</em> and <em>background</em> sets. The <em>absolute</em> change in popularity (foregroundPercent - backgroundPercent) would favor common terms whereas the <em>relative</em> change in popularity (foregroundPercent/ backgroundPercent) would favor rare terms. Rare vs common is essentially a precision vs recall balance and so the absolute and relative changes are multiplied to provide a sweet spot between precision and recall.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_mutual_information"></a>Mutual information<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>Mutual information as described in "Information Retrieval", Manning et al., Chapter 13.5.1 can be used as significance score by adding the parameter</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">	 "mutual_information": {
	      "include_negatives": true
	 }</pre>
</div>
<p>Mutual information does not differentiate between terms that are descriptive for the subset or for documents outside the subset. The significant terms therefore can contain terms that appear more or less frequent in the subset than outside the subset. To filter out the terms that appear less often in the subset than in documents outside the subset, <code class="literal">include_negatives</code> can be set to <code class="literal">false</code>.</p>
<p>Per default, the assumption is that the documents in the bucket are also contained in the background. If instead you defined a custom background filter that represents a different set of documents that you want to compare to, set</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">"background_is_superset": false</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_chi_square"></a>Chi square<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>Chi square as described in "Information Retrieval", Manning et al., Chapter 13.5.2 can be used as significance score by adding the parameter</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">	 "chi_square": {
	 }</pre>
</div>
<p>Chi square behaves like mutual information and can be configured with the same parameters <code class="literal">include_negatives</code> and <code class="literal">background_is_superset</code>.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_google_normalized_distance"></a>Google normalized distance<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>Google normalized distance  as described in "The Google Similarity Distance", Cilibrasi and Vitanyi, 2007 (<a href="https://arxiv.org/pdf/cs/0412098v3.pdf" class="ulink" target="_top">https://arxiv.org/pdf/cs/0412098v3.pdf</a>) can be used as significance score by adding the parameter</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">	 "gnd": {
	 }</pre>
</div>
<p><code class="literal">gnd</code> also accepts the <code class="literal">background_is_superset</code> parameter.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_percentage"></a>Percentage<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>A simple calculation of the number of documents in the foreground sample with a term divided by the number of documents in the background with the term.
By default this produces a score greater than zero and less than one.</p>
<p>The benefit of this heuristic is that the scoring logic is simple to explain to anyone familiar with a "per capita" statistic. However, for fields with high cardinality there is a tendency for this heuristic to select the rarest terms such as typos that occur only once because they score 1/1 = 100%.</p>
<p>It would be hard for a seasoned boxer to win a championship if the prize was awarded purely on the basis of percentage of fights won - by these rules a newcomer with only one fight under their belt would be impossible to beat.
Multiple observations are typically required to reinforce a view so it is recommended in these cases to set both <code class="literal">min_doc_count</code> and <code class="literal">shard_min_doc_count</code> to a higher value such as 10 in order to filter out the low-frequency terms that otherwise take precedence.</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">	 "percentage": {
	 }</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_which_one_is_best"></a>Which one is best?<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>Roughly, <code class="literal">mutual_information</code> prefers high frequent terms even if they occur also frequently in the background. For example, in an analysis of natural language text this might lead to selection of stop words. <code class="literal">mutual_information</code> is unlikely to select very rare terms like misspellings. <code class="literal">gnd</code> prefers terms with a high co-occurrence and avoids selection of stopwords. It might be better suited for synonym detection. However, <code class="literal">gnd</code> has a tendency to select very rare terms that are, for example, a result of misspelling. <code class="literal">chi_square</code> and <code class="literal">jlh</code> are somewhat in-between.</p>
<p>It is hard to say which one of the different heuristics will be the best choice as it depends on what the significant terms are used for (see for example [Yang and Pedersen, "A Comparative Study on Feature Selection in Text Categorization", 1997](<a href="http://courses.ischool.berkeley.edu/i256/f06/papers/yang97comparative.pdf" class="ulink" target="_top">http://courses.ischool.berkeley.edu/i256/f06/papers/yang97comparative.pdf</a>) for a study on using significant terms for feature selection for text classification).</p>
<p>If none of the above measures suits your usecase than another option is to implement a custom significance measure:</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_scripted"></a>Scripted<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>Customized scores can be implemented via a script:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">	    "script_heuristic": {
              "script": {
	        "lang": "painless",
	        "source": "params._subset_freq/(params._superset_freq - params._subset_freq + 1)"
	      }
            }</pre>
</div>
<p>Scripts can be inline (as in above example), indexed or stored on disk. For details on the options, see <a class="xref" href="modules-scripting.html" title="Scripting">script documentation</a>.</p>
<p>Available parameters in the script are</p>
<div class="informaltable">
<table border="0" cellpadding="4px">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody valign="top">
<tr>
<td valign="top">
<p>
<code class="literal">_subset_freq</code>
</p>
</td>
<td valign="top">
<p>
Number of documents the term appears in the subset.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">_superset_freq</code>
</p>
</td>
<td valign="top">
<p>
Number of documents the term appears in the superset.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">_subset_size</code>
</p>
</td>
<td valign="top">
<p>
Number of documents in the subset.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">_superset_size</code>
</p>
</td>
<td valign="top">
<p>
Number of documents in the superset.
</p>
</td>
</tr>
</tbody>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="sig-terms-shard-size"></a>Size &amp; Shard Size<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>The <code class="literal">size</code> parameter can be set to define how many term buckets should be returned out of the overall terms list. By
default, the node coordinating the search process will request each shard to provide its own top term buckets
and once all shards respond, it will reduce the results to the final list that will then be returned to the client.
If the number of unique terms is greater than <code class="literal">size</code>, the returned list can be slightly off and not accurate
(it could be that the term counts are slightly off and it could even be that a term that should have been in the top
size buckets was not returned).</p>
<p>To ensure better accuracy a multiple of the final <code class="literal">size</code> is used as the number of terms to request from each shard
(<code class="literal">2 * (size * 1.5 + 10)</code>). To take manual control of this setting the <code class="literal">shard_size</code> parameter
can be  used to control the volumes of candidate terms produced by each shard.</p>
<p>Low-frequency terms can turn out to be the most interesting ones once all results are combined so the
significant_terms aggregation can produce higher-quality results when the <code class="literal">shard_size</code> parameter is set to
values significantly higher than the <code class="literal">size</code> setting. This ensures that a bigger volume of promising candidate terms are given
a consolidated review by the reducing node before the final selection. Obviously large candidate term lists
will cause extra network traffic and RAM usage so this is  quality/cost trade off that needs to be balanced.  If <code class="literal">shard_size</code> is set to -1 (the default) then <code class="literal">shard_size</code> will be automatically estimated based on the number of shards and the <code class="literal">size</code> parameter.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p><code class="literal">shard_size</code> cannot be smaller than <code class="literal">size</code> (as it doesn&#8217;t make much sense). When it is, Elasticsearch will
        override it and reset it to be equal to <code class="literal">size</code>.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_minimum_document_count_2"></a>Minimum document count<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>It is possible to only return terms that match more than a configured number of hits using the <code class="literal">min_doc_count</code> option:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "tags": {
      "significant_terms": {
        "field": "tag",
        "min_doc_count": 10
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1062.console"></div>
<p>The above aggregation would only return tags which have been found in 10 hits or more. Default value is <code class="literal">3</code>.</p>
<p>Terms that score highly will be collected on a shard level and merged with the terms collected from other shards in a second step. However, the shard does not have the information about the global term frequencies available. The decision if a term is added to a candidate list depends only on the score computed on the shard using local shard frequencies, not the global frequencies of the word. The <code class="literal">min_doc_count</code> criterion is only applied after merging local terms statistics of all shards. In a way the decision to add the term as a candidate is made without being very <em>certain</em> about if the term will actually reach the required <code class="literal">min_doc_count</code>. This might cause many (globally) high frequent terms to be missing in the final result if low frequent but high scoring terms populated the candidate lists. To avoid this, the <code class="literal">shard_size</code> parameter can be increased to allow more candidate terms on the shards. However, this increases memory consumption and network traffic.</p>
<p><code class="literal">shard_min_doc_count</code> parameter</p>
<p>The parameter <code class="literal">shard_min_doc_count</code> regulates the <em>certainty</em> a shard has if the term should actually be added to the candidate list or not with respect to the <code class="literal">min_doc_count</code>. Terms will only be considered if their local shard frequency within the set is higher than the <code class="literal">shard_min_doc_count</code>. If your dictionary contains many low frequent words and you are not interested in these (for example misspellings), then you can set the <code class="literal">shard_min_doc_count</code> parameter to filter out candidate terms on a shard level that will with a reasonable certainty not reach the required <code class="literal">min_doc_count</code> even after merging the local frequencies. <code class="literal">shard_min_doc_count</code> is set to <code class="literal">1</code> per default and has no effect unless you explicitly set it.</p>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>Setting <code class="literal">min_doc_count</code> to <code class="literal">1</code> is generally not advised as it tends to return terms that
         are typos or other bizarre curiosities. Finding more than one instance of a term helps
         reinforce that, while still rare, the term was not the result of a one-off accident. The
         default value of 3 is used to provide a minimum weight-of-evidence.
         Setting <code class="literal">shard_min_doc_count</code> too high will cause significant candidate terms to be filtered out on a shard level. This value should be set much lower than <code class="literal">min_doc_count/#shards</code>.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_custom_background_context"></a>Custom background context<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>The default source of statistical information for background term frequencies is the entire index and this
scope can be narrowed through the use of a <code class="literal">background_filter</code> to focus in on significant terms within a narrower
context:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "query": {
    "match": {
      "city": "madrid"
    }
  },
  "aggs": {
    "tags": {
      "significant_terms": {
        "field": "tag",
        "background_filter": {
          "term": { "text": "spain" }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1063.console"></div>
<p>The above filter would help focus in on terms that were peculiar to the city of Madrid rather than revealing
terms like "Spanish" that are unusual in the full index&#8217;s worldwide context but commonplace in the subset of documents containing the
word "Spain".</p>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>Use of background filters will slow the query as each term&#8217;s postings must be filtered to determine a frequency</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_filtering_values_2"></a>Filtering Values<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>It is possible (although rarely required) to filter the values for which buckets will be created. This can be done using the <code class="literal">include</code> and
<code class="literal">exclude</code> parameters which are based on a regular expression string or arrays of exact terms. This functionality mirrors the features
described in the <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation" title="Terms aggregation">terms aggregation</a> documentation.</p>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_collect_mode"></a>Collect mode<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>To avoid memory issues, the <code class="literal">significant_terms</code> aggregation always computes child aggregations in <code class="literal">breadth_first</code> mode.
A description of the different collection modes can be found in the
<a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation-collect" title="Collect mode">terms aggregation</a> documentation.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_execution_hint_2"></a>Execution hint<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>There are different mechanisms by which terms aggregations can be executed:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
by using field values directly in order to aggregate data per-bucket (<code class="literal">map</code>)
</li>
<li class="listitem">
by using <a class="xref" href="mapping-params.html#eager-global-ordinals" title="eager_global_ordinals">global ordinals</a> of the field and allocating one bucket per global ordinal (<code class="literal">global_ordinals</code>)
</li>
</ul>
</div>
<p>Elasticsearch tries to have sensible defaults so this is something that generally doesn&#8217;t need to be configured.</p>
<p><code class="literal">global_ordinals</code> is the default option for <code class="literal">keyword</code> field, it uses global ordinals to allocates buckets dynamically
so memory usage is linear to the number of values of the documents that are part of the aggregation scope.</p>
<p><code class="literal">map</code> should only be considered when very few documents match a query. Otherwise the ordinals-based execution mode
is significantly faster. By default, <code class="literal">map</code> is only used when running an aggregation on scripts, since they don&#8217;t have
ordinals.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "tags": {
      "significant_terms": {
        "field": "tags",
        "execution_hint": "map" <a id="CO257-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1064.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO257-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>the possible values are <code class="literal">map</code>, <code class="literal">global_ordinals</code></p>
</td>
</tr>
</table>
</div>
<p>Please note that Elasticsearch will ignore this execution hint if it is not applicable.</p>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-significanttext-aggregation"></a>Significant text aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/significanttext-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>An aggregation that returns interesting or unusual occurrences of free-text terms in a set.
It is like the <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-significantterms-aggregation" title="Significant terms aggregation">significant terms</a> aggregation but differs in that:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
It is specifically designed for use on type <code class="literal">text</code> fields
</li>
<li class="listitem">
It does not require field data or doc-values
</li>
<li class="listitem">
It re-analyzes text content on-the-fly meaning it can also filter duplicate sections of
noisy text that otherwise tend to skew statistics.
</li>
</ul>
</div>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>Re-analyzing <em>large</em> result sets will require a lot of time and memory. It is recommended that the significant_text
         aggregation is used as a child of either the <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-sampler-aggregation" title="Sampler aggregation">sampler</a> or
         <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-diversified-sampler-aggregation" title="Diversified sampler aggregation">diversified sampler</a> aggregation to limit the analysis
         to a <em>small</em> selection of top-matching documents e.g. 200. This will typically improve speed, memory use and quality of
         results.</p>
</div>
</div>
<div class="ulist itemizedlist">
<p class="title"><strong>Example use cases:</strong></p>
<ul class="itemizedlist">
<li class="listitem">
Suggesting "H5N1" when users search for "bird flu" to help expand queries
</li>
<li class="listitem">
Suggesting keywords relating to stock symbol $ATI for use in an automated news classifier
</li>
</ul>
</div>
<p>In these cases the words being selected are not simply the most popular terms in results. The most popular words tend to be
very boring (<em>and, of, the, we, I, they</em> &#8230;&#8203;).
The significant words are the ones that have undergone a significant change in popularity measured between a <em>foreground</em> and <em>background</em> set.
If the term "H5N1" only exists in 5 documents in a 10 million document index and yet is found in 4 of the 100 documents that make up a user&#8217;s search results
that is significant and probably very relevant to their search. 5/10,000,000 vs 4/100 is a big swing in frequency.</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_basic_use"></a>Basic use<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/significanttext-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>In the typical use case, the <em>foreground</em> set of interest is a selection of the top-matching search results for a query
and the _background_set used for statistical comparisons is the index or indices from which the results were gathered.</p>
<p>Example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET news/_search
{
  "query": {
    "match": { "content": "Bird flu" }
  },
  "aggregations": {
    "my_sample": {
      "sampler": {
        "shard_size": 100
      },
      "aggregations": {
        "keywords": {
          "significant_text": { "field": "content" }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1065.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "took": 9,
  "timed_out": false,
  "_shards": ...,
  "hits": ...,
    "aggregations" : {
        "my_sample": {
            "doc_count": 100,
            "keywords" : {
                "doc_count": 100,
                "buckets" : [
                    {
                        "key": "h5n1",
                        "doc_count": 4,
                        "score": 4.71235374214817,
                        "bg_count": 5
                    }
                    ...
                ]
            }
        }
    }
}</pre>
</div>
<p>The results show that "h5n1" is one of several terms strongly associated with bird flu.
It only occurs 5 times in our index as a whole (see the <code class="literal">bg_count</code>) and yet 4 of these
were lucky enough to appear in our 100 document sample of "bird flu" results. That suggests
a significant word and one which the user can potentially add to their search.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="filter-duplicate-text-noisy-data"></a>Dealing with noisy data using <code class="literal">filter_duplicate_text</code><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/significanttext-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Free-text fields often contain a mix of original content and mechanical copies of text (cut-and-paste biographies, email reply chains,
retweets, boilerplate headers/footers, page navigation menus, sidebar news links, copyright notices, standard disclaimers, addresses).</p>
<p>In real-world data these duplicate sections of text tend to feature heavily in <code class="literal">significant_text</code> results if they aren&#8217;t filtered out.
Filtering near-duplicate text is a difficult task at index-time but we can cleanse the data on-the-fly at query time using the
<code class="literal">filter_duplicate_text</code> setting.</p>
<p>First let&#8217;s look at an unfiltered real-world example using the <a href="https://research.signalmedia.co/newsir16/signal-dataset.html" class="ulink" target="_top">Signal media dataset</a> of
a million news articles covering a wide variety of news. Here are the raw significant text results for a search for the articles
mentioning "elasticsearch":</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  ...
  "aggregations": {
    "sample": {
      "doc_count": 35,
      "keywords": {
        "doc_count": 35,
        "buckets": [
          {
            "key": "elasticsearch",
            "doc_count": 35,
            "score": 28570.428571428572,
            "bg_count": 35
          },
          ...
          {
            "key": "currensee",
            "doc_count": 8,
            "score": 6530.383673469388,
            "bg_count": 8
          },
          ...
          {
            "key": "pozmantier",
            "doc_count": 4,
            "score": 3265.191836734694,
            "bg_count": 4
          },
          ...

}</pre>
</div>
<p>The uncleansed documents have thrown up some odd-looking terms that are, on the face of it, statistically
correlated with appearances of our search term "elasticsearch" e.g. "pozmantier".
We can drill down into examples of these documents to see why pozmantier is connected using this query:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET news/_search
{
  "query": {
    "simple_query_string": {
      "query": "+elasticsearch  +pozmantier"
    }
  },
  "_source": [
    "title",
    "source"
  ],
  "highlight": {
    "fields": {
      "content": {}
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1066.console"></div>
<p>The results show a series of very similar news articles about a judging panel for a number of tech projects:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  ...
  "hits": {
    "hits": [
      {
        ...
        "_source": {
          "source": "Presentation Master",
          "title": "T.E.N. Announces Nominees for the 2015 ISE® North America Awards"
        },
        "highlight": {
          "content": [
            "City of San Diego Mike &lt;em&gt;Pozmantier&lt;/em&gt;, Program Manager, Cyber Security Division, Department of",
            " Janus, Janus &lt;em&gt;ElasticSearch&lt;/em&gt; Security Visualization Engine "
          ]
        }
      },
      {
        ...
        "_source": {
          "source": "RCL Advisors",
          "title": "T.E.N. Announces Nominees for the 2015 ISE(R) North America Awards"
        },
        "highlight": {
          "content": [
            "Mike &lt;em&gt;Pozmantier&lt;/em&gt;, Program Manager, Cyber Security Division, Department of Homeland Security S&amp;T",
            "Janus, Janus &lt;em&gt;ElasticSearch&lt;/em&gt; Security Visualization Engine"
          ]
        }
      },
      ...</pre>
</div>
<p>Mike Pozmantier was one of many judges on a panel and elasticsearch was used in one of many projects being judged.</p>
<p>As is typical, this lengthy press release was cut-and-paste by a variety of news sites and consequently any rare names, numbers or
typos they contain become statistically correlated with our matching query.</p>
<p>Fortunately similar documents tend to rank similarly so as part of examining the stream of top-matching documents the significant_text
aggregation can apply a filter to remove sequences of any 6 or more tokens that have already been seen. Let&#8217;s try this same query now but
with the <code class="literal">filter_duplicate_text</code> setting turned on:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET news/_search
{
  "query": {
    "match": {
      "content": "elasticsearch"
    }
  },
  "aggs": {
    "sample": {
      "sampler": {
        "shard_size": 100
      },
      "aggs": {
        "keywords": {
          "significant_text": {
            "field": "content",
            "filter_duplicate_text": true
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1067.console"></div>
<p>The results from analysing our deduplicated text are obviously of higher quality to anyone familiar with the elastic stack:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  ...
  "aggregations": {
    "sample": {
      "doc_count": 35,
      "keywords": {
        "doc_count": 35,
        "buckets": [
          {
            "key": "elasticsearch",
            "doc_count": 22,
            "score": 11288.001166180758,
            "bg_count": 35
          },
          {
            "key": "logstash",
            "doc_count": 3,
            "score": 1836.648979591837,
            "bg_count": 4
          },
          {
            "key": "kibana",
            "doc_count": 3,
            "score": 1469.3020408163263,
            "bg_count": 5
          }
        ]
      }
    }
  }
}</pre>
</div>
<p>Mr Pozmantier and other one-off associations with elasticsearch no longer appear in the aggregation
results as a consequence of copy-and-paste operations or other forms of mechanical repetition.</p>
<p>If your duplicate or near-duplicate content is identifiable via a single-value indexed field  (perhaps
a hash of the article&#8217;s <code class="literal">title</code> text or an <code class="literal">original_press_release_url</code> field) then it would be more
efficient to use a parent <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-diversified-sampler-aggregation" title="Diversified sampler aggregation">diversified sampler</a> aggregation
to eliminate these documents from the sample set based on that single key. The less duplicate content you can feed into
the significant_text aggregation up front the better in terms of performance.</p>
<div class="sidebar">
<div class="titlepage"><div><div>
<p class="title"><strong>How are the significance scores calculated?</strong></p>
</div></div></div>
<p>The numbers returned for scores are primarily intended for ranking different suggestions sensibly rather than something easily
understood by end users. The scores are derived from the doc frequencies in <em>foreground</em> and <em>background</em> sets. In brief, a
term is considered significant if there is a noticeable difference in the frequency in which a term appears in the subset and
in the background. The way the terms are ranked can be configured, see "Parameters" section.</p>
</div>
<div class="sidebar">
<div class="titlepage"><div><div>
<p class="title"><strong>Use the <em>"like this but not this"</em> pattern</strong></p>
</div></div></div>
<p>You can spot mis-categorized content by first searching a structured field e.g. <code class="literal">category:adultMovie</code> and use significant_text on the
text "movie_description" field. Take the suggested words (I&#8217;ll leave them to your imagination) and then search for all movies NOT marked as category:adultMovie but containing these keywords.
You now have a ranked list of badly-categorized movies that you should reclassify or at least remove from the "familyFriendly" category.</p>
<p>The significance score from each term can also provide a useful <code class="literal">boost</code> setting to sort matches.
Using the <code class="literal">minimum_should_match</code> setting of the <code class="literal">terms</code> query with the keywords will help control the balance of precision/recall in the result set i.e
a high setting would have a small number of relevant results packed full of keywords and a setting of "1" would produce a more exhaustive results set with all documents containing <em>any</em> keyword.</p>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_limitations_8"></a>Limitations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/significanttext-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_no_support_for_child_aggregations"></a>No support for child aggregations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/significanttext-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>The significant_text aggregation intentionally does not support the addition of child aggregations because:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
It would come with a high memory cost
</li>
<li class="listitem">
It isn&#8217;t a generally useful feature and there is a workaround for those that need it
</li>
</ul>
</div>
<p>The volume of candidate terms is generally very high and these are pruned heavily before the final
results are returned. Supporting child aggregations would generate additional churn and be inefficient.
Clients can always take the heavily-trimmed set of results from a <code class="literal">significant_text</code> request and
make a subsequent follow-up query using a <code class="literal">terms</code> aggregation with an <code class="literal">include</code> clause and child
aggregations to perform further analysis of selected keywords in a more efficient fashion.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_no_support_for_nested_objects"></a>No support for nested objects<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/significanttext-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>The significant_text aggregation currently also cannot be used with text fields in
nested objects, because it works with the document JSON source. This makes this
feature inefficient when matching nested docs from stored JSON given a matching
Lucene docID.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_approximate_counts_2"></a>Approximate counts<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/significanttext-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>The counts of how many documents contain a term provided in results are based on summing the samples returned from each shard and
as such may be:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
low if certain shards did not provide figures for a given term in their top sample
</li>
<li class="listitem">
high when considering the background frequency as it may count occurrences found in deleted documents
</li>
</ul>
</div>
<p>Like most design decisions, this is the basis of a trade-off in which we have chosen to provide fast performance at the cost of some (typically small) inaccuracies.
However, the <code class="literal">size</code> and <code class="literal">shard size</code> settings covered in the next section provide tools to help control the accuracy levels.</p>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="significanttext-aggregation-parameters"></a>Parameters<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/significanttext-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_significance_heuristics"></a>Significance heuristics<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/significanttext-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>This aggregation supports the same scoring heuristics (JLH, mutual_information, gnd, chi_square etc) as the <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-significantterms-aggregation" title="Significant terms aggregation">significant terms</a> aggregation</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="sig-text-shard-size"></a>Size &amp; Shard Size<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/significanttext-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>The <code class="literal">size</code> parameter can be set to define how many term buckets should be returned out of the overall terms list. By
default, the node coordinating the search process will request each shard to provide its own top term buckets
and once all shards respond, it will reduce the results to the final list that will then be returned to the client.
If the number of unique terms is greater than <code class="literal">size</code>, the returned list can be slightly off and not accurate
(it could be that the term counts are slightly off and it could even be that a term that should have been in the top
size buckets was not returned).</p>
<p>To ensure better accuracy a multiple of the final <code class="literal">size</code> is used as the number of terms to request from each shard
(<code class="literal">2 * (size * 1.5 + 10)</code>). To take manual control of this setting the <code class="literal">shard_size</code> parameter
can be  used to control the volumes of candidate terms produced by each shard.</p>
<p>Low-frequency terms can turn out to be the most interesting ones once all results are combined so the
significant_terms aggregation can produce higher-quality results when the <code class="literal">shard_size</code> parameter is set to
values significantly higher than the <code class="literal">size</code> setting. This ensures that a bigger volume of promising candidate terms are given
a consolidated review by the reducing node before the final selection. Obviously large candidate term lists
will cause extra network traffic and RAM usage so this is  quality/cost trade off that needs to be balanced.  If <code class="literal">shard_size</code> is set to -1 (the default) then <code class="literal">shard_size</code> will be automatically estimated based on the number of shards and the <code class="literal">size</code> parameter.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p><code class="literal">shard_size</code> cannot be smaller than <code class="literal">size</code> (as it doesn&#8217;t make much sense). When it is, elasticsearch will
        override it and reset it to be equal to <code class="literal">size</code>.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_minimum_document_count_3"></a>Minimum document count<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/significanttext-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>It is possible to only return terms that match more than a configured number of hits using the <code class="literal">min_doc_count</code> option.
The Default value is 3.</p>
<p>Terms that score highly will be collected on a shard level and merged with the terms collected from other shards in a second step.
However, the shard does not have the information about the global term frequencies available. The decision if a term is added to a
candidate list depends only on the score computed on the shard using local shard frequencies, not the global frequencies of the word.
The <code class="literal">min_doc_count</code> criterion is only applied after merging local terms statistics of all shards. In a way the decision to add the
term as a candidate is made without being very <em>certain</em> about if the term will actually reach the required <code class="literal">min_doc_count</code>.
This might cause many (globally) high frequent terms to be missing in the final result if low frequent but high scoring terms populated
the candidate lists. To avoid this, the <code class="literal">shard_size</code> parameter can be increased to allow more candidate terms on the shards.
However, this increases memory consumption and network traffic.</p>
<p><code class="literal">shard_min_doc_count</code> parameter</p>
<p>The parameter <code class="literal">shard_min_doc_count</code> regulates the <em>certainty</em> a shard has if the term should actually be added to the candidate list or
not with respect to the <code class="literal">min_doc_count</code>. Terms will only be considered if their local shard frequency within the set is higher than the
<code class="literal">shard_min_doc_count</code>. If your dictionary contains many low frequent words and you are not interested in these (for example misspellings),
then you can set the <code class="literal">shard_min_doc_count</code> parameter to filter out candidate terms on a shard level that will with a reasonable certainty
not reach the required <code class="literal">min_doc_count</code> even after merging the local frequencies. <code class="literal">shard_min_doc_count</code> is set to <code class="literal">1</code> per default and has
no effect unless you explicitly set it.</p>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>Setting <code class="literal">min_doc_count</code> to <code class="literal">1</code> is generally not advised as it tends to return terms that
         are typos or other bizarre curiosities. Finding more than one instance of a term helps
         reinforce that, while still rare, the term was not the result of a one-off accident. The
         default value of 3 is used to provide a minimum weight-of-evidence.
         Setting <code class="literal">shard_min_doc_count</code> too high will cause significant candidate terms to be filtered out on a shard level.
         This value should be set much lower than <code class="literal">min_doc_count/#shards</code>.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_custom_background_context_2"></a>Custom background context<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/significanttext-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>The default source of statistical information for background term frequencies is the entire index and this
scope can be narrowed through the use of a <code class="literal">background_filter</code> to focus in on significant terms within a narrower
context:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET news/_search
{
  "query": {
    "match": {
      "content": "madrid"
    }
  },
  "aggs": {
    "tags": {
      "significant_text": {
        "field": "content",
        "background_filter": {
          "term": { "content": "spain" }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1068.console"></div>
<p>The above filter would help focus in on terms that were peculiar to the city of Madrid rather than revealing
terms like "Spanish" that are unusual in the full index&#8217;s worldwide context but commonplace in the subset of documents containing the
word "Spain".</p>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>Use of background filters will slow the query as each term&#8217;s postings must be filtered to determine a frequency</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_dealing_with_source_and_index_mappings"></a>Dealing with source and index mappings<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/significanttext-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>Ordinarily the indexed field name and the original JSON field being retrieved share the same name.
However with more complex field mappings using features like <code class="literal">copy_to</code> the source
JSON field(s) and the indexed field being aggregated can differ.
In these cases it is possible to list the JSON _source fields from which text
will be analyzed using the <code class="literal">source_fields</code> parameter:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET news/_search
{
  "query": {
    "match": {
      "custom_all": "elasticsearch"
    }
  },
  "aggs": {
    "tags": {
      "significant_text": {
        "field": "custom_all",
        "source_fields": [ "content", "title" ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1069.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_filtering_values_3"></a>Filtering Values<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/significanttext-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>It is possible (although rarely required) to filter the values for which buckets will be created. This can be done using the <code class="literal">include</code> and
<code class="literal">exclude</code> parameters which are based on a regular expression string or arrays of exact terms. This functionality mirrors the features
described in the <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation" title="Terms aggregation">terms aggregation</a> documentation.</p>
</div>

</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-terms-aggregation"></a>Terms aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A multi-bucket value source based aggregation where buckets are dynamically built - one per unique value.</p>
<p>Example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "genres": {
      "terms": { "field": "genre" } <a id="CO258-1"></a><i class="conum" data-value="1"></i>
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1070.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO258-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p><code class="literal">terms</code> aggregation should be a field of type <code class="literal">keyword</code> or any other data type suitable for bucket aggregations. In order to use it with <code class="literal">text</code> you will need to enable
<a class="xref" href="getting-started-modify-data.html#fielddata" title="fielddata mapping parameter">fielddata</a>.</p>
</td>
</tr>
</table>
</div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "genres": {
      "doc_count_error_upper_bound": 0,   <a id="CO259-1"></a><i class="conum" data-value="1"></i>
      "sum_other_doc_count": 0,           <a id="CO259-2"></a><i class="conum" data-value="2"></i>
      "buckets": [                        <a id="CO259-3"></a><i class="conum" data-value="3"></i>
        {
          "key": "electronic",
          "doc_count": 6
        },
        {
          "key": "rock",
          "doc_count": 3
        },
        {
          "key": "jazz",
          "doc_count": 2
        }
      ]
    }
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO259-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>an upper bound of the error on the document counts for each term, see <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation-approximate-counts" title="Document counts are approximate">below</a></p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO259-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>when there are lots of unique terms, Elasticsearch only returns the top terms; this number is the sum of the document counts for all buckets that are not part of the response</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO259-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>the list of the top buckets, the meaning of <code class="literal">top</code> being defined by the <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation-order" title="Order">order</a></p>
</td>
</tr>
</table>
</div>
<p>By default, the <code class="literal">terms</code> aggregation will return the buckets for the top ten terms ordered by the <code class="literal">doc_count</code>. One can
change this default behaviour by setting the <code class="literal">size</code> parameter.</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-bucket-terms-aggregation-size"></a>Size<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">size</code> parameter can be set to define how many term buckets should be returned out of the overall terms list. By
default, the node coordinating the search process will request each shard to provide its own top <code class="literal">size</code> term buckets
and once all shards respond, it will reduce the results to the final list that will then be returned to the client.
This means that if the number of unique terms is greater than <code class="literal">size</code>, the returned list is slightly off and not accurate
(it could be that the term counts are slightly off and it could even be that a term that should have been in the top
size buckets was not returned).</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>If you want to retrieve <span class="strong strong"><strong>all</strong></span> terms or all combinations of terms in a nested <code class="literal">terms</code> aggregation
      you should use the <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-composite-aggregation" title="Composite aggregation">Composite</a> aggregation which
      allows to paginate over all possible terms rather than setting a size greater than the cardinality of the field in the
      <code class="literal">terms</code> aggregation. The <code class="literal">terms</code> aggregation is meant to return the <code class="literal">top</code> terms and does not allow pagination.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-bucket-terms-aggregation-approximate-counts"></a>Document counts are approximate<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Document counts (and the results of any sub aggregations) in the terms
aggregation are not always accurate. Each shard provides its own view of what
the ordered list of terms should be. These views are combined to give a final
view.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_shard_size_3"></a>Shard Size<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The higher the requested <code class="literal">size</code> is, the more accurate the results will be, but also, the more expensive it will be to
compute the final results (both due to bigger priority queues that are managed on a shard level and due to bigger data
transfers between the nodes and the client).</p>
<p>The <code class="literal">shard_size</code> parameter can be  used to minimize the extra work that comes with bigger requested <code class="literal">size</code>. When defined,
it will determine how many terms the coordinating node will request from each shard. Once all the shards responded, the
coordinating node will then reduce them to a final result which will be based on the <code class="literal">size</code> parameter - this way,
one can increase the accuracy of the returned terms and avoid the overhead of streaming a big list of buckets back to
the client.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p><code class="literal">shard_size</code> cannot be smaller than <code class="literal">size</code> (as it doesn&#8217;t make much sense). When it is, Elasticsearch will
        override it and reset it to be equal to <code class="literal">size</code>.</p>
</div>
</div>
<p>The default <code class="literal">shard_size</code> is <code class="literal">(size * 1.5 + 10)</code>.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_calculating_document_count_error"></a>Calculating Document Count Error<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>There are two error values which can be shown on the terms aggregation. The first gives a value for the aggregation as
a whole which represents the maximum potential document count for a term which did not make it into the final list of
terms. This is calculated as the sum of the document count from the last term returned from each shard.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_per_bucket_document_count_error"></a>Per bucket document count error<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The second error value can be enabled by setting the <code class="literal">show_term_doc_count_error</code> parameter to true:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "products": {
      "terms": {
        "field": "product",
        "size": 5,
        "show_term_doc_count_error": true
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1071.console"></div>
<p>This shows an error value for each term returned by the aggregation which represents the <em>worst case</em> error in the document count
and can be useful when deciding on a value for the <code class="literal">shard_size</code> parameter. This is calculated by summing the document counts for
the last term returned by all shards which did not return the term.</p>
<p>These errors can only be calculated in this way when the terms are ordered by descending document count. When the aggregation is
ordered by the terms values themselves (either ascending or descending) there is no error in the document count since if a shard
does not return a particular term which appears in the results from another shard, it must not have that term in its index. When the
aggregation is either sorted by a sub aggregation or in order of ascending document count, the error in the document counts cannot be
determined and is given a value of -1 to indicate this.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-bucket-terms-aggregation-order"></a>Order<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The order of the buckets can be customized by setting the <code class="literal">order</code> parameter. By default, the buckets are ordered by
their <code class="literal">doc_count</code> descending.  It is possible to change this behaviour as documented below:</p>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>Sorting by ascending <code class="literal">_count</code> or by sub aggregation is discouraged as it increases the
<a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation-approximate-counts" title="Document counts are approximate">error</a> on document counts.
It is fine when a single shard is queried, or when the field that is being aggregated was used
as a routing key at index time: in these cases results will be accurate since shards have disjoint
values. However otherwise, errors are unbounded. One particular case that could still be useful
is sorting by <a class="xref" href="search-aggregations-metrics.html#search-aggregations-metrics-min-aggregation" title="Min aggregation"><code class="literal">min</code></a> or
<a class="xref" href="search-aggregations-metrics.html#search-aggregations-metrics-max-aggregation" title="Max aggregation"><code class="literal">max</code></a> aggregation: counts will not be accurate
but at least the top buckets will be correctly picked.</p>
</div>
</div>
<p>Ordering the buckets by their doc <code class="literal">_count</code> in an ascending manner:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "genres": {
      "terms": {
        "field": "genre",
        "order": { "_count": "asc" }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1072.console"></div>
<p>Ordering the buckets alphabetically by their terms in an ascending manner:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "genres": {
      "terms": {
        "field": "genre",
        "order": { "_key": "asc" }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1073.console"></div>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<h3>Deprecated in 6.0.0.</h3>
<p>Use <code class="literal">_key</code> instead of <code class="literal">_term</code> to order buckets by their term</p>
</div>
</div>
<p>Ordering the buckets by single value metrics sub-aggregation (identified by the aggregation name):</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "genres": {
      "terms": {
        "field": "genre",
        "order": { "max_play_count": "desc" }
      },
      "aggs": {
        "max_play_count": { "max": { "field": "play_count" } }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1074.console"></div>
<p>Ordering the buckets by multi value metrics sub-aggregation (identified by the aggregation name):</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "genres": {
      "terms": {
        "field": "genre",
        "order": { "playback_stats.max": "desc" }
      },
      "aggs": {
        "playback_stats": { "stats": { "field": "play_count" } }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1075.console"></div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<h3>Pipeline aggs cannot be used for sorting</h3>
<p><a class="xref" href="search-aggregations-pipeline.html" title="Pipeline aggregations">Pipeline aggregations</a> are run during the
reduce phase after all other aggregations have already completed.  For this
reason, they cannot be used for ordering.</p>
</div>
</div>
<p>It is also possible to order the buckets based on a "deeper" aggregation in the hierarchy. This is supported as long
as the aggregations path are of a single-bucket type, where the last aggregation in the path may either be a single-bucket
one or a metrics one. If it&#8217;s a single-bucket type, the order will be defined by the number of docs in the bucket (i.e. <code class="literal">doc_count</code>),
in case it&#8217;s a metrics one, the same rules as above apply (where the path must indicate the metric name to sort by in case of
a multi-value metrics aggregation, and in case of a single-value metrics aggregation the sort will be applied on that value).</p>
<p>The path must be defined in the following form:</p>
<div class="pre_wrapper lang-ebnf">
<pre class="programlisting prettyprint lang-ebnf">AGG_SEPARATOR       =  '&gt;' ;
METRIC_SEPARATOR    =  '.' ;
AGG_NAME            =  &lt;the name of the aggregation&gt; ;
METRIC              =  &lt;the name of the metric (in case of multi-value metrics aggregation)&gt; ;
PATH                =  &lt;AGG_NAME&gt; [ &lt;AGG_SEPARATOR&gt;, &lt;AGG_NAME&gt; ]* [ &lt;METRIC_SEPARATOR&gt;, &lt;METRIC&gt; ] ;</pre>
</div>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "countries": {
      "terms": {
        "field": "artist.country",
        "order": { "rock&gt;playback_stats.avg": "desc" }
      },
      "aggs": {
        "rock": {
          "filter": { "term": { "genre": "rock" } },
          "aggs": {
            "playback_stats": { "stats": { "field": "play_count" } }
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1076.console"></div>
<p>The above will sort the artist&#8217;s countries buckets based on the average play count among the rock songs.</p>
<p>Multiple criteria can be used to order the buckets by providing an array of order criteria such as the following:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "countries": {
      "terms": {
        "field": "artist.country",
        "order": [ { "rock&gt;playback_stats.avg": "desc" }, { "_count": "desc" } ]
      },
      "aggs": {
        "rock": {
          "filter": { "term": { "genre": "rock" } },
          "aggs": {
            "playback_stats": { "stats": { "field": "play_count" } }
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1077.console"></div>
<p>The above will sort the artist&#8217;s countries buckets based on the average play count among the rock songs and then by
their <code class="literal">doc_count</code> in descending order.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>In the event that two buckets share the same values for all order criteria the bucket&#8217;s term value is used as a
tie-breaker in ascending alphabetical order to prevent non-deterministic ordering of buckets.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_minimum_document_count_4"></a>Minimum document count<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>It is possible to only return terms that match more than a configured number of hits using the <code class="literal">min_doc_count</code> option:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "tags": {
      "terms": {
        "field": "tags",
        "min_doc_count": 10
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1078.console"></div>
<p>The above aggregation would only return tags which have been found in 10 hits or more. Default value is <code class="literal">1</code>.</p>
<p>Terms are collected and ordered on a shard level and merged with the terms collected from other shards in a second step. However, the shard does not have the information about the global document count available. The decision if a term is added to a candidate list depends only on the order computed on the shard using local shard frequencies. The <code class="literal">min_doc_count</code> criterion is only applied after merging local terms statistics of all shards. In a way the decision to add the term as a candidate is made without being very <em>certain</em> about if the term will actually reach the required <code class="literal">min_doc_count</code>. This might cause many (globally) high frequent terms to be missing in the final result if low frequent terms populated the candidate lists. To avoid this, the <code class="literal">shard_size</code> parameter can be increased to allow more candidate terms on the shards. However, this increases memory consumption and network traffic.</p>
<p><code class="literal">shard_min_doc_count</code> parameter</p>
<p>The parameter <code class="literal">shard_min_doc_count</code> regulates the <em>certainty</em> a shard has if the term should actually be added to the candidate list or not with respect to the <code class="literal">min_doc_count</code>. Terms will only be considered if their local shard frequency within the set is higher than the <code class="literal">shard_min_doc_count</code>. If your dictionary contains many low frequent terms and you are not interested in those (for example misspellings), then you can set the <code class="literal">shard_min_doc_count</code> parameter to filter out candidate terms on a shard level that will with a reasonable certainty not reach the required <code class="literal">min_doc_count</code> even after merging the local counts. <code class="literal">shard_min_doc_count</code> is set to <code class="literal">0</code> per default and has no effect unless you explicitly set it.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>Setting <code class="literal">min_doc_count</code>=<code class="literal">0</code> will also return buckets for terms that didn&#8217;t match any hit. However, some of
         the returned terms which have a document count of zero might only belong to deleted documents or documents
         from other types, so there is no warranty that a <code class="literal">match_all</code> query would find a positive document count for
         those terms.</p>
</div>
</div>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>When NOT sorting on <code class="literal">doc_count</code> descending, high values of <code class="literal">min_doc_count</code> may return a number of buckets
         which is less than <code class="literal">size</code> because not enough data was gathered from the shards. Missing buckets can be
         back by increasing <code class="literal">shard_size</code>.
         Setting <code class="literal">shard_min_doc_count</code> too high will cause terms to be filtered out on a shard level. This value should be set much lower than <code class="literal">min_doc_count/#shards</code>.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-bucket-terms-aggregation-script"></a>Script<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Generating the terms using a script:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "genres": {
      "terms": {
        "script": {
          "source": "doc['genre'].value",
          "lang": "painless"
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1079.console"></div>
<p>This will interpret the <code class="literal">script</code> parameter as an <code class="literal">inline</code> script with the default script language and no script parameters. To use a stored script use the following syntax:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "genres": {
      "terms": {
        "script": {
          "id": "my_script",
          "params": {
            "field": "genre"
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1080.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_value_script_2"></a>Value Script<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "genres": {
      "terms": {
        "field": "genre",
        "script": {
          "source": "'Genre: ' +_value",
          "lang": "painless"
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1081.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_filtering_values_4"></a>Filtering Values<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>It is possible to filter the values for which buckets will be created. This can be done using the <code class="literal">include</code> and
<code class="literal">exclude</code> parameters which are based on regular expression strings or arrays of exact values. Additionally,
<code class="literal">include</code> clauses can filter using <code class="literal">partition</code> expressions.</p>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_filtering_values_with_regular_expressions_2"></a>Filtering Values with regular expressions<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "tags": {
      "terms": {
        "field": "tags",
        "include": ".*sport.*",
        "exclude": "water_.*"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1082.console"></div>
<p>In the above example, buckets will be created for all the tags that has the word <code class="literal">sport</code> in them, except those starting
with <code class="literal">water_</code> (so the tag <code class="literal">water_sports</code> will not be aggregated). The <code class="literal">include</code> regular expression will determine what
values are "allowed" to be aggregated, while the <code class="literal">exclude</code> determines the values that should not be aggregated. When
both are defined, the <code class="literal">exclude</code> has precedence, meaning, the <code class="literal">include</code> is evaluated first and only then the <code class="literal">exclude</code>.</p>
<p>The syntax is the same as <a class="xref" href="regexp-syntax.html" title="Regular expression syntax">regexp queries</a>.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_filtering_values_with_exact_values_2"></a>Filtering Values with exact values<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>For matching based on exact values the <code class="literal">include</code> and <code class="literal">exclude</code> parameters can simply take an array of
strings that represent the terms as they are found in the index:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "JapaneseCars": {
      "terms": {
        "field": "make",
        "include": [ "mazda", "honda" ]
      }
    },
    "ActiveCarManufacturers": {
      "terms": {
        "field": "make",
        "exclude": [ "rover", "jensen" ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1083.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_filtering_values_with_partitions"></a>Filtering Values with partitions<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>Sometimes there are too many unique terms to process in a single request/response pair so
it can be useful to break the analysis up into multiple requests.
This can be achieved by grouping the field&#8217;s values into a number of partitions at query-time and processing
only one partition in each request.
Consider this request which is looking for accounts that have not logged any access recently:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
   "size": 0,
   "aggs": {
      "expired_sessions": {
         "terms": {
            "field": "account_id",
            "include": {
               "partition": 0,
               "num_partitions": 20
            },
            "size": 10000,
            "order": {
               "last_access": "asc"
            }
         },
         "aggs": {
            "last_access": {
               "max": {
                  "field": "access_date"
               }
            }
         }
      }
   }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1084.console"></div>
<p>This request is finding the last logged access date for a subset of customer accounts because we
might want to expire some customer accounts who haven&#8217;t been seen for a long while.
The <code class="literal">num_partitions</code> setting has requested that the unique account_ids are organized evenly into twenty
partitions (0 to 19). and the <code class="literal">partition</code> setting in this request filters to only consider account_ids falling
into partition 0. Subsequent requests should ask for partitions 1 then 2 etc to complete the expired-account analysis.</p>
<p>Note that the <code class="literal">size</code> setting for the number of results returned needs to be tuned with the <code class="literal">num_partitions</code>.
For this particular account-expiration example the process for balancing values for <code class="literal">size</code> and <code class="literal">num_partitions</code> would be as follows:</p>
<div class="olist orderedlist">
<ol class="orderedlist">
<li class="listitem">
Use the <code class="literal">cardinality</code> aggregation to estimate the total number of unique account_id values
</li>
<li class="listitem">
Pick a value for <code class="literal">num_partitions</code> to break the number from 1) up into more manageable chunks
</li>
<li class="listitem">
Pick a <code class="literal">size</code> value for the number of responses we want from each partition
</li>
<li class="listitem">
Run a test request
</li>
</ol>
</div>
<p>If we have a circuit-breaker error we are trying to do too much in one request and must increase <code class="literal">num_partitions</code>.
If the request was successful but the last account ID in the date-sorted test response was still an account we might want to
expire then we may be missing accounts of interest and have set our numbers too low. We must either</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
increase the <code class="literal">size</code> parameter to return more results per partition (could be heavy on memory) or
</li>
<li class="listitem">
increase the <code class="literal">num_partitions</code> to consider less accounts per request (could increase overall processing time as we need to make more requests)
</li>
</ul>
</div>
<p>Ultimately this is a balancing act between managing the Elasticsearch resources required to process a single request and the volume
of requests that the client application must issue to complete a task.</p>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_multi_field_terms_aggregation"></a>Multi-field terms aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">terms</code> aggregation does not support collecting terms from multiple fields
in the same document.  The reason is that the <code class="literal">terms</code> agg doesn&#8217;t collect the
string term values themselves, but rather uses
<a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation-execution-hint" title="Execution hint">global ordinals</a>
to produce a list of all of the unique values in the field.  Global ordinals
results in an important performance boost which would not be possible across
multiple fields.</p>
<p>There are two approaches that you can use to perform a <code class="literal">terms</code> agg across
multiple fields:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation-script" title="Script">Script</a>
</span>
</dt>
<dd>
Use a script to retrieve terms from multiple fields.  This disables the global
ordinals optimization and will be slower than collecting terms from a single
field, but it gives you the flexibility to implement this option at search
time.
</dd>
<dt>
<span class="term">
<a class="xref" href="mapping-params.html#copy-to" title="copy_to"><code class="literal">copy_to</code> field</a>
</span>
</dt>
<dd>
If you know ahead of time that you want to collect the terms from two or more
fields, then use <code class="literal">copy_to</code> in your mapping to create a new dedicated field at
index time which contains the values from both fields.  You can aggregate on
this single field, which will benefit from the global ordinals optimization.
</dd>
</dl>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-bucket-terms-aggregation-collect"></a>Collect mode<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Deferring calculation of child aggregations</p>
<p>For fields with many unique terms and a small number of required results it can be more efficient to delay the calculation
of child aggregations until the top parent-level aggs have been pruned. Ordinarily, all branches of the aggregation tree
are expanded in one depth-first pass and only then any pruning occurs.
In some scenarios this can be very wasteful and can hit memory constraints.
An example problem scenario is querying a movie database for the 10 most popular actors and their 5 most common co-stars:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "actors": {
      "terms": {
        "field": "actors",
        "size": 10
      },
      "aggs": {
        "costars": {
          "terms": {
            "field": "actors",
            "size": 5
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1085.console"></div>
<p>Even though the number of actors may be comparatively small and we want only 50 result buckets there is a combinatorial explosion of buckets
during calculation - a single actor can produce n² buckets where n is the number of actors. The sane option would be to first determine
the 10 most popular actors and only then examine the top co-stars for these 10 actors. This alternative strategy is what we call the <code class="literal">breadth_first</code> collection
mode as opposed to the <code class="literal">depth_first</code> mode.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>The <code class="literal">breadth_first</code> is the default mode for fields with a cardinality bigger than the requested size or when the cardinality is unknown (numeric fields or scripts for instance).
It is possible to override the default heuristic and to provide a collect mode directly in the request:</p>
</div>
</div>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "actors": {
      "terms": {
        "field": "actors",
        "size": 10,
        "collect_mode": "breadth_first" <a id="CO260-1"></a><i class="conum" data-value="1"></i>
      },
      "aggs": {
        "costars": {
          "terms": {
            "field": "actors",
            "size": 5
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1086.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO260-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>the possible values are <code class="literal">breadth_first</code> and <code class="literal">depth_first</code></p>
</td>
</tr>
</table>
</div>
<p>When using <code class="literal">breadth_first</code> mode the set of documents that fall into the uppermost buckets are
cached for subsequent replay so there is a memory overhead in doing this which is linear with the number of matching documents.
Note that the <code class="literal">order</code> parameter can still be used to refer to data from a child aggregation when using the <code class="literal">breadth_first</code> setting - the parent
aggregation understands that this child aggregation will need to be called first before any of the other child aggregations.</p>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>Nested aggregations such as <code class="literal">top_hits</code> which require access to score information under an aggregation that uses the <code class="literal">breadth_first</code>
collection mode need to replay the query on the second pass but only for the documents belonging to the top buckets.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-bucket-terms-aggregation-execution-hint"></a>Execution hint<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>There are different mechanisms by which terms aggregations can be executed:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
by using field values directly in order to aggregate data per-bucket (<code class="literal">map</code>)
</li>
<li class="listitem">
by using global ordinals of the field and allocating one bucket per global ordinal (<code class="literal">global_ordinals</code>)
</li>
</ul>
</div>
<p>Elasticsearch tries to have sensible defaults so this is something that generally doesn&#8217;t need to be configured.</p>
<p><code class="literal">global_ordinals</code> is the default option for <code class="literal">keyword</code> field, it uses global ordinals to allocates buckets dynamically
so memory usage is linear to the number of values of the documents that are part of the aggregation scope.</p>
<p><code class="literal">map</code> should only be considered when very few documents match a query. Otherwise the ordinals-based execution mode
is significantly faster. By default, <code class="literal">map</code> is only used when running an aggregation on scripts, since they don&#8217;t have
ordinals.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "tags": {
      "terms": {
        "field": "tags",
        "execution_hint": "map" <a id="CO261-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1087.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO261-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The possible values are <code class="literal">map</code>, <code class="literal">global_ordinals</code></p>
</td>
</tr>
</table>
</div>
<p>Please note that Elasticsearch will ignore this execution hint if it is not applicable and that there is no backward compatibility guarantee on these hints.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_missing_value_4"></a>Missing value<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">missing</code> parameter defines how documents that are missing a value should be treated.
By default they will be ignored but it is also possible to treat them as if they
had a value.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "tags": {
      "terms": {
        "field": "tags",
        "missing": "N/A" <a id="CO262-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1088.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO262-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Documents without a value in the <code class="literal">tags</code> field will fall into the same bucket as documents that have the value <code class="literal">N/A</code>.</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_mixing_field_types"></a>Mixing field types<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>When aggregating on multiple indices the type of the aggregated field may not be the same in all indices.
Some types are compatible with each other (<code class="literal">integer</code> and <code class="literal">long</code> or <code class="literal">float</code> and <code class="literal">double</code>) but when the types are a mix
of decimal and non-decimal number the terms aggregation will promote the non-decimal numbers to decimal numbers.
This can result in a loss of precision in the bucket values.</p>
</div>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-variablewidthhistogram-aggregation"></a>Variable width histogram aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/variablewidthhistogram-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>This functionality is experimental and may be changed or removed completely in a future release. Elastic will take a best effort approach to fix any issues, but experimental features are not subject to the support SLA of official GA features. We&#8217;re evaluating the request and response format for this new aggregation. For feature status, see <a href="https://github.com/elastic/elasticsearch/issues/58573" class="ulink" target="_top">#58573</a>.</p>
</div>
</div>
<p>This is a multi-bucket aggregation similar to <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-histogram-aggregation" title="Histogram aggregation">Histogram</a>.
However, the width of each bucket is not specified. Rather, a target number of buckets is provided and bucket intervals
are dynamically determined based on the document distribution. This is done using a simple one-pass document clustering algorithm
that aims to obtain low distances between bucket centroids. Unlike other multi-bucket aggregations, the intervals will not
necessarily have a uniform width.</p>
<div class="tip admon">
<div class="icon"></div>
<div class="admon_content">
<p>The number of buckets returned will always be less than or equal to the target number.</p>
</div>
</div>
<p>Requesting a target of 2 buckets.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "prices": {
      "variable_width_histogram": {
        "field": "price",
        "buckets": 2
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1089.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "prices": {
      "buckets": [
        {
          "min": 10.0,
          "key": 30.0,
          "max": 50.0,
          "doc_count": 2
        },
        {
          "min": 150.0,
          "key": 185.0,
          "max": 200.0,
          "doc_count": 5
        }
      ]
    }
  }
}</pre>
</div>
<div class="important admon">
<div class="icon"></div>
<div class="admon_content">
<p>This aggregation cannot currently be nested under any aggregation that collects from more than a single bucket.</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_clustering_algorithm"></a>Clustering Algorithm<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/variablewidthhistogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Each shard fetches the first <code class="literal">initial_buffer</code> documents and stores them in memory. Once the buffer is full, these documents
are sorted and linearly separated into <code class="literal">3/4 * shard_size buckets</code>.
Next each remaining documents is either collected into the nearest bucket, or placed into a new bucket if it is distant
from all the existing ones. At most <code class="literal">shard_size</code> total buckets are created.</p>
<p>In the reduce step, the coordinating node sorts the buckets from all shards by their centroids. Then, the two buckets
with the nearest centroids are repeatedly merged until the target number of buckets is achieved.
This merging procedure is a form of <a href="https://en.wikipedia.org/wiki/Hierarchical_clustering" class="ulink" target="_top">agglomerative hierarchical clustering</a>.</p>
<div class="tip admon">
<div class="icon"></div>
<div class="admon_content">
<p>A shard can return fewer than <code class="literal">shard_size</code> buckets, but it cannot return more.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_shard_size_4"></a>Shard size<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/variablewidthhistogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">shard_size</code> parameter specifies the number of buckets that the coordinating node will request from each shard.
A higher <code class="literal">shard_size</code> leads each shard to produce smaller buckets. This reduce the likelihood of buckets overlapping
after the reduction step. Increasing the <code class="literal">shard_size</code> will improve the accuracy of the histogram, but it will
also make it more expensive to compute the final result because bigger priority queues will have to be managed on a
shard level, and the data transfers between the nodes and the client will be larger.</p>
<div class="tip admon">
<div class="icon"></div>
<div class="admon_content">
<p>Parameters <code class="literal">buckets</code>, <code class="literal">shard_size</code>, and <code class="literal">initial_buffer</code> are optional. By default, <code class="literal">buckets = 10</code>, <code class="literal">shard_size = buckets * 50</code>, and <code class="literal">initial_buffer = min(10 * shard_size, 50000)</code>.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_initial_buffer"></a>Initial Buffer<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/variablewidthhistogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">initial_buffer</code> parameter can be used to specify the number of individual documents that will be stored in memory
on a shard before the initial bucketing algorithm is run. Bucket distribution is determined using this sample
of <code class="literal">initial_buffer</code> documents. So, although a higher <code class="literal">initial_buffer</code> will use more memory, it will lead to more representative
clusters.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_bucket_bounds_are_approximate"></a>Bucket bounds are approximate<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/variablewidthhistogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>During the reduce step, the master node continuously merges the two buckets with the nearest centroids. If two buckets have
overlapping bounds but distant centroids, then it is possible that they will not be merged. Because of this, after
reduction the maximum value in some interval (<code class="literal">max</code>) might be greater than the minimum value in the subsequent
bucket (<code class="literal">min</code>). To reduce the impact of this error, when such an overlap occurs the bound between these intervals is adjusted to be <code class="literal">(max + min) / 2</code>.</p>
<div class="tip admon">
<div class="icon"></div>
<div class="admon_content">
<p>Bucket bounds are very sensitive to outliers</p>
</div>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-range-field-note"></a>Subtleties of bucketing range fields<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/range-field-note.asciidoc">edit</a></h2>
</div></div></div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_documents_are_counted_for_each_bucket_they_land_in"></a>Documents are counted for each bucket they land in<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/range-field-note.asciidoc">edit</a></h3>
</div></div></div>
<p>Since a range represents multiple values, running a bucket aggregation over a
range field can result in the same document landing in multiple buckets. This
can lead to surprising behavior, such as the sum of bucket counts being higher
than the number of matched documents.  For example, consider the following
index:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT range_index
{
  "settings": {
    "number_of_shards": 2
  },
  "mappings": {
    "properties": {
      "expected_attendees": {
        "type": "integer_range"
      },
      "time_frame": {
        "type": "date_range",
        "format": "yyyy-MM-dd||epoch_millis"
      }
    }
  }
}

PUT range_index/_doc/1?refresh
{
  "expected_attendees" : {
    "gte" : 10,
    "lte" : 20
  },
  "time_frame" : {
    "gte" : "2019-10-28",
    "lte" : "2019-11-04"
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1090.console"></div>
<p>The range is wider than the interval in the following aggregation, and thus the
document will land in multiple buckets.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /range_index/_search?size=0
{
  "aggs": {
    "range_histo": {
      "histogram": {
        "field": "expected_attendees",
        "interval": 5
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1091.console"></div>
<p>Since the interval is <code class="literal">5</code> (and the offset is <code class="literal">0</code> by default), we expect buckets <code class="literal">10</code>,
<code class="literal">15</code>, and <code class="literal">20</code>. Our range document will fall in all three of these buckets.</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations" : {
    "range_histo" : {
      "buckets" : [
        {
          "key" : 10.0,
          "doc_count" : 1
        },
        {
          "key" : 15.0,
          "doc_count" : 1
        },
        {
          "key" : 20.0,
          "doc_count" : 1
        }
      ]
    }
  }
}</pre>
</div>
<p>A document cannot exist partially in a bucket; For example, the above document
cannot count as one-third in each of the above three buckets. In this example,
since the document&#8217;s range landed in multiple buckets, the full value of that
document would also be counted in any sub-aggregations for each bucket as well.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_query_bounds_are_not_aggregation_filters"></a>Query bounds are not aggregation filters<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/aggregations/bucket/range-field-note.asciidoc">edit</a></h3>
</div></div></div>
<p>Another unexpected behavior can arise when a query is used to filter on the
field being aggregated. In this case, a document could match the query but
still have one or both of the endpoints of the range outside the query.
Consider the following aggregation on the above document:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /range_index/_search?size=0
{
  "query": {
    "range": {
      "time_frame": {
        "gte": "2019-11-01",
        "format": "yyyy-MM-dd"
      }
    }
  },
  "aggs": {
    "november_data": {
      "date_histogram": {
        "field": "time_frame",
        "calendar_interval": "day",
        "format": "yyyy-MM-dd"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1092.console"></div>
<p>Even though the query only considers days in November, the aggregation
generates 8 buckets (4 in October, 4 in November) because the aggregation is
calculated over the ranges of all matching documents.</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations" : {
    "november_data" : {
      "buckets" : [
              {
          "key_as_string" : "2019-10-28",
          "key" : 1572220800000,
          "doc_count" : 1
        },
        {
          "key_as_string" : "2019-10-29",
          "key" : 1572307200000,
          "doc_count" : 1
        },
        {
          "key_as_string" : "2019-10-30",
          "key" : 1572393600000,
          "doc_count" : 1
        },
        {
          "key_as_string" : "2019-10-31",
          "key" : 1572480000000,
          "doc_count" : 1
        },
        {
          "key_as_string" : "2019-11-01",
          "key" : 1572566400000,
          "doc_count" : 1
        },
        {
          "key_as_string" : "2019-11-02",
          "key" : 1572652800000,
          "doc_count" : 1
        },
        {
          "key_as_string" : "2019-11-03",
          "key" : 1572739200000,
          "doc_count" : 1
        },
        {
          "key_as_string" : "2019-11-04",
          "key" : 1572825600000,
          "doc_count" : 1
        }
      ]
    }
  }
}</pre>
</div>
<p>Depending on the use case, a <code class="literal">CONTAINS</code> query could limit the documents to only
those that fall entirely in the queried range.  In this example, the one
document would not be included and the aggregation would be empty.  Filtering
the buckets after the aggregation is also an option, for use cases where the
document should be counted but the out of bounds data can be safely ignored.</p>
</div>

</div>

</div>
<div class="navfooter">
<span class="prev">
<a href="search-aggregations.html">« Aggregations</a>
</span>
<span class="next">
<a href="search-aggregations-metrics.html">Metrics aggregations »</a>
</span>
</div>
</div>

                  <!-- end body -->
                </div>

                <div class="col-12 order-3 col-lg-2 order-lg-3 h-almost-full-lg sticky-top-lg" id="right_col">
                  <div id="sticky_content">
                    <!-- The OTP is appended here -->
                    <div class="row">
                      <div class="col-0 col-md-4 col-lg-0" id="bottom_left_col"></div>
                      <div class="col-12 col-md-8 col-lg-12">
                        <div id="rtpcontainer">
                          <div class="mktg-promo" id="most-popular">
                            <p class="aside-heading">Most Popular</p>
                            <div class="pb-2">
                              <p class="media-type">Video</p>
                              <a href="https://www.elastic.co/webinars/getting-started-elasticsearch?page=docs&placement=top-video">
                                <p class="mb-0">Get Started with Elasticsearch</p>
                              </a>
                            </div>
                            <div class="pb-2">
                              <p class="media-type">Video</p>
                              <a href="https://www.elastic.co/webinars/getting-started-kibana?page=docs&placement=top-video">
                                <p class="mb-0">Intro to Kibana</p>
                              </a>
                            </div>
                            <div class="pb-2">
                              <p class="media-type">Video</p>
                              <a href="https://www.elastic.co/webinars/introduction-elk-stack?page=docs&placement=top-video">
                                <p class="mb-0">ELK for Logs & Metrics</p>
                              </a>
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </section>

        </div>


<div id='elastic-footer'></div>
<script src='https://www.elastic.co/elastic-footer.js'></script>
<!-- Footer Section end-->

      </section>
    </div>

<script src="/guide/static/jquery.js"></script>
<script type="text/javascript" src="/guide/static/docs.js"></script>
<script type="text/javascript">
  window.initial_state = {}</script>
  </body>
</html>
