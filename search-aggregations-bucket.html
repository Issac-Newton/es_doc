<!DOCTYPE html>
<html lang="en-us">
  <head>
    
<meta charset="UTF-8">
<title>Bucket aggregations | Elasticsearch Guide | Elastic</title>
<meta class="elastic" name="content" content="Bucket aggregations | Elasticsearch Guide">

<link rel="home" href="index.html" title="Elasticsearch Guide"/>
<link rel="up" href="search-aggregations.html" title="Aggregations"/>
<link rel="prev" href="search-aggregations.html" title="Aggregations"/>
<link rel="next" href="search-aggregations-metrics.html" title="Metrics aggregations"/>
<meta class="elastic" name="product_version" content=""/>
<meta class="elastic" name="product_name" content=""/>
<meta class="elastic" name="website_area" content="documentation"/>
<meta name="DC.type" content="Learn/Docs/"/>
<meta name="DC.subject" content=""/>
<meta name="DC.identifier" content=""/>

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://cdn.optimizely.com/js/18132920325.js"></script>
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-icon-180x180.png">
    <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/android-chrome-192x192.png" sizes="192x192">
    <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
    <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
    <link rel="manifest" href="/manifest.json">
    <meta name="apple-mobile-web-app-title" content="Elastic">
    <meta name="application-name" content="Elastic">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/mstile-144x144.png">
    <meta name="theme-color" content="#ffffff">
    <meta name="naver-site-verification" content="936882c1853b701b3cef3721758d80535413dbfd" />
    <meta name="yandex-verification" content="d8a47e95d0972434" />
    <meta name="localized" content="true" />
    <meta name="st:robots" content="follow,index" />
    <meta property="og:image" content="https://static-www.elastic.co/v3/assets/bltefdd0b53724fa2ce/blt280217a63b82a734/6202d3378b1f312528798412/elastic-logo.svg" />
    <meta property="og:image:width" content="500" />
    <meta property="og:image:height" content="172" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon-precomposed" sizes="64x64" href="/favicon_64x64_16bit.png">
    <link rel="apple-touch-icon-precomposed" sizes="32x32" href="/favicon_32x32.png">
    <link rel="apple-touch-icon-precomposed" sizes="16x16" href="/favicon_16x16.png">
    <!-- Give IE8 a fighting chance -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <link rel="stylesheet" type="text/css" href="/guide/static/styles.css" />
  </head>

  <!--© 2015-2022 Elasticsearch B.V. -->
  <!-- All Elastic documentation is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License. -->
  <!-- http://creativecommons.org/licenses/by-nc-nd/4.0/ -->

  <body>
    <!-- Google Tag Manager -->
    <script>dataLayer = [];</script><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-58RLH5" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0], j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src= '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f); })(window,document,'script','dataLayer','GTM-58RLH5');</script>
    <!-- End Google Tag Manager -->

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-12395217-16"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-12395217-16');
    </script>

    <!-- Google Tag Manager for GA4 -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0], j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-KNJMG2M');</script>
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KNJMG2M" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager for GA4-->

    <div id='elastic-nav' style="display:none;"></div>
    <script src='https://www.elastic.co/elastic-nav.js'></script>

    <div class="main-container">
      <section id="content" >
        <div class="content-wrapper">

          <section id="guide" lang="en">
            <div class="container-fluid">
              <div class="row pb-3">
                <div class="col-12 order-2 col-md-4 order-md-1 col-lg-3 h-almost-full-md sticky-top-md" id="left_col">
                  <!-- The TOC is appended here -->
                </div>

                <div class="col-12 order-1 col-md-8 order-md-2 col-lg-7 order-lg-2 guide-section" id="middle_col">
                  <!-- start body -->
                  
<div id="content">
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="/guide/">Elastic Docs</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="index.html">Elasticsearch Guide</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="search-aggregations.html">Aggregations</a></span>
</div>
<div class="navheader">
<span class="prev">
<a href="search-aggregations.html">« Aggregations</a>
</span>
<span class="next">
<a href="search-aggregations-metrics.html">Metrics aggregations »</a>
</span>
</div>
<div class="chapter">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket"></a>Bucket aggregations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket.asciidoc">edit</a></h2>
</div></div></div>
<p>Bucket aggregations don&#8217;t calculate metrics over fields like the metrics aggregations do, but instead, they create
buckets of documents. Each bucket is associated with a criterion (depending on the aggregation type) which determines
whether or not a document in the current context "falls" into it. In other words, the buckets effectively define document
sets. In addition to the buckets themselves, the <code class="literal">bucket</code> aggregations also compute and return the number of documents
that "fell into" each bucket.</p>
<p>Bucket aggregations, as opposed to <code class="literal">metrics</code> aggregations, can hold sub-aggregations. These sub-aggregations will be
aggregated for the buckets created by their "parent" bucket aggregation.</p>
<p>There are different bucket aggregators, each with a different "bucketing" strategy. Some define a single bucket, some
define fixed number of multiple buckets, and others dynamically create the buckets during the aggregation process.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>The <a class="xref" href="settings.html#search-settings-max-buckets"><code class="literal">search.max_buckets</code></a> cluster setting
limits the number of buckets allowed in a single response.</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-adjacency-matrix-aggregation"></a>Adjacency matrix aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/adjacency-matrix-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A bucket aggregation returning a form of <a href="https://en.wikipedia.org/wiki/Adjacency_matrix" class="ulink" target="_top">adjacency matrix</a>.
The request provides a collection of named filter expressions, similar to the <code class="literal">filters</code> aggregation
request.
Each bucket in the response represents a non-empty cell in the matrix of intersecting filters.</p>
<p>Given filters named <code class="literal">A</code>, <code class="literal">B</code> and <code class="literal">C</code> the response would return buckets with the following names:</p>
<div class="informaltable">
<table border="1" cellpadding="4px">
<colgroup>
<col class="col_1"/>
<col class="col_2"/>
<col class="col_3"/>
<col class="col_4"/>
</colgroup>
<thead>
<tr>
<th align="left" valign="top"></th>
<th align="left" valign="top">A</th>
<th align="left" valign="top">B</th>
<th align="left" valign="top">C</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p><span class="strong strong"><strong>A</strong></span></p></td>
<td align="left" valign="top"><p>A</p></td>
<td align="left" valign="top"><p>A&amp;B</p></td>
<td align="left" valign="top"><p>A&amp;C</p></td>
</tr>
<tr>
<td align="left" valign="top"><p><span class="strong strong"><strong>B</strong></span></p></td>
<td align="left" valign="top"><p></p></td>
<td align="left" valign="top"><p>B</p></td>
<td align="left" valign="top"><p>B&amp;C</p></td>
</tr>
<tr>
<td align="left" valign="top"><p><span class="strong strong"><strong>C</strong></span></p></td>
<td align="left" valign="top"><p></p></td>
<td align="left" valign="top"><p></p></td>
<td align="left" valign="top"><p>C</p></td>
</tr>
</tbody>
</table>
</div>
<p>The intersecting buckets e.g <code class="literal">A&amp;C</code> are labelled using a combination of the two filter names with a default separator
of <code class="literal">&amp;</code>. Note that the response does not also include a <code class="literal">C&amp;A</code> bucket as this would be the
same set of documents as <code class="literal">A&amp;C</code>. The matrix is said to be <em>symmetric</em> so we only return half of it. To do this we sort
the filter name strings and always use the lowest of a pair as the value to the left of the separator.</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="adjacency-matrix-agg-ex"></a>Example<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/adjacency-matrix-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The following <code class="literal">interactions</code> aggregation uses <code class="literal">adjacency_matrix</code> to determine
which groups of individuals exchanged emails.</p>
<a id="adjacency-matrix-aggregation-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT emails/_bulk?refresh
{ "index" : { "_id" : 1 } }
{ "accounts" : ["hillary", "sidney"]}
{ "index" : { "_id" : 2 } }
{ "accounts" : ["hillary", "donald"]}
{ "index" : { "_id" : 3 } }
{ "accounts" : ["vladimir", "donald"]}

GET emails/_search
{
  "size": 0,
  "aggs" : {
    "interactions" : {
      "adjacency_matrix" : {
        "filters" : {
          "grpA" : { "terms" : { "accounts" : ["hillary", "sidney"] }},
          "grpB" : { "terms" : { "accounts" : ["donald", "mitt"] }},
          "grpC" : { "terms" : { "accounts" : ["vladimir", "nigel"] }}
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1185.console"></div>
<p>The response contains buckets with document counts for each filter and
combination of filters. Buckets with no matching documents are excluded from the
response.</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "took": 9,
  "timed_out": false,
  "_shards": ...,
  "hits": ...,
  "aggregations": {
    "interactions": {
      "buckets": [
        {
          "key":"grpA",
          "doc_count": 2
        },
        {
          "key":"grpA&amp;grpB",
          "doc_count": 1
        },
        {
          "key":"grpB",
          "doc_count": 2
        },
        {
          "key":"grpB&amp;grpC",
          "doc_count": 1
        },
        {
          "key":"grpC",
          "doc_count": 1
        }
      ]
    }
  }
}</pre>
</div>
</div>

<div class="section child_attributes">
<div class="titlepage"><div><div>
<h3 class="title"><a id="adjacency-matrix-agg-params"></a>Parameters<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/adjacency-matrix-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">filters</code>
</span>
</dt>
<dd>
<p>
(Required, object)
Filters used to create buckets.
</p>
<details open>
<summary class="title">Properties of <code class="literal">filters</code></summary>
<div class="content">
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">&lt;filter&gt;</code>
</span>
</dt>
<dd>
<p>
(Required, <a class="xref" href="query-dsl.html" title="Query DSL">Query DSL object</a>)
Query used to filter documents. The key is the filter name.
</p>
<p>At least one filter is required. The total number of filters cannot exceed the
<a class="xref" href="settings.html#indices-query-bool-max-clause-count"><code class="literal">indices.query.bool.max_clause_count</code></a>
setting. See <a class="xref" href="search-aggregations-bucket.html#adjacency-matrix-agg-filter-limits" title="Filter limits">Filter limits</a>.</p>
</dd>
</dl>
</div>
</div>
</details>
</dd>
<dt>
<span class="term">
<code class="literal">separator</code>
</span>
</dt>
<dd>
(Optional, string)
Separator used to concatenate filter names. Defaults to <code class="literal">&amp;</code>.
</dd>
</dl>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="adjacency-matrix-agg-response"></a>Response body<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/adjacency-matrix-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">key</code>
</span>
</dt>
<dd>
(string)
Filters for the bucket. If the bucket uses multiple filters, filter names are
concatenated using a <code class="literal">separator</code>.
</dd>
<dt>
<span class="term">
<code class="literal">doc_count</code>
</span>
</dt>
<dd>
(integer)
Number of documents matching the bucket&#8217;s filters.
</dd>
</dl>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="adjacency-matrix-agg-usage"></a>Usage<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/adjacency-matrix-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>On its own this aggregation can provide all of the data required to create an undirected weighted graph.
However, when used with child aggregations such as a <code class="literal">date_histogram</code> the results can provide the
additional levels of data required to perform <a href="https://en.wikipedia.org/wiki/Dynamic_network_analysis" class="ulink" target="_top">dynamic network analysis</a>
where examining interactions <em>over time</em> becomes important.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="adjacency-matrix-agg-filter-limits"></a>Filter limits<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/adjacency-matrix-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>For N filters the matrix of buckets produced can be N²/2 which can be costly.
The circuit breaker settings prevent results producing too many buckets and to avoid excessive disk seeks
the <code class="literal">indices.query.bool.max_clause_count</code> setting is used to limit the number of filters.</p>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-autodatehistogram-aggregation"></a>Auto-interval date histogram aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/autodatehistogram-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A multi-bucket aggregation similar to the <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-datehistogram-aggregation" title="Date histogram aggregation">Date histogram</a> except
instead of providing an interval to use as the width of each bucket, a target number of buckets is provided
indicating the number of buckets needed and the interval of the buckets is automatically chosen to best achieve
that target. The number of buckets returned will always be less than or equal to this target number.</p>
<p>The buckets field is optional, and will default to 10 buckets if not specified.</p>
<p>Requesting a target of 10 buckets.</p>
<a id="autodatehistogram-aggregation-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "sales_over_time": {
      "auto_date_histogram": {
        "field": "date",
        "buckets": 10
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1186.console"></div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_keys"></a>Keys<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/autodatehistogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Internally, a date is represented as a 64 bit number representing a timestamp
in milliseconds-since-the-epoch. These timestamps are returned as the bucket
<code class="literal">key</code>s. The <code class="literal">key_as_string</code> is the same timestamp converted to a formatted
date string using the format specified with the <code class="literal">format</code> parameter:</p>
<div class="tip admon">
<div class="icon"></div>
<div class="admon_content">
<p>If no <code class="literal">format</code> is specified, then it will use the first date
<a class="xref" href="mapping-params.html#mapping-date-format" title="format">format</a> specified in the field mapping.</p>
</div>
</div>
<a id="autodatehistogram-aggregation-format-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "sales_over_time": {
      "auto_date_histogram": {
        "field": "date",
        "buckets": 5,
        "format": "yyyy-MM-dd" <a id="CO256-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1187.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO256-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Supports expressive date <a class="xref" href="search-aggregations-bucket.html#date-format-pattern" title="Date Format/Pattern">format pattern</a></p>
</td>
</tr>
</table>
</div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "sales_over_time": {
      "buckets": [
        {
          "key_as_string": "2015-01-01",
          "key": 1420070400000,
          "doc_count": 3
        },
        {
          "key_as_string": "2015-02-01",
          "key": 1422748800000,
          "doc_count": 2
        },
        {
          "key_as_string": "2015-03-01",
          "key": 1425168000000,
          "doc_count": 2
        }
      ],
      "interval": "1M"
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_intervals"></a>Intervals<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/autodatehistogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The interval of the returned buckets is selected based on the data collected by the
aggregation so that the number of buckets returned is less than or equal to the number
requested. The possible intervals returned are:</p>
<div class="informaltable">
<table border="0" cellpadding="4px">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody valign="top">
<tr>
<td valign="top">
<p>
seconds
</p>
</td>
<td valign="top">
<p>
In multiples of 1, 5, 10 and 30
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
minutes
</p>
</td>
<td valign="top">
<p>
In multiples of 1, 5, 10 and 30
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
hours
</p>
</td>
<td valign="top">
<p>
In multiples of 1, 3 and 12
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
days
</p>
</td>
<td valign="top">
<p>
In multiples of 1, and 7
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
months
</p>
</td>
<td valign="top">
<p>
In multiples of 1, and 3
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
years
</p>
</td>
<td valign="top">
<p>
In multiples of 1, 5, 10, 20, 50 and 100
</p>
</td>
</tr>
</tbody>
</table>
</div>
<p>In the worst case, where the number of daily buckets are too many for the requested
number of buckets, the number of buckets returned will be 1/7th of the number of
buckets requested.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_time_zone"></a>Time Zone<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/autodatehistogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Date-times are stored in Elasticsearch in UTC. By default, all bucketing and
rounding is also done in UTC. The <code class="literal">time_zone</code> parameter can be used to indicate
that bucketing should use a different time zone.</p>
<p>Time zones may either be specified as an ISO 8601 UTC offset (e.g. <code class="literal">+01:00</code> or
<code class="literal">-08:00</code>)  or as a timezone id, an identifier used in the TZ database like
<code class="literal">America/Los_Angeles</code>.</p>
<p>Consider the following example:</p>
<a id="autodatehistogram-aggregation-timezone-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT my-index-000001/_doc/1?refresh
{
  "date": "2015-10-01T00:30:00Z"
}

PUT my-index-000001/_doc/2?refresh
{
  "date": "2015-10-01T01:30:00Z"
}

PUT my-index-000001/_doc/3?refresh
{
  "date": "2015-10-01T02:30:00Z"
}

GET my-index-000001/_search?size=0
{
  "aggs": {
    "by_day": {
      "auto_date_histogram": {
        "field":     "date",
        "buckets" : 3
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1188.console"></div>
<p>UTC is used if no time zone is specified, three 1-hour buckets are returned
starting at midnight UTC on 1 October 2015:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "by_day": {
      "buckets": [
        {
          "key_as_string": "2015-10-01T00:00:00.000Z",
          "key": 1443657600000,
          "doc_count": 1
        },
        {
          "key_as_string": "2015-10-01T01:00:00.000Z",
          "key": 1443661200000,
          "doc_count": 1
        },
        {
          "key_as_string": "2015-10-01T02:00:00.000Z",
          "key": 1443664800000,
          "doc_count": 1
        }
      ],
      "interval": "1h"
    }
  }
}</pre>
</div>
<p>If a <code class="literal">time_zone</code> of <code class="literal">-01:00</code> is specified, then midnight starts at one hour before
midnight UTC:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET my-index-000001/_search?size=0
{
  "aggs": {
    "by_day": {
      "auto_date_histogram": {
        "field":     "date",
        "buckets" : 3,
        "time_zone": "-01:00"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1189.console"></div>
<p>Now three 1-hour buckets are still returned but the first bucket starts at
11:00pm on 30 September 2015 since that is the local time for the bucket in
the specified time zone.</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "by_day": {
      "buckets": [
        {
          "key_as_string": "2015-09-30T23:00:00.000-01:00", <a id="CO257-1"></a><i class="conum" data-value="1"></i>
          "key": 1443657600000,
          "doc_count": 1
        },
        {
          "key_as_string": "2015-10-01T00:00:00.000-01:00",
          "key": 1443661200000,
          "doc_count": 1
        },
        {
          "key_as_string": "2015-10-01T01:00:00.000-01:00",
          "key": 1443664800000,
          "doc_count": 1
        }
      ],
      "interval": "1h"
    }
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO257-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">key_as_string</code> value represents midnight on each day
in the specified time zone.</p>
</td>
</tr>
</table>
</div>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>When using time zones that follow DST (daylight savings time) changes,
buckets close to the moment when those changes happen can have slightly different
sizes than neighbouring buckets.
For example, consider a DST start in the <code class="literal">CET</code> time zone: on 27 March 2016 at 2am,
clocks were turned forward 1 hour to 3am local time. If the result of the aggregation
was daily buckets, the bucket covering that day will only hold data for 23 hours
instead of the usual 24 hours for other buckets. The same is true for shorter intervals
like e.g. 12h. Here, we will have only a 11h bucket on the morning of 27 March when the
DST shift happens.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_minimum_interval_parameter"></a>Minimum Interval parameter<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/autodatehistogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">minimum_interval</code> allows the caller to specify the minimum rounding interval that should be used.
This can make the collection process more efficient, as the aggregation will not attempt to round at
any interval lower than <code class="literal">minimum_interval</code>.</p>
<p>The accepted units for <code class="literal">minimum_interval</code> are:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
year
</li>
<li class="listitem">
month
</li>
<li class="listitem">
day
</li>
<li class="listitem">
hour
</li>
<li class="listitem">
minute
</li>
<li class="listitem">
second
</li>
</ul>
</div>
<a id="autodatehistogram-aggregation-minimum-interval-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "sale_date": {
      "auto_date_histogram": {
        "field": "date",
        "buckets": 10,
        "minimum_interval": "minute"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1190.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_missing_value"></a>Missing value<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/autodatehistogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">missing</code> parameter defines how documents that are missing a value should be treated.
By default they will be ignored but it is also possible to treat them as if they
had a value.</p>
<a id="autodatehistogram-aggregation-missing-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "sale_date": {
      "auto_date_histogram": {
        "field": "date",
        "buckets": 10,
        "missing": "2000/01/01" <a id="CO258-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1191.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO258-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Documents without a value in the <code class="literal">publish_date</code> field will fall into the same bucket as documents that have the value <code class="literal">2000-01-01</code>.</p>
</td>
</tr>
</table>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-categorize-text-aggregation"></a>Categorize text aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/categorize-text-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A multi-bucket aggregation that groups semi-structured text into buckets. Each <code class="literal">text</code> field is re-analyzed
using a custom analyzer. The resulting tokens are then categorized creating buckets of similarly formatted
text values. This aggregation works best with machine generated text like system logs. Only the first 100 analyzed
tokens are used to categorize the text.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>If you have considerable memory allocated to your JVM but are receiving circuit breaker exceptions from this
      aggregation, you may be attempting to categorize text that is poorly formatted for categorization. Consider
      adding <code class="literal">categorization_filters</code> or running under <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-sampler-aggregation" title="Sampler aggregation">sampler</a>,
      <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-diversified-sampler-aggregation" title="Diversified sampler aggregation">diversified sampler</a>, or
      <a class="xref" href="search-aggregations-bucket.html#search-aggregations-random-sampler-aggregation" title="Random sampler aggregation">random sampler</a> to explore the created categories.</p>
</div>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>The algorithm used for categorization was completely changed in version 8.3.0. As a result this aggregation
      will not work in a mixed version cluster where some nodes are on version 8.3.0 or higher and others are
      on a version older than 8.3.0. Upgrade all nodes in your cluster to the same version if you experience
      an error related to this change.</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="bucket-categorize-text-agg-syntax"></a>Parameters<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/categorize-text-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">categorization_analyzer</code>
</span>
</dt>
<dd>
<p>
(Optional, object or string)
The categorization analyzer specifies how the text is analyzed and tokenized before
being categorized. The syntax is very similar to that used to define the <code class="literal">analyzer</code> in the
<a class="xref" href="indices.html#indices-analyze" title="Analyze API">Analyze endpoint</a>. This
property cannot be used at the same time as <code class="literal">categorization_filters</code>.
</p>
<p>The <code class="literal">categorization_analyzer</code> field can be specified either as a string or as an
object. If it is a string it must refer to a
<a class="xref" href="analysis-analyzers.html" title="Built-in analyzer reference">built-in analyzer</a> or one added by another plugin. If it
is an object it has the following properties:</p>
<details open>
<summary class="title">Properties of <code class="literal">categorization_analyzer</code></summary>
<div class="content">
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">char_filter</code>
</span>
</dt>
<dd>
(array of strings or objects)
One or more <a class="xref" href="analysis-charfilters.html" title="Character filters reference">character filters</a>. In addition to the
built-in character filters, other plugins can provide more character filters.
This property is optional. If it is not specified, no character filters are
applied prior to categorization. If you are customizing some other aspect of the
analyzer and you need to achieve the equivalent of <code class="literal">categorization_filters</code>
(which are not permitted when some other aspect of the analyzer is customized),
add them here as
<a class="xref" href="analysis-charfilters.html#analysis-pattern-replace-charfilter" title="Pattern replace character filter">pattern replace character filters</a>.
</dd>
<dt>
<span class="term">
<code class="literal">tokenizer</code>
</span>
</dt>
<dd>
(string or object)
The name or definition of the <a class="xref" href="analysis-tokenizers.html" title="Tokenizer reference">tokenizer</a> to use after
character filters are applied. This property is compulsory if
<code class="literal">categorization_analyzer</code> is specified as an object. Machine learning provides
a tokenizer called <code class="literal">ml_standard</code> that tokenizes in a way that has been
determined to produce good categorization results on a variety of log
file formats for logs in English. If you want to use that tokenizer but
change the character or token filters, specify <code class="literal">"tokenizer": "ml_standard"</code>
in your <code class="literal">categorization_analyzer</code>. Additionally, the <code class="literal">ml_classic</code> tokenizer
is available, which tokenizes in the same way as the non-customizable
tokenizer in old versions of the product (before 6.2). <code class="literal">ml_classic</code> was
the default categorization tokenizer in versions 6.2 to 7.13, so if you
need categorization identical to the default for jobs created in these
versions, specify <code class="literal">"tokenizer": "ml_classic"</code> in your <code class="literal">categorization_analyzer</code>.
</dd>
<dt>
<span class="term">
<code class="literal">filter</code>
</span>
</dt>
<dd>
(array of strings or objects)
One or more <a class="xref" href="analysis-tokenfilters.html" title="Token filter reference">token filters</a>. In addition to the built-in
token filters, other plugins can provide more token filters. This property is
optional. If it is not specified, no token filters are applied prior to
categorization.
</dd>
</dl>
</div>
</div>
</details>
</dd>
<dt>
<span class="term">
<code class="literal">categorization_filters</code>
</span>
</dt>
<dd>
(Optional, array of strings)
This property expects an array of regular expressions. The expressions
are used to filter out matching sequences from the categorization field values.
You can use this functionality to fine tune the categorization by excluding
sequences from consideration when categories are defined. For example, you can
exclude SQL statements that appear in your log files. This
property cannot be used at the same time as <code class="literal">categorization_analyzer</code>. If you
only want to define simple regular expression filters that are applied prior to
tokenization, setting this property is the easiest method. If you also want to
customize the tokenizer or post-tokenization filtering, use the
<code class="literal">categorization_analyzer</code> property instead and include the filters as
<code class="literal">pattern_replace</code> character filters.
</dd>
<dt>
<span class="term">
<code class="literal">field</code>
</span>
</dt>
<dd>
(Required, string)
The semi-structured text field to categorize.
</dd>
<dt>
<span class="term">
<code class="literal">max_matched_tokens</code>
</span>
</dt>
<dd>
(Optional, integer)
This parameter does nothing now, but is permitted for compatibility with the original
pre-8.3.0 implementation.
</dd>
<dt>
<span class="term">
<code class="literal">max_unique_tokens</code>
</span>
</dt>
<dd>
(Optional, integer)
This parameter does nothing now, but is permitted for compatibility with the original
pre-8.3.0 implementation.
</dd>
<dt>
<span class="term">
<code class="literal">min_doc_count</code>
</span>
</dt>
<dd>
(Optional, integer)
The minimum number of documents for a bucket to be returned to the results.
</dd>
<dt>
<span class="term">
<code class="literal">shard_min_doc_count</code>
</span>
</dt>
<dd>
(Optional, integer)
The minimum number of documents for a bucket to be returned from the shard before
merging.
</dd>
<dt>
<span class="term">
<code class="literal">shard_size</code>
</span>
</dt>
<dd>
(Optional, integer)
The number of categorization buckets to return from each shard before merging
all the results.
</dd>
<dt>
<span class="term">
<code class="literal">similarity_threshold</code>
</span>
</dt>
<dd>
(Optional, integer, default: <code class="literal">70</code>)
The minimum percentage of token weight that must match for text to be added to the
category bucket.
Must be between 1 and 100. The larger the value the narrower the categories.
Larger values will increase memory usage and create narrower categories.
</dd>
<dt>
<span class="term">
<code class="literal">size</code>
</span>
</dt>
<dd>
(Optional, integer, default: <code class="literal">10</code>)
The number of buckets to return.
</dd>
</dl>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="bucket-categorize-text-agg-response"></a>Response body<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/categorize-text-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">key</code>
</span>
</dt>
<dd>
(string)
Consists of the tokens (extracted by the <code class="literal">categorization_analyzer</code>)
that are common to all values of the input field included in the category.
</dd>
<dt>
<span class="term">
<code class="literal">doc_count</code>
</span>
</dt>
<dd>
(integer)
Number of documents matching the category.
</dd>
<dt>
<span class="term">
<code class="literal">max_matching_length</code>
</span>
</dt>
<dd>
(integer)
Categories from short messages containing few tokens may also match
categories containing many tokens derived from much longer messages.
<code class="literal">max_matching_length</code> is an indication of the maximum length of messages
that should be considered to belong to the category. When searching for
messages that match the category, any messages longer than
<code class="literal">max_matching_length</code> should be excluded. Use this field to prevent a
search for members of a category of short messages from matching much longer
ones.
</dd>
<dt>
<span class="term">
<code class="literal">regex</code>
</span>
</dt>
<dd>
(string)
A regular expression that will match all values of the input field included
in the category. It is possible that the <code class="literal">regex</code> does not incorporate every
term in <code class="literal">key</code>, if ordering varies between the values included in the
category. However, in simple cases the <code class="literal">regex</code> will be the ordered terms
concatenated into a regular expression that allows for arbitrary sections
in between them. It is not recommended to use the <code class="literal">regex</code> as the primary
mechanism for searching for the original documents that were categorized.
Search using a regular expression is very slow. Instead the terms in the
<code class="literal">key</code> field should be used to search for matching documents, as a terms
search can use the inverted index and hence be much faster. However, there
may be situations where it is useful to use the <code class="literal">regex</code> field to test whether
a small set of messages that have not been indexed match the category, or to
confirm that the terms in the <code class="literal">key</code> occur in the correct order in all the
matched documents.
</dd>
</dl>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_basic_use"></a>Basic use<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/categorize-text-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>Re-analyzing <em>large</em> result sets will require a lot of time and memory. This aggregation should be
         used in conjunction with <a class="xref" href="search.html#async-search" title="Async search">Async search</a>. Additionally, you may consider
         using the aggregation as a child of either the <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-sampler-aggregation" title="Sampler aggregation">sampler</a> or
         <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-diversified-sampler-aggregation" title="Diversified sampler aggregation">diversified sampler</a> aggregation.
         This will typically improve speed and memory use.</p>
</div>
</div>
<p>Example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST log-messages/_search?filter_path=aggregations
{
  "aggs": {
    "categories": {
      "categorize_text": {
        "field": "message"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1192.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "aggregations" : {
    "categories" : {
      "buckets" : [
        {
          "doc_count" : 3,
          "key" : "Node shutting down",
          "regex" : ".*?Node.+?shutting.+?down.*?",
          "max_matching_length" : 49
        },
        {
          "doc_count" : 1,
          "key" : "Node starting up",
          "regex" : ".*?Node.+?starting.+?up.*?",
          "max_matching_length" : 47
        },
        {
          "doc_count" : 1,
          "key" : "User foo_325 logging on",
          "regex" : ".*?User.+?foo_325.+?logging.+?on.*?",
          "max_matching_length" : 52
        },
        {
          "doc_count" : 1,
          "key" : "User foo_864 logged off",
          "regex" : ".*?User.+?foo_864.+?logged.+?off.*?",
          "max_matching_length" : 52
        }
      ]
    }
  }
}</pre>
</div>
<p>Here is an example using <code class="literal">categorization_filters</code></p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST log-messages/_search?filter_path=aggregations
{
  "aggs": {
    "categories": {
      "categorize_text": {
        "field": "message",
        "categorization_filters": ["\\w+\\_\\d{3}"] <a id="CO259-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1193.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO259-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The filters to apply to the analyzed tokens. It filters
out tokens like <code class="literal">bar_123</code>.</p>
</td>
</tr>
</table>
</div>
<p>Note how the <code class="literal">foo_&lt;number&gt;</code> tokens are not part of the
category results</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "aggregations" : {
    "categories" : {
      "buckets" : [
        {
          "doc_count" : 3,
          "key" : "Node shutting down",
          "regex" : ".*?Node.+?shutting.+?down.*?",
          "max_matching_length" : 49
        },
        {
          "doc_count" : 1,
          "key" : "Node starting up",
          "regex" : ".*?Node.+?starting.+?up.*?",
          "max_matching_length" : 47
        },
        {
          "doc_count" : 1,
          "key" : "User logged off",
          "regex" : ".*?User.+?logged.+?off.*?",
          "max_matching_length" : 52
        },
        {
          "doc_count" : 1,
          "key" : "User logging on",
          "regex" : ".*?User.+?logging.+?on.*?",
          "max_matching_length" : 52
        }
      ]
    }
  }
}</pre>
</div>
<p>Here is an example using <code class="literal">categorization_filters</code>.
The default analyzer uses the <code class="literal">ml_standard</code> tokenizer which is similar to a whitespace tokenizer
but filters out tokens that could be interpreted as hexadecimal numbers. The default analyzer
also uses the <code class="literal">first_line_with_letters</code> character filter, so that only the first meaningful line
of multi-line messages is considered.
But, it may be that a token is a known highly-variable token (formatted usernames, emails, etc.). In that case, it is good to supply
custom <code class="literal">categorization_filters</code> to filter out those tokens for better categories. These filters may also reduce memory usage as fewer
tokens are held in memory for the categories. (If there are sufficient examples of different usernames, emails, etc., then
categories will form that naturally discard them as variables, but for small input data where only one example exists this won&#8217;t
happen.)</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST log-messages/_search?filter_path=aggregations
{
  "aggs": {
    "categories": {
      "categorize_text": {
        "field": "message",
        "categorization_filters": ["\\w+\\_\\d{3}"], <a id="CO260-1"></a><i class="conum" data-value="1"></i>
        "similarity_threshold": 11 <a id="CO260-2"></a><i class="conum" data-value="2"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1194.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO260-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The filters to apply to the analyzed tokens. It filters
out tokens like <code class="literal">bar_123</code>.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO260-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>Require 11% of token weight to match before adding a message to an
existing category rather than creating a new one.</p>
</td>
</tr>
</table>
</div>
<p>The resulting categories are now very broad, merging the log groups.
(A <code class="literal">similarity_threshold</code> of 11% is generally too low. Settings over
50% are usually better.)</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "aggregations" : {
    "categories" : {
      "buckets" : [
        {
          "doc_count" : 4,
          "key" : "Node",
          "regex" : ".*?Node.*?",
          "max_matching_length" : 49
        },
        {
          "doc_count" : 2,
          "key" : "User",
          "regex" : ".*?User.*?",
          "max_matching_length" : 52
        }
      ]
    }
  }
}</pre>
</div>
<p>This aggregation can have both sub-aggregations and itself be a sub-aggregation. This allows gathering the top daily categories and the
top sample doc as below.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST log-messages/_search?filter_path=aggregations
{
  "aggs": {
    "daily": {
      "date_histogram": {
        "field": "time",
        "fixed_interval": "1d"
      },
      "aggs": {
        "categories": {
          "categorize_text": {
            "field": "message",
            "categorization_filters": ["\\w+\\_\\d{3}"]
          },
          "aggs": {
            "hit": {
              "top_hits": {
                "size": 1,
                "sort": ["time"],
                "_source": "message"
              }
            }
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1195.console"></div>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "aggregations" : {
    "daily" : {
      "buckets" : [
        {
          "key_as_string" : "2016-02-07T00:00:00.000Z",
          "key" : 1454803200000,
          "doc_count" : 3,
          "categories" : {
            "buckets" : [
              {
                "doc_count" : 2,
                "key" : "Node shutting down",
                "regex" : ".*?Node.+?shutting.+?down.*?",
                "max_matching_length" : 49,
                "hit" : {
                  "hits" : {
                    "total" : {
                      "value" : 2,
                      "relation" : "eq"
                    },
                    "max_score" : null,
                    "hits" : [
                      {
                        "_index" : "log-messages",
                        "_id" : "1",
                        "_score" : null,
                        "_source" : {
                          "message" : "2016-02-07T00:00:00+0000 Node 3 shutting down"
                        },
                        "sort" : [
                          1454803260000
                        ]
                      }
                    ]
                  }
                }
              },
              {
                "doc_count" : 1,
                "key" : "Node starting up",
                "regex" : ".*?Node.+?starting.+?up.*?",
                "max_matching_length" : 47,
                "hit" : {
                  "hits" : {
                    "total" : {
                      "value" : 1,
                      "relation" : "eq"
                    },
                    "max_score" : null,
                    "hits" : [
                      {
                        "_index" : "log-messages",
                        "_id" : "2",
                        "_score" : null,
                        "_source" : {
                          "message" : "2016-02-07T00:00:00+0000 Node 5 starting up"
                        },
                        "sort" : [
                          1454803320000
                        ]
                      }
                    ]
                  }
                }
              }
            ]
          }
        },
        {
          "key_as_string" : "2016-02-08T00:00:00.000Z",
          "key" : 1454889600000,
          "doc_count" : 3,
          "categories" : {
            "buckets" : [
              {
                "doc_count" : 1,
                "key" : "Node shutting down",
                "regex" : ".*?Node.+?shutting.+?down.*?",
                "max_matching_length" : 49,
                "hit" : {
                  "hits" : {
                    "total" : {
                      "value" : 1,
                      "relation" : "eq"
                    },
                    "max_score" : null,
                    "hits" : [
                      {
                        "_index" : "log-messages",
                        "_id" : "4",
                        "_score" : null,
                        "_source" : {
                          "message" : "2016-02-08T00:00:00+0000 Node 5 shutting down"
                        },
                        "sort" : [
                          1454889660000
                        ]
                      }
                    ]
                  }
                }
              },
              {
                "doc_count" : 1,
                "key" : "User logged off",
                "regex" : ".*?User.+?logged.+?off.*?",
                "max_matching_length" : 52,
                "hit" : {
                  "hits" : {
                    "total" : {
                      "value" : 1,
                      "relation" : "eq"
                    },
                    "max_score" : null,
                    "hits" : [
                      {
                        "_index" : "log-messages",
                        "_id" : "6",
                        "_score" : null,
                        "_source" : {
                          "message" : "2016-02-08T00:00:00+0000 User foo_864 logged off"
                        },
                        "sort" : [
                          1454889840000
                        ]
                      }
                    ]
                  }
                }
              },
              {
                "doc_count" : 1,
                "key" : "User logging on",
                "regex" : ".*?User.+?logging.+?on.*?",
                "max_matching_length" : 52,
                "hit" : {
                  "hits" : {
                    "total" : {
                      "value" : 1,
                      "relation" : "eq"
                    },
                    "max_score" : null,
                    "hits" : [
                      {
                        "_index" : "log-messages",
                        "_id" : "5",
                        "_score" : null,
                        "_source" : {
                          "message" : "2016-02-08T00:00:00+0000 User foo_325 logging on"
                        },
                        "sort" : [
                          1454889720000
                        ]
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      ]
    }
  }
}</pre>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-children-aggregation"></a>Children aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/children-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A special single bucket aggregation that selects child documents that have the specified type, as defined in a <a class="xref" href="mapping-types.html#parent-join" title="Join field type"><code class="literal">join</code> field</a>.</p>
<p>This aggregation has a single option:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<code class="literal">type</code> - The child type that should be selected.
</li>
</ul>
</div>
<p>For example, let&#8217;s say we have an index of questions and answers. The answer type has the following <code class="literal">join</code> field in the mapping:</p>
<a id="children-aggregation-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT child_example
{
  "mappings": {
    "properties": {
      "join": {
        "type": "join",
        "relations": {
          "question": "answer"
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1196.console"></div>
<p>The <code class="literal">question</code> document contain a tag field and the <code class="literal">answer</code> documents contain an owner field. With the <code class="literal">children</code>
aggregation the tag buckets can be mapped to the owner buckets in a single request even though the two fields exist in
two different kinds of documents.</p>
<p>An example of a question document:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT child_example/_doc/1
{
  "join": {
    "name": "question"
  },
  "body": "&lt;p&gt;I have Windows 2003 server and i bought a new Windows 2008 server...",
  "title": "Whats the best way to file transfer my site from server to a newer one?",
  "tags": [
    "windows-server-2003",
    "windows-server-2008",
    "file-transfer"
  ]
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1197.console"></div>
<p>Examples of <code class="literal">answer</code> documents:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT child_example/_doc/2?routing=1
{
  "join": {
    "name": "answer",
    "parent": "1"
  },
  "owner": {
    "location": "Norfolk, United Kingdom",
    "display_name": "Sam",
    "id": 48
  },
  "body": "&lt;p&gt;Unfortunately you're pretty much limited to FTP...",
  "creation_date": "2009-05-04T13:45:37.030"
}

PUT child_example/_doc/3?routing=1&amp;refresh
{
  "join": {
    "name": "answer",
    "parent": "1"
  },
  "owner": {
    "location": "Norfolk, United Kingdom",
    "display_name": "Troll",
    "id": 49
  },
  "body": "&lt;p&gt;Use Linux...",
  "creation_date": "2009-05-05T13:45:37.030"
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1198.console"></div>
<p>The following request can be built that connects the two together:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST child_example/_search?size=0
{
  "aggs": {
    "top-tags": {
      "terms": {
        "field": "tags.keyword",
        "size": 10
      },
      "aggs": {
        "to-answers": {
          "children": {
            "type" : "answer" <a id="CO261-1"></a><i class="conum" data-value="1"></i>
          },
          "aggs": {
            "top-names": {
              "terms": {
                "field": "owner.display_name.keyword",
                "size": 10
              }
            }
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1199.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO261-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">type</code> points to type / mapping with the name <code class="literal">answer</code>.</p>
</td>
</tr>
</table>
</div>
<p>The above example returns the top question tags and per tag the top answer owners.</p>
<p>Possible response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "took": 25,
  "timed_out": false,
  "_shards": {
    "total": 1,
    "successful": 1,
    "skipped" : 0,
    "failed": 0
  },
  "hits": {
    "total" : {
      "value": 3,
      "relation": "eq"
    },
    "max_score": null,
    "hits": []
  },
  "aggregations": {
    "top-tags": {
      "doc_count_error_upper_bound": 0,
      "sum_other_doc_count": 0,
      "buckets": [
        {
          "key": "file-transfer",
          "doc_count": 1, <a id="CO262-1"></a><i class="conum" data-value="1"></i>
          "to-answers": {
            "doc_count": 2, <a id="CO262-2"></a><i class="conum" data-value="2"></i>
            "top-names": {
              "doc_count_error_upper_bound": 0,
              "sum_other_doc_count": 0,
              "buckets": [
                {
                  "key": "Sam",
                  "doc_count": 1
                },
                {
                  "key": "Troll",
                  "doc_count": 1
                }
              ]
            }
          }
        },
        {
          "key": "windows-server-2003",
          "doc_count": 1, <a id="CO262-3"></a><i class="conum" data-value="1"></i>
          "to-answers": {
            "doc_count": 2, <a id="CO262-4"></a><i class="conum" data-value="2"></i>
            "top-names": {
              "doc_count_error_upper_bound": 0,
              "sum_other_doc_count": 0,
              "buckets": [
                {
                  "key": "Sam",
                  "doc_count": 1
                },
                {
                  "key": "Troll",
                  "doc_count": 1
                }
              ]
            }
          }
        },
        {
          "key": "windows-server-2008",
          "doc_count": 1, <a id="CO262-5"></a><i class="conum" data-value="1"></i>
          "to-answers": {
            "doc_count": 2, <a id="CO262-6"></a><i class="conum" data-value="2"></i>
            "top-names": {
              "doc_count_error_upper_bound": 0,
              "sum_other_doc_count": 0,
              "buckets": [
                {
                  "key": "Sam",
                  "doc_count": 1
                },
                {
                  "key": "Troll",
                  "doc_count": 1
                }
              ]
            }
          }
        }
      ]
    }
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO262-1"><i class="conum" data-value="1"></i></a><a href="#CO262-3"></a><a href="#CO262-5"></a></p>
</td>
<td align="left" valign="top">
<p>The number of question documents with the tag <code class="literal">file-transfer</code>, <code class="literal">windows-server-2003</code>, etc.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO262-2"><i class="conum" data-value="2"></i></a><a href="#CO262-4"></a><a href="#CO262-6"></a></p>
</td>
<td align="left" valign="top">
<p>The number of answer documents that are related to question documents with the tag <code class="literal">file-transfer</code>, <code class="literal">windows-server-2003</code>, etc.</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-composite-aggregation"></a>Composite aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/composite-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>The composite aggregation is expensive. Load test your application
before deploying a composite aggregation in production.</p>
</div>
</div>
<p>A multi-bucket aggregation that creates composite buckets from different sources.</p>
<p>Unlike the other <code class="literal">multi-bucket</code> aggregations, you can use the <code class="literal">composite</code>
aggregation to paginate <span class="strong strong"><strong>all</strong></span> buckets from a multi-level aggregation
efficiently. This aggregation provides a way to stream <span class="strong strong"><strong>all</strong></span> buckets of a
specific aggregation, similar to what
<a class="xref" href="paginate-search-results.html#scroll-search-results" title="Scroll search results">scroll</a> does for documents.</p>
<p>The composite buckets are built from the combinations of the
values extracted/created for each document and each combination is considered as
a composite bucket.</p>
<p>For example, consider the following document:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "keyword": ["foo", "bar"],
  "number": [23, 65, 76]
}</pre>
</div>
<p>Using <code class="literal">keyword</code> and <code class="literal">number</code> as source fields for the aggregation results in
the following composite buckets:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{ "keyword": "foo", "number": 23 }
{ "keyword": "foo", "number": 65 }
{ "keyword": "foo", "number": 76 }
{ "keyword": "bar", "number": 23 }
{ "keyword": "bar", "number": 65 }
{ "keyword": "bar", "number": 76 }</pre>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_value_sources"></a>Value sources<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/composite-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">sources</code> parameter defines the source fields to use when building
composite buckets. The order that the <code class="literal">sources</code> are defined controls the order
that the keys are returned.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>You must use a unique name when defining <code class="literal">sources</code>.</p>
</div>
</div>
<p>The <code class="literal">sources</code> parameter can be any of the following types:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<a class="xref" href="search-aggregations-bucket.html#_terms" title="Terms">Terms</a>
</li>
<li class="listitem">
<a class="xref" href="search-aggregations-bucket.html#_histogram" title="Histogram">Histogram</a>
</li>
<li class="listitem">
<a class="xref" href="search-aggregations-bucket.html#_date_histogram" title="Date histogram">Date histogram</a>
</li>
<li class="listitem">
<a class="xref" href="search-aggregations-bucket.html#_geotile_grid" title="GeoTile grid">GeoTile grid</a>
</li>
</ul>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_terms"></a>Terms<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/composite-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>The <code class="literal">terms</code> value source is similar to a simple <code class="literal">terms</code> aggregation.
The values are extracted from a field exactly like the <code class="literal">terms</code> aggregation.</p>
<p>Example:</p>
<a id="composite-aggregation-terms-field-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          { "product": { "terms": { "field": "product" } } }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1200.console"></div>
<p>Like the <code class="literal">terms</code> aggregation, it&#8217;s possible to use a
<a class="xref" href="runtime.html" title="Runtime fields">runtime field</a> to create values for the composite buckets:</p>
<a id="composite-aggregation-terms-runtime-field-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "runtime_mappings": {
    "day_of_week": {
      "type": "keyword",
      "script": """
        emit(doc['timestamp'].value.dayOfWeekEnum
          .getDisplayName(TextStyle.FULL, Locale.ROOT))
      """
    }
  },
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          {
            "dow": {
              "terms": { "field": "day_of_week" }
            }
          }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1201.console"></div>
<p>Although similar, the <code class="literal">terms</code> value source doesn&#8217;t support the same set of
parameters as the <code class="literal">terms</code> aggregation. For other supported value source
parameters, see:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<a class="xref" href="search-aggregations-bucket.html#_order" title="Order">Order</a>
</li>
<li class="listitem">
<a class="xref" href="search-aggregations-bucket.html#_missing_bucket" title="Missing bucket">Missing bucket</a>
</li>
</ul>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_histogram"></a>Histogram<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/composite-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>The <code class="literal">histogram</code> value source can be applied on numeric values to build fixed size
interval over the values. The <code class="literal">interval</code> parameter defines how the numeric values should be
transformed. For instance an <code class="literal">interval</code> set to 5 will translate any numeric values to its closest interval,
a value of <code class="literal">101</code> would be translated to <code class="literal">100</code> which is the key for the interval between 100 and 105.</p>
<p>Example:</p>
<a id="composite-aggregation-histogram-field-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          { "histo": { "histogram": { "field": "price", "interval": 5 } } }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1202.console"></div>
<p>Like the <code class="literal">histogram</code> aggregation it&#8217;s possible to use a
<a class="xref" href="runtime.html" title="Runtime fields">runtime field</a> to create values for the composite buckets:</p>
<a id="composite-aggregation-histogram-runtime-field-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "runtime_mappings": {
    "price.discounted": {
      "type": "double",
      "script": """
        double price = doc['price'].value;
        if (doc['product'].value == 'mad max') {
          price *= 0.8;
        }
        emit(price);
      """
    }
  },
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          {
            "price": {
              "histogram": {
                "interval": 5,
                "field": "price.discounted"
              }
            }
          }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1203.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_date_histogram"></a>Date histogram<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/composite-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>The <code class="literal">date_histogram</code> is similar to the <code class="literal">histogram</code> value source except that the interval
is specified by date/time expression:</p>
<a id="composite-aggregation-datehistogram-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          { "date": { "date_histogram": { "field": "timestamp", "calendar_interval": "1d" } } }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1204.console"></div>
<p>The example above creates an interval per day and translates all <code class="literal">timestamp</code> values to the start of its closest intervals.
Available expressions for interval: <code class="literal">year</code>, <code class="literal">quarter</code>, <code class="literal">month</code>, <code class="literal">week</code>, <code class="literal">day</code>, <code class="literal">hour</code>, <code class="literal">minute</code>, <code class="literal">second</code></p>
<p>Time values can also be specified via abbreviations supported by <a class="xref" href="api-conventions.html#time-units" title="Time units">time units</a> parsing.
Note that fractional time values are not supported, but you can address this by shifting to another
time unit (e.g., <code class="literal">1.5h</code> could instead be specified as <code class="literal">90m</code>).</p>
<p><span class="strong strong"><strong>Format</strong></span></p>
<p>Internally, a date is represented as a 64 bit number representing a timestamp in milliseconds-since-the-epoch.
These timestamps are returned as the bucket keys. It is possible to return a formatted date string instead using
the format specified with the format parameter:</p>
<a id="composite-aggregation-datehistogram-format-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          {
            "date": {
              "date_histogram": {
                "field": "timestamp",
                "calendar_interval": "1d",
                "format": "yyyy-MM-dd"         <a id="CO263-1"></a><i class="conum" data-value="1"></i>
              }
            }
          }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1205.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO263-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Supports expressive date <a class="xref" href="search-aggregations-bucket.html#date-format-pattern" title="Date Format/Pattern">format pattern</a></p>
</td>
</tr>
</table>
</div>
<p><span class="strong strong"><strong>Time Zone</strong></span></p>
<p>Date-times are stored in Elasticsearch in UTC. By default, all bucketing and
rounding is also done in UTC. The <code class="literal">time_zone</code> parameter can be used to indicate
that bucketing should use a different time zone.</p>
<p>Time zones may either be specified as an ISO 8601 UTC offset (e.g. <code class="literal">+01:00</code> or
<code class="literal">-08:00</code>)  or as a timezone id, an identifier used in the TZ database like
<code class="literal">America/Los_Angeles</code>.</p>
<p><span class="strong strong"><strong>Offset</strong></span></p>
<p>Use the <code class="literal">offset</code> parameter to change the start value of each bucket by the
specified positive (<code class="literal">+</code>) or negative offset (<code class="literal">-</code>) duration, such as <code class="literal">1h</code> for
an hour, or <code class="literal">1d</code> for a day. See <a class="xref" href="api-conventions.html#time-units" title="Time units">Time units</a> for more possible time
duration options.</p>
<p>For example, when using an interval of <code class="literal">day</code>, each bucket runs from midnight
to midnight. Setting the <code class="literal">offset</code> parameter to <code class="literal">+6h</code> changes each bucket
to run from 6am to 6am:</p>
<a id="composite-aggregation-datehistogram-offset-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT my-index-000001/_doc/1?refresh
{
  "date": "2015-10-01T05:30:00Z"
}

PUT my-index-000001/_doc/2?refresh
{
  "date": "2015-10-01T06:30:00Z"
}

GET my-index-000001/_search?size=0
{
  "aggs": {
    "my_buckets": {
      "composite" : {
        "sources" : [
          {
            "date": {
              "date_histogram" : {
                "field": "date",
                "calendar_interval": "day",
                "offset": "+6h",
                "format": "iso8601"
              }
            }
          }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1206.console"></div>
<p>Instead of a single bucket starting at midnight, the above request groups the
documents into buckets starting at 6am:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "my_buckets": {
      "after_key": { "date": "2015-10-01T06:00:00.000Z" },
      "buckets": [
        {
          "key": { "date": "2015-09-30T06:00:00.000Z" },
          "doc_count": 1
        },
        {
          "key": { "date": "2015-10-01T06:00:00.000Z" },
          "doc_count": 1
        }
      ]
    }
  }
}</pre>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>The start <code class="literal">offset</code> of each bucket is calculated after <code class="literal">time_zone</code>
adjustments have been made.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_geotile_grid"></a>GeoTile grid<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/composite-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>The <code class="literal">geotile_grid</code> value source works on <code class="literal">geo_point</code> fields and groups points into buckets that represent
cells in a grid. The resulting grid can be sparse and only contains cells
that have matching data. Each cell corresponds to a
<a href="https://en.wikipedia.org/wiki/Tiled_web_map" class="ulink" target="_top">map tile</a> as used by many online map
sites. Each cell is labeled using a "{zoom}/{x}/{y}" format, where zoom is equal
to the user-specified precision.</p>
<a id="composite-aggregation-geotilegrid-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          { "tile": { "geotile_grid": { "field": "location", "precision": 8 } } }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1207.console"></div>
<p><span class="strong strong"><strong>Precision</strong></span></p>
<p>The highest-precision geotile of length 29 produces cells that cover
less than 10cm by 10cm of land. This precision is uniquely suited for composite aggregations as each
tile does not have to be generated and loaded in memory.</p>
<p>See <a href="https://wiki.openstreetmap.org/wiki/Zoom_levels" class="ulink" target="_top">Zoom level documentation</a>
on how precision (zoom) correlates to size on the ground. Precision for this
aggregation can be between 0 and 29, inclusive.</p>
<p><span class="strong strong"><strong>Bounding box filtering</strong></span></p>
<p>The geotile source can optionally be constrained to a specific geo bounding box, which reduces
the range of tiles used. These bounds are useful when only a specific part of a geographical area needs high
precision tiling.</p>
<a id="composite-aggregation-geotilegrid-boundingbox-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          {
            "tile": {
              "geotile_grid": {
                "field": "location",
                "precision": 22,
                "bounds": {
                  "top_left": "POINT (4.9 52.4)",
                  "bottom_right": "POINT (5.0 52.3)"
                }
              }
            }
          }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1208.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_mixing_different_value_sources"></a>Mixing different value sources<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/composite-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>The <code class="literal">sources</code> parameter accepts an array of value sources.
It is possible to mix different value sources to create composite buckets.
For example:</p>
<a id="composite-aggregation-mixing-sources-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          { "date": { "date_histogram": { "field": "timestamp", "calendar_interval": "1d" } } },
          { "product": { "terms": { "field": "product" } } }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1209.console"></div>
<p>This will create composite buckets from the values created by two value sources, a <code class="literal">date_histogram</code> and a <code class="literal">terms</code>.
Each bucket is composed of two values, one for each value source defined in the aggregation.
Any type of combinations is allowed and the order in the array is preserved
in the composite buckets.</p>
<a id="composite-aggregation-mixing-three-sources-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          { "shop": { "terms": { "field": "shop" } } },
          { "product": { "terms": { "field": "product" } } },
          { "date": { "date_histogram": { "field": "timestamp", "calendar_interval": "1d" } } }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1210.console"></div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_order"></a>Order<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/composite-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>By default the composite buckets are sorted by their natural ordering. Values are sorted
in ascending order of their values. When multiple value sources are requested, the ordering is done per value
source, the first value of the composite bucket is compared to the first value of the other composite bucket and if they are equals the
next values in the composite bucket are used for tie-breaking. This means that the composite bucket
 <code class="literal">[foo, 100]</code> is considered smaller than <code class="literal">[foobar, 0]</code> because <code class="literal">foo</code> is considered smaller than <code class="literal">foobar</code>.
It is possible to define the direction of the sort for each value source by setting <code class="literal">order</code> to <code class="literal">asc</code> (default value)
or <code class="literal">desc</code> (descending order) directly in the value source definition.
For example:</p>
<a id="composite-aggregation-order-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          { "date": { "date_histogram": { "field": "timestamp", "calendar_interval": "1d", "order": "desc" } } },
          { "product": { "terms": { "field": "product", "order": "asc" } } }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1211.console"></div>
<p>... will sort the composite bucket in descending order when comparing values from the <code class="literal">date_histogram</code> source
and in ascending order when comparing values from the <code class="literal">terms</code> source.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_missing_bucket"></a>Missing bucket<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/composite-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>By default documents without a value for a given source are ignored.
It is possible to include them in the response by setting <code class="literal">missing_bucket</code> to
<code class="literal">true</code> (defaults to <code class="literal">false</code>):</p>
<a id="composite-aggregation-missing-bucket-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [{
          "product_name": {
            "terms": {
              "field": "product",
              "missing_bucket": true,
              "missing_order": "last"
            }
          }
        }]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1212.console"></div>
<p>In the above example, the <code class="literal">product_name</code> source emits an explicit <code class="literal">null</code> bucket
for documents without a <code class="literal">product</code> value. This bucket is placed last.</p>
<p>You can control the position of the <code class="literal">null</code> bucket using the optional
<code class="literal">missing_order</code> parameter. If <code class="literal">missing_order</code> is <code class="literal">first</code> or <code class="literal">last</code>, the <code class="literal">null</code>
bucket is placed in the respective first or last position. If <code class="literal">missing_order</code> is
omitted or <code class="literal">default</code>, the source&#8217;s <code class="literal">order</code> determines the bucket&#8217;s position. If
<code class="literal">order</code> is <code class="literal">asc</code> (ascending), the bucket is in the first position. If <code class="literal">order</code> is
<code class="literal">desc</code> (descending), the bucket is in the last position.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_size"></a>Size<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/composite-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">size</code> parameter can be set to define how many composite buckets should be returned.
Each composite bucket is considered as a single bucket, so setting a size of 10 will return the
first 10 composite buckets created from the value sources.
The response contains the values for each composite bucket in an array containing the values extracted
from each value source. Defaults to <code class="literal">10</code>.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_pagination"></a>Pagination<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/composite-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>If the number of composite buckets is too high (or unknown) to be returned in a single response
it is possible to split the retrieval in multiple requests.
Since the composite buckets are flat by nature, the requested <code class="literal">size</code> is exactly the number of composite buckets
that will be returned in the response (assuming that they are at least <code class="literal">size</code> composite buckets to return).
If all composite buckets should be retrieved it is preferable to use a small size (<code class="literal">100</code> or <code class="literal">1000</code> for instance)
and then use the <code class="literal">after</code> parameter to retrieve the next results.
For example:</p>
<a id="composite-aggregation-after-key-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "size": 2,
        "sources": [
          { "date": { "date_histogram": { "field": "timestamp", "calendar_interval": "1d" } } },
          { "product": { "terms": { "field": "product" } } }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1213.console"></div>
<p>... returns:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "my_buckets": {
      "after_key": {
        "date": 1494288000000,
        "product": "mad max"
      },
      "buckets": [
        {
          "key": {
            "date": 1494201600000,
            "product": "rocky"
          },
          "doc_count": 1
        },
        {
          "key": {
            "date": 1494288000000,
            "product": "mad max"
          },
          "doc_count": 2
        }
      ]
    }
  }
}</pre>
</div>
<p>To get the next set of buckets, resend the same aggregation with the <code class="literal">after</code>
parameter set to the <code class="literal">after_key</code> value returned in the response.
For example, this request uses the <code class="literal">after_key</code> value provided in the previous response:</p>
<a id="composite-aggregation-after-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "size": 2,
        "sources": [
          { "date": { "date_histogram": { "field": "timestamp", "calendar_interval": "1d", "order": "desc" } } },
          { "product": { "terms": { "field": "product", "order": "asc" } } }
        ],
        "after": { "date": 1494288000000, "product": "mad max" } <a id="CO264-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1214.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO264-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Should restrict the aggregation to buckets that sort <span class="strong strong"><strong>after</strong></span> the provided values.</p>
</td>
</tr>
</table>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>The <code class="literal">after_key</code> is <span class="strong strong"><strong>usually</strong></span> the key to the last bucket returned in
the response, but that isn&#8217;t guaranteed. Always use the returned <code class="literal">after_key</code> instead
of deriving it from the buckets.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_early_termination"></a>Early termination<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/composite-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>For optimal performance the <a class="xref" href="index-modules-index-sorting.html" title="Index Sorting">index sort</a> should be set on the index so that it matches
parts or fully the source order in the composite aggregation.
For instance the following index sort:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT my-index-000001
{
  "settings": {
    "index": {
      "sort.field": [ "username", "timestamp" ],   <a id="CO265-1"></a><i class="conum" data-value="1"></i>
      "sort.order": [ "asc", "desc" ]              <a id="CO265-2"></a><i class="conum" data-value="2"></i>
    }
  },
  "mappings": {
    "properties": {
      "username": {
        "type": "keyword",
        "doc_values": true
      },
      "timestamp": {
        "type": "date"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1215.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO265-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>This index is sorted by <code class="literal">username</code> first then by <code class="literal">timestamp</code>.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO265-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>&#8230;&#8203; in ascending order for the <code class="literal">username</code> field and in descending order for the <code class="literal">timestamp</code> field.</p>
<div class="olist orderedlist">
<ol class="orderedlist">
<li class="listitem">
could be used to optimize these composite aggregations:
</li>
</ol>
</div>
</td>
</tr>
</table>
</div>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          { "user_name": { "terms": { "field": "user_name" } } }     <a id="CO266-1"></a><i class="conum" data-value="1"></i>
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1216.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO266-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p><code class="literal">user_name</code> is a prefix of the index sort and the order matches (<code class="literal">asc</code>).</p>
</td>
</tr>
</table>
</div>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          { "user_name": { "terms": { "field": "user_name" } } }, <a id="CO267-1"></a><i class="conum" data-value="1"></i>
          { "date": { "date_histogram": { "field": "timestamp", "calendar_interval": "1d", "order": "desc" } } } <a id="CO267-2"></a><i class="conum" data-value="2"></i>
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1217.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO267-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p><code class="literal">user_name</code> is a prefix of the index sort and the order matches (<code class="literal">asc</code>).</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO267-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p><code class="literal">timestamp</code> matches also the prefix and the order matches (<code class="literal">desc</code>).</p>
</td>
</tr>
</table>
</div>
<p>In order to optimize the early termination it is advised to set <code class="literal">track_total_hits</code> in the request
to <code class="literal">false</code>. The number of total hits that match the request can be retrieved on the first request
and it would be costly to compute this number on every page:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "size": 0,
  "track_total_hits": false,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          { "user_name": { "terms": { "field": "user_name" } } },
          { "date": { "date_histogram": { "field": "timestamp", "calendar_interval": "1d", "order": "desc" } } }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1218.console"></div>
<p>Note that the order of the source is important, in the example below switching the <code class="literal">user_name</code> with the <code class="literal">timestamp</code>
would deactivate the sort optimization since this configuration wouldn&#8217;t match the index sort specification.
If the order of sources do not matter for your use case you can follow these simple guidelines:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Put the fields with the highest cardinality first.
</li>
<li class="listitem">
Make sure that the order of the field matches the order of the index sort.
</li>
<li class="listitem">
Put multi-valued fields last since they cannot be used for early termination.
</li>
</ul>
</div>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p><a class="xref" href="index-modules-index-sorting.html" title="Index Sorting">index sort</a> can slowdown indexing, it is very important to test index sorting
with your specific use case and dataset to ensure that it matches your requirement. If it doesn&#8217;t note that <code class="literal">composite</code>
aggregations will also try to early terminate on non-sorted indices if the query matches all document (<code class="literal">match_all</code> query).</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_sub_aggregations"></a>Sub-aggregations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/composite-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Like any <code class="literal">multi-bucket</code> aggregations the <code class="literal">composite</code> aggregation can hold sub-aggregations.
These sub-aggregations can be used to compute other buckets or statistics on each composite bucket created by this
parent aggregation.
For instance the following example computes the average value of a field
per composite bucket:</p>
<a id="composite-aggregation-subaggregations-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          { "date": { "date_histogram": { "field": "timestamp", "calendar_interval": "1d", "order": "desc" } } },
          { "product": { "terms": { "field": "product" } } }
        ]
      },
      "aggregations": {
        "the_avg": {
          "avg": { "field": "price" }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1219.console"></div>
<p>... returns:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "my_buckets": {
      "after_key": {
        "date": 1494201600000,
        "product": "rocky"
      },
      "buckets": [
        {
          "key": {
            "date": 1494460800000,
            "product": "apocalypse now"
          },
          "doc_count": 1,
          "the_avg": {
            "value": 10.0
          }
        },
        {
          "key": {
            "date": 1494374400000,
            "product": "mad max"
          },
          "doc_count": 1,
          "the_avg": {
            "value": 27.0
          }
        },
        {
          "key": {
            "date": 1494288000000,
            "product": "mad max"
          },
          "doc_count": 2,
          "the_avg": {
            "value": 22.5
          }
        },
        {
          "key": {
            "date": 1494201600000,
            "product": "rocky"
          },
          "doc_count": 1,
          "the_avg": {
            "value": 10.0
          }
        }
      ]
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-bucket-composite-aggregation-pipeline-aggregations"></a>Pipeline aggregations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/composite-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The composite agg is not currently compatible with pipeline aggregations, nor does it make sense in most cases.
E.g. due to the paging nature of composite aggs, a single logical partition (one day for example) might be spread
over multiple pages. Since pipeline aggregations are purely post-processing on the final list of buckets,
running something like a derivative on a composite page could lead to inaccurate results as it is only taking into
account a "partial" result on that page.</p>
<p>Pipeline aggs that are self contained to a single bucket (such as <code class="literal">bucket_selector</code>) might be supported in the future.</p>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-datehistogram-aggregation"></a>Date histogram aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/datehistogram-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>This multi-bucket aggregation is similar to the normal
<a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-histogram-aggregation" title="Histogram aggregation">histogram</a>, but it can
only be used with date or date range values. Because dates are represented internally in
Elasticsearch as long values, it is possible, but not as accurate, to use the
normal <code class="literal">histogram</code> on dates as well. The main difference in the two APIs is
that here the interval can be specified using date/time expressions. Time-based
data requires special support because time-based intervals are not always a
fixed length.</p>
<p>Like the histogram, values are rounded <span class="strong strong"><strong>down</strong></span> into the closest bucket. For
example, if the interval is a calendar day, <code class="literal">2020-01-03T07:00:01Z</code> is rounded to
<code class="literal">2020-01-03T00:00:00Z</code>. Values are rounded as follows:</p>
<div class="pre_wrapper lang-java">
<pre class="programlisting prettyprint lang-java">bucket_key = Math.floor(value / interval) * interval</pre>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="calendar_and_fixed_intervals"></a>Calendar and fixed intervals<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/datehistogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>When configuring a date histogram aggregation, the interval can be specified
in two manners: calendar-aware time intervals, and fixed time intervals.</p>
<p>Calendar-aware intervals understand that daylight savings changes the length
of specific days, months have different amounts of days, and leap seconds can
be tacked onto a particular year.</p>
<p>Fixed intervals are, by contrast, always multiples of SI units and do not change
based on calendaring context.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="calendar_intervals"></a>Calendar intervals<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/datehistogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Calendar-aware intervals are configured with the <code class="literal">calendar_interval</code> parameter.
You can specify calendar intervals using the unit name, such as <code class="literal">month</code>, or as a
single unit quantity, such as <code class="literal">1M</code>. For example, <code class="literal">day</code> and <code class="literal">1d</code> are equivalent.
Multiple quantities, such as <code class="literal">2d</code>, are not supported.</p>
<p>The accepted calendar intervals are:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">minute</code>, <code class="literal">1m</code>
</span>
</dt>
<dd>
All minutes begin at 00 seconds.
One minute is the interval between 00 seconds of the first minute and 00
seconds of the following minute in the specified time zone, compensating for any
intervening leap seconds, so that the number of minutes and seconds past the
hour is the same at the start and end.
</dd>
<dt>
<span class="term">
<code class="literal">hour</code>, <code class="literal">1h</code>
</span>
</dt>
<dd>
All hours begin at 00 minutes and 00 seconds.
One hour (1h) is the interval between 00:00 minutes of the first hour and 00:00
minutes of the following hour in the specified time zone, compensating for any
intervening leap seconds, so that the number of minutes and seconds past the hour
is the same at the start and end.
</dd>
<dt>
<span class="term">
<code class="literal">day</code>, <code class="literal">1d</code>
</span>
</dt>
<dd>
All days begin at the earliest possible time, which is usually 00:00:00
(midnight).
One day (1d) is the interval between the start of the day and the start of
the following day in the specified time zone, compensating for any intervening
time changes.
</dd>
<dt>
<span class="term">
<code class="literal">week</code>, <code class="literal">1w</code>
</span>
</dt>
<dd>
One week is the interval between the start day_of_week:hour:minute:second
and the same day of the week and time of the following week in the specified
time zone.
</dd>
<dt>
<span class="term">
<code class="literal">month</code>, <code class="literal">1M</code>
</span>
</dt>
<dd>
One month is the interval between the start day of the month and time of
day and the same day of the month and time of the following month in the specified
time zone, so that the day of the month and time of day are the same at the start
and end. Note that the day may differ if an
<a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-datehistogram-offset-months" title="Long offsets over calendar intervals"><code class="literal">offset</code> is used that is longer than a month</a>.
</dd>
<dt>
<span class="term">
<code class="literal">quarter</code>, <code class="literal">1q</code>
</span>
</dt>
<dd>
One quarter is the interval between the start day of the month and
time of day and the same day of the month and time of day three months later,
so that the day of the month and time of day are the same at the start and end.<br>
</dd>
<dt>
<span class="term">
<code class="literal">year</code>, <code class="literal">1y</code>
</span>
</dt>
<dd>
One year is the interval between the start day of the month and time of
day and the same day of the month and time of day the following year in the
specified time zone, so that the date and time are the same at the start and end.<br>
</dd>
</dl>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="calendar_interval_examples"></a>Calendar interval examples<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/datehistogram-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>As an example, here is an aggregation requesting bucket intervals of a month in calendar time:</p>
<a id="datehistogram-aggregation-calendar-interval-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "sales_over_time": {
      "date_histogram": {
        "field": "date",
        "calendar_interval": "month"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1220.console"></div>
<p>If you attempt to use multiples of calendar units, the aggregation will fail because only
singular calendar units are supported:</p>
<a id="datehistogram-aggregation-calendar-interval-multiples-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "sales_over_time": {
      "date_histogram": {
        "field": "date",
        "calendar_interval": "2d"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1221.console"></div>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "error" : {
    "root_cause" : [...],
    "type" : "x_content_parse_exception",
    "reason" : "[1:82] [date_histogram] failed to parse field [calendar_interval]",
    "caused_by" : {
      "type" : "illegal_argument_exception",
      "reason" : "The supplied interval [2d] could not be parsed as a calendar interval.",
      "stack_trace" : "java.lang.IllegalArgumentException: The supplied interval [2d] could not be parsed as a calendar interval."
    }
  }
}</pre>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="fixed_intervals"></a>Fixed intervals<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/datehistogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Fixed intervals are configured with the <code class="literal">fixed_interval</code> parameter.</p>
<p>In contrast to calendar-aware intervals, fixed intervals are a fixed number of SI
units and never deviate, regardless of where they fall on the calendar. One second
is always composed of <code class="literal">1000ms</code>. This allows fixed intervals to be specified in
any multiple of the supported units.</p>
<p>However, it means fixed intervals cannot express other units such as months,
since the duration of a month is not a fixed quantity. Attempting to specify
a calendar interval like month or quarter will throw an exception.</p>
<p>The accepted units for fixed intervals are:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
milliseconds (<code class="literal">ms</code>)
</span>
</dt>
<dd>
A single millisecond. This is a very, very small interval.
</dd>
<dt>
<span class="term">
seconds (<code class="literal">s</code>)
</span>
</dt>
<dd>
Defined as 1000 milliseconds each.
</dd>
<dt>
<span class="term">
minutes (<code class="literal">m</code>)
</span>
</dt>
<dd>
Defined as 60 seconds each (60,000 milliseconds).
All minutes begin at 00 seconds.
</dd>
<dt>
<span class="term">
hours (<code class="literal">h</code>)
</span>
</dt>
<dd>
Defined as 60 minutes each (3,600,000 milliseconds).
All hours begin at 00 minutes and 00 seconds.
</dd>
<dt>
<span class="term">
days (<code class="literal">d</code>)
</span>
</dt>
<dd>
Defined as 24 hours (86,400,000 milliseconds).
All days begin at the earliest possible time, which is usually 00:00:00
(midnight).
</dd>
</dl>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="fixed_interval_examples"></a>Fixed interval examples<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/datehistogram-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>If we try to recreate the "month" <code class="literal">calendar_interval</code> from earlier, we can approximate that with
30 fixed days:</p>
<a id="datehistogram-aggregation-fixed-interval-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "sales_over_time": {
      "date_histogram": {
        "field": "date",
        "fixed_interval": "30d"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1222.console"></div>
<p>But if we try to use a calendar unit that is not supported, such as weeks, we&#8217;ll get an exception:</p>
<a id="datehistogram-aggregation-fixed-interval-unsupported-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "sales_over_time": {
      "date_histogram": {
        "field": "date",
        "fixed_interval": "2w"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1223.console"></div>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "error" : {
    "root_cause" : [...],
    "type" : "x_content_parse_exception",
    "reason" : "[1:82] [date_histogram] failed to parse field [fixed_interval]",
    "caused_by" : {
      "type" : "illegal_argument_exception",
      "reason" : "failed to parse setting [date_histogram.fixedInterval] with value [2w] as a time value: unit is missing or unrecognized",
      "stack_trace" : "java.lang.IllegalArgumentException: failed to parse setting [date_histogram.fixedInterval] with value [2w] as a time value: unit is missing or unrecognized"
    }
  }
}</pre>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="datehistogram-aggregation-notes"></a>Date histogram usage notes<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/datehistogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>In all cases, when the specified end time does not exist, the actual end time is
the closest available time after the specified end.</p>
<p>Widely distributed applications must also consider vagaries such as countries that
start and stop daylight savings time at 12:01 A.M., so end up with one minute of
Sunday followed by an additional 59 minutes of Saturday once a year, and countries
that decide to move across the international date line. Situations like
that can make irregular time zone offsets seem easy.</p>
<p>As always, rigorous testing, especially around time-change events, will ensure
that your time interval specification is
what you intend it to be.</p>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>To avoid unexpected results, all connected servers and clients must
sync to a reliable network time service.</p>
</div>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>Fractional time values are not supported, but you can address this by
shifting to another time unit (e.g., <code class="literal">1.5h</code> could instead be specified as <code class="literal">90m</code>).</p>
</div>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>You can also specify time values using abbreviations supported by
<a class="xref" href="api-conventions.html#time-units" title="Time units">time units</a> parsing.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="datehistogram-aggregation-keys"></a>Keys<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/datehistogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Internally, a date is represented as a 64 bit number representing a timestamp
in milliseconds-since-the-epoch (01/01/1970 midnight UTC). These timestamps are
returned as the <code class="literal">key</code> name of the bucket. The <code class="literal">key_as_string</code> is the same
timestamp converted to a formatted
date string using the <code class="literal">format</code> parameter specification:</p>
<div class="tip admon">
<div class="icon"></div>
<div class="admon_content">
<p>If you don&#8217;t specify <code class="literal">format</code>, the first date
<a class="xref" href="mapping-params.html#mapping-date-format" title="format">format</a> specified in the field mapping is used.</p>
</div>
</div>
<a id="datehistogram-aggregation-format-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "sales_over_time": {
      "date_histogram": {
        "field": "date",
        "calendar_interval": "1M",
        "format": "yyyy-MM-dd" <a id="CO268-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1224.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO268-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Supports expressive date <a class="xref" href="search-aggregations-bucket.html#date-format-pattern" title="Date Format/Pattern">format pattern</a></p>
</td>
</tr>
</table>
</div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "sales_over_time": {
      "buckets": [
        {
          "key_as_string": "2015-01-01",
          "key": 1420070400000,
          "doc_count": 3
        },
        {
          "key_as_string": "2015-02-01",
          "key": 1422748800000,
          "doc_count": 2
        },
        {
          "key_as_string": "2015-03-01",
          "key": 1425168000000,
          "doc_count": 2
        }
      ]
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="datehistogram-aggregation-time-zone"></a>Time zone<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/datehistogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Elasticsearch stores date-times in Coordinated Universal Time (UTC). By default, all bucketing and
rounding is also done in UTC. Use the <code class="literal">time_zone</code> parameter to indicate
that bucketing should use a different time zone.</p>
<p>For example, if the interval is a calendar day and the time zone is
<code class="literal">America/New_York</code> then <code class="literal">2020-01-03T01:00:01Z</code> is :
# Converted to <code class="literal">2020-01-02T18:00:01</code>
# Rounded down to <code class="literal">2020-01-02T00:00:00</code>
# Then converted back to UTC to produce <code class="literal">2020-01-02T05:00:00:00Z</code>
# Finally, when the bucket is turned into a string key it is printed in
  <code class="literal">America/New_York</code> so it&#8217;ll display as <code class="literal">"2020-01-02T00:00:00"</code>.</p>
<p>It looks like:</p>
<div class="pre_wrapper lang-java">
<pre class="programlisting prettyprint lang-java">bucket_key = localToUtc(Math.floor(utcToLocal(value) / interval) * interval))</pre>
</div>
<p>You can specify time zones as an ISO 8601 UTC offset (e.g. <code class="literal">+01:00</code> or
<code class="literal">-08:00</code>) or as an IANA time zone ID,
such as <code class="literal">America/Los_Angeles</code>.</p>
<p>Consider the following example:</p>
<a id="datehistogram-aggregation-timezone-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT my-index-000001/_doc/1?refresh
{
  "date": "2015-10-01T00:30:00Z"
}

PUT my-index-000001/_doc/2?refresh
{
  "date": "2015-10-01T01:30:00Z"
}

GET my-index-000001/_search?size=0
{
  "aggs": {
    "by_day": {
      "date_histogram": {
        "field":     "date",
        "calendar_interval":  "day"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1225.console"></div>
<p>If you don&#8217;t specify a time zone, UTC is used. This would result in both of these
documents being placed into the same day bucket, which starts at midnight UTC
on 1 October 2015:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "by_day": {
      "buckets": [
        {
          "key_as_string": "2015-10-01T00:00:00.000Z",
          "key":           1443657600000,
          "doc_count":     2
        }
      ]
    }
  }
}</pre>
</div>
<p>If you specify a <code class="literal">time_zone</code> of <code class="literal">-01:00</code>, midnight in that time zone is one hour
before midnight UTC:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET my-index-000001/_search?size=0
{
  "aggs": {
    "by_day": {
      "date_histogram": {
        "field":     "date",
        "calendar_interval":  "day",
        "time_zone": "-01:00"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1226.console"></div>
<p>Now the first document falls into the bucket for 30 September 2015, while the
second document falls into the bucket for 1 October 2015:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "by_day": {
      "buckets": [
        {
          "key_as_string": "2015-09-30T00:00:00.000-01:00", <a id="CO269-1"></a><i class="conum" data-value="1"></i>
          "key": 1443574800000,
          "doc_count": 1
        },
        {
          "key_as_string": "2015-10-01T00:00:00.000-01:00", <a id="CO269-2"></a><i class="conum" data-value="1"></i>
          "key": 1443661200000,
          "doc_count": 1
        }
      ]
    }
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO269-1"><i class="conum" data-value="1"></i></a><a href="#CO269-2"></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">key_as_string</code> value represents midnight on each day
in the specified time zone.</p>
</td>
</tr>
</table>
</div>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>Many time zones shift their clocks for daylight savings time. Buckets
close to the moment when those changes happen can have slightly different sizes
than you would expect from the <code class="literal">calendar_interval</code> or <code class="literal">fixed_interval</code>.
For example, consider a DST start in the <code class="literal">CET</code> time zone: on 27 March 2016 at 2am,
clocks were turned forward 1 hour to 3am local time. If you use <code class="literal">day</code> as the
<code class="literal">calendar_interval</code>, the bucket covering that day will only hold data for 23
hours instead of the usual 24 hours for other buckets. The same is true for
shorter intervals, like a <code class="literal">fixed_interval</code> of <code class="literal">12h</code>, where you&#8217;ll have only a 11h
bucket on the morning of 27 March when the DST shift happens.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-bucket-datehistogram-offset"></a>Offset<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/datehistogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Use the <code class="literal">offset</code> parameter to change the start value of each bucket by the
specified positive (<code class="literal">+</code>) or negative offset (<code class="literal">-</code>) duration, such as <code class="literal">1h</code> for
an hour, or <code class="literal">1d</code> for a day. See <a class="xref" href="api-conventions.html#time-units" title="Time units">Time units</a> for more possible time
duration options.</p>
<p>For example, when using an interval of <code class="literal">day</code>, each bucket runs from midnight
to midnight. Setting the <code class="literal">offset</code> parameter to <code class="literal">+6h</code> changes each bucket
to run from 6am to 6am:</p>
<a id="datehistogram-aggregation-offset-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT my-index-000001/_doc/1?refresh
{
  "date": "2015-10-01T05:30:00Z"
}

PUT my-index-000001/_doc/2?refresh
{
  "date": "2015-10-01T06:30:00Z"
}

GET my-index-000001/_search?size=0
{
  "aggs": {
    "by_day": {
      "date_histogram": {
        "field":     "date",
        "calendar_interval":  "day",
        "offset":    "+6h"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1227.console"></div>
<p>Instead of a single bucket starting at midnight, the above request groups the
documents into buckets starting at 6am:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "by_day": {
      "buckets": [
        {
          "key_as_string": "2015-09-30T06:00:00.000Z",
          "key": 1443592800000,
          "doc_count": 1
        },
        {
          "key_as_string": "2015-10-01T06:00:00.000Z",
          "key": 1443679200000,
          "doc_count": 1
        }
      ]
    }
  }
}</pre>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>The start <code class="literal">offset</code> of each bucket is calculated after <code class="literal">time_zone</code>
adjustments have been made.</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="search-aggregations-bucket-datehistogram-offset-months"></a>Long offsets over calendar intervals<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/datehistogram-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>It is typical to use offsets in units smaller than the <code class="literal">calendar_interval</code>. For example,
using offsets in hours when the interval is days, or an offset of days when the interval is months.
If the calendar interval is always of a standard length, or the <code class="literal">offset</code> is less than one unit of the calendar
interval (for example less than <code class="literal">+24h</code> for <code class="literal">days</code> or less than <code class="literal">+28d</code> for months),
then each bucket will have a repeating start. For example <code class="literal">+6h</code> for <code class="literal">days</code> will result in all buckets
starting at 6am each day. However, <code class="literal">+30h</code> will also result in buckets starting at 6am, except when crossing
days that change from standard to summer-savings time or vice-versa.</p>
<p>This situation is much more pronounced for months, where each month has a different length
to at least one of its adjacent months.
To demonstrate this, consider eight documents each with a date field on the 20th day of each of the
eight months from January to August of 2022.</p>
<p>When querying for a date histogram over the calendar interval of months, the response will return one bucket per month, each with a single document.
Each bucket will have a key named after the first day of the month, plus any offset.
For example, the offset of <code class="literal">+19d</code> will result in buckets with names like <code class="literal">2022-01-20</code>.</p>
<a id="datehistogram-aggregation-offset-example-19d"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">"buckets": [
  { "key_as_string": "2022-01-20", "key": 1642636800000, "doc_count": 1 },
  { "key_as_string": "2022-02-20", "key": 1645315200000, "doc_count": 1 },
  { "key_as_string": "2022-03-20", "key": 1647734400000, "doc_count": 1 },
  { "key_as_string": "2022-04-20", "key": 1650412800000, "doc_count": 1 },
  { "key_as_string": "2022-05-20", "key": 1653004800000, "doc_count": 1 },
  { "key_as_string": "2022-06-20", "key": 1655683200000, "doc_count": 1 },
  { "key_as_string": "2022-07-20", "key": 1658275200000, "doc_count": 1 },
  { "key_as_string": "2022-08-20", "key": 1660953600000, "doc_count": 1 }
]</pre>
</div>
<div class="console_widget" data-snippet="snippets/1228.console"></div>
<p>Increasing the offset to <code class="literal">+20d</code>, each document will appear in a bucket for the previous month,
with all bucket keys ending with the same day of the month, as normal.
However, further increasing to <code class="literal">+28d</code>,
what used to be a February bucket has now become <code class="literal">"2022-03-01"</code>.</p>
<a id="datehistogram-aggregation-offset-example-28d"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">"buckets": [
  { "key_as_string": "2021-12-29", "key": 1640736000000, "doc_count": 1 },
  { "key_as_string": "2022-01-29", "key": 1643414400000, "doc_count": 1 },
  { "key_as_string": "2022-03-01", "key": 1646092800000, "doc_count": 1 },
  { "key_as_string": "2022-03-29", "key": 1648512000000, "doc_count": 1 },
  { "key_as_string": "2022-04-29", "key": 1651190400000, "doc_count": 1 },
  { "key_as_string": "2022-05-29", "key": 1653782400000, "doc_count": 1 },
  { "key_as_string": "2022-06-29", "key": 1656460800000, "doc_count": 1 },
  { "key_as_string": "2022-07-29", "key": 1659052800000, "doc_count": 1 }
]</pre>
</div>
<div class="console_widget" data-snippet="snippets/1229.console"></div>
<p>If we continue to increase the offset, the 30-day months will also shift into the next month,
so that 3 of the 8 buckets have different days than the other five.
In fact if we keep going, we will find cases where two documents appear in the same month.
Documents that were originally 30 days apart can be shifted into the same 31-day month bucket.</p>
<p>For example, for <code class="literal">+50d</code> we see:</p>
<a id="datehistogram-aggregation-offset-example-50d"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">"buckets": [
  { "key_as_string": "2022-01-20", "key": 1642636800000, "doc_count": 1 },
  { "key_as_string": "2022-02-20", "key": 1645315200000, "doc_count": 2 },
  { "key_as_string": "2022-04-20", "key": 1650412800000, "doc_count": 2 },
  { "key_as_string": "2022-06-20", "key": 1655683200000, "doc_count": 2 },
  { "key_as_string": "2022-08-20", "key": 1660953600000, "doc_count": 1 }
]</pre>
</div>
<div class="console_widget" data-snippet="snippets/1230.console"></div>
<p>It is therefor always important when using <code class="literal">offset</code> with <code class="literal">calendar_interval</code> bucket sizes
to understand the consequences of using offsets larger than the interval size.</p>
<p>More examples:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
If the goal is to, for example, have an annual histogram where each year starts on the 5th February,
you could use <code class="literal">calendar_interval</code> of <code class="literal">year</code> and <code class="literal">offset</code> of <code class="literal">+33d</code>, and each year will be shifted identically,
because the offset includes only January, which is the same length every year.
However, if the goal is to have the year start on the 5th March instead, this technique will not work because
the offset includes February, which changes length every four years.
</li>
<li class="listitem">
If you want a quarterly histogram starting on a date within the first month of the year, it will work,
but as soon as you push the start date into the second month by having an offset longer than a month, the
quarters will all start on different dates.
</li>
</ul>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="date-histogram-keyed-response"></a>Keyed Response<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/datehistogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Setting the <code class="literal">keyed</code> flag to <code class="literal">true</code> associates a unique string key with each
bucket and returns the ranges as a hash rather than an array:</p>
<a id="datehistogram-aggregation-keyed-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "sales_over_time": {
      "date_histogram": {
        "field": "date",
        "calendar_interval": "1M",
        "format": "yyyy-MM-dd",
        "keyed": true
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1231.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "sales_over_time": {
      "buckets": {
        "2015-01-01": {
          "key_as_string": "2015-01-01",
          "key": 1420070400000,
          "doc_count": 3
        },
        "2015-02-01": {
          "key_as_string": "2015-02-01",
          "key": 1422748800000,
          "doc_count": 2
        },
        "2015-03-01": {
          "key_as_string": "2015-03-01",
          "key": 1425168000000,
          "doc_count": 2
        }
      }
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="date-histogram-scripts"></a>Scripts<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/datehistogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>If the data in your documents doesn&#8217;t exactly match what you&#8217;d like to aggregate,
use a <a class="xref" href="runtime.html" title="Runtime fields">runtime field</a> . For example, if the revenue
for promoted sales should be recognized a day after the sale date:</p>
<a id="datehistogram-aggregation-runtime-field"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "runtime_mappings": {
    "date.promoted_is_tomorrow": {
      "type": "date",
      "script": """
        long date = doc['date'].value.toInstant().toEpochMilli();
        if (doc['promoted'].value) {
          date += 86400;
        }
        emit(date);
      """
    }
  },
  "aggs": {
    "sales_over_time": {
      "date_histogram": {
        "field": "date.promoted_is_tomorrow",
        "calendar_interval": "1M"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1232.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="date-histogram-params"></a>Parameters<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/datehistogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>You can control the order of the returned
buckets using the <code class="literal">order</code>
settings and filter the returned buckets based on a <code class="literal">min_doc_count</code> setting
(by default all buckets between the first
bucket that matches documents and the last one are returned). This histogram
also supports the <code class="literal">extended_bounds</code>
setting, which enables extending the bounds of the histogram beyond the data
itself, and <code class="literal">hard_bounds</code> that limits the histogram to specified bounds.
For more information, see
<a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-histogram-aggregation-extended-bounds"><code class="literal">Extended Bounds</code></a> and
<a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-histogram-aggregation-hard-bounds"><code class="literal">Hard Bounds</code></a>.</p>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="date-histogram-missing-value"></a>Missing value<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/datehistogram-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>The <code class="literal">missing</code> parameter defines how to treat documents that are missing a value.
By default, they are ignored, but it is also possible to treat them as if they
have a value.</p>
<a id="datehistogram-aggregation-missing-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "sale_date": {
      "date_histogram": {
        "field": "date",
        "calendar_interval": "year",
        "missing": "2000/01/01" <a id="CO270-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1233.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO270-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Documents without a value in the <code class="literal">date</code> field will fall into the
same bucket as documents that have the value <code class="literal">2000-01-01</code>.</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="date-histogram-order"></a>Order<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/datehistogram-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>By default the returned buckets are sorted by their <code class="literal">key</code> ascending, but you can
control the order using
the <code class="literal">order</code> setting. This setting supports the same <code class="literal">order</code> functionality as
<a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation-order" title="Order"><code class="literal">Terms Aggregation</code></a>.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="date-histogram-aggregate-scripts"></a>Using a script to aggregate by day of the week<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/datehistogram-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>When you need to aggregate the results by day of the week, run a <code class="literal">terms</code>
aggregation on a <a class="xref" href="runtime.html" title="Runtime fields">runtime field</a> that returns the day of the week:</p>
<a id="datehistogram-aggregation-day-of-week-runtime-field"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "runtime_mappings": {
    "date.day_of_week": {
      "type": "keyword",
      "script": "emit(doc['date'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))"
    }
  },
  "aggs": {
    "day_of_week": {
      "terms": { "field": "date.day_of_week" }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1234.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "day_of_week": {
      "doc_count_error_upper_bound": 0,
      "sum_other_doc_count": 0,
      "buckets": [
        {
          "key": "Sunday",
          "doc_count": 4
        },
        {
          "key": "Thursday",
          "doc_count": 3
        }
      ]
    }
  }
}</pre>
</div>
<p>The response will contain all the buckets having the relative day of
the week as key : 1 for Monday, 2 for Tuesday&#8230;&#8203; 7 for Sunday.</p>
</div>

</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-daterange-aggregation"></a>Date range aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/daterange-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A range aggregation that is dedicated for date values. The main difference
between this aggregation and the normal
<a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-range-aggregation" title="Range aggregation">range</a>
aggregation is that the <code class="literal">from</code> and <code class="literal">to</code> values can be expressed in
<a class="xref" href="common-options.html#date-math" title="Date Math">Date Math</a> expressions, and it is also possible to specify a date
format by which the <code class="literal">from</code> and <code class="literal">to</code> response fields will be returned.
Note that this aggregation includes the <code class="literal">from</code> value and excludes the <code class="literal">to</code> value
for each range.</p>
<p>Example:</p>
<a id="daterange-aggregation-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "range": {
      "date_range": {
        "field": "date",
        "format": "MM-yyyy",
        "ranges": [
          { "to": "now-10M/M" },  <a id="CO271-1"></a><i class="conum" data-value="1"></i>
          { "from": "now-10M/M" } <a id="CO271-2"></a><i class="conum" data-value="2"></i>
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1235.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO271-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>&lt; now minus 10 months, rounded down to the start of the month.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO271-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>&gt;= now minus 10 months, rounded down to the start of the month.</p>
</td>
</tr>
</table>
</div>
<p>In the example above, we created two range buckets, the first will "bucket" all
documents dated prior to 10 months ago and the second will "bucket" all
documents dated since 10 months ago</p>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "range": {
      "buckets": [
        {
          "to": 1.4436576E12,
          "to_as_string": "10-2015",
          "doc_count": 7,
          "key": "*-10-2015"
        },
        {
          "from": 1.4436576E12,
          "from_as_string": "10-2015",
          "doc_count": 0,
          "key": "10-2015-*"
        }
      ]
    }
  }
}</pre>
</div>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>If a format or date value is incomplete, the date range aggregation
replaces any missing components with default values. See
<a class="xref" href="term-level-queries.html#missing-date-components" title="Missing date components">Missing date components</a>.</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_missing_values_2"></a>Missing Values<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/daterange-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">missing</code> parameter defines how documents that are missing a value should
be treated. By default they will be ignored but it is also possible to treat
them as if they had a value. This is done by adding a set of fieldname :
value mappings to specify default values per field.</p>
<a id="daterange-aggregation-missing-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
   "aggs": {
       "range": {
           "date_range": {
               "field": "date",
               "missing": "1976/11/30",
               "ranges": [
                  {
                    "key": "Older",
                    "to": "2016/02/01"
                  }, <a id="CO272-1"></a><i class="conum" data-value="1"></i>
                  {
                    "key": "Newer",
                    "from": "2016/02/01",
                    "to" : "now/d"
                  }
              ]
          }
      }
   }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1236.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO272-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Documents without a value in the <code class="literal">date</code> field will be added to the "Older"
bucket, as if they had a date value of "1976-11-30".</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="date-format-pattern"></a>Date Format/Pattern<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/daterange-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>this information was copied from
<a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html" class="ulink" target="_top">DateTimeFormatter</a></p>
</div>
</div>
<p>All ASCII letters are reserved as format pattern letters, which are defined
as follows:</p>
<div class="informaltable">
<table border="1" cellpadding="4px">
<colgroup>
<col class="col_1"/>
<col class="col_2"/>
<col class="col_3"/>
<col class="col_4"/>
</colgroup>
<thead>
<tr>
<th align="left" valign="top">Symbol</th>
<th align="left" valign="top">Meaning</th>
<th align="left" valign="top">Presentation</th>
<th align="left" valign="top">Examples</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p>G</p></td>
<td align="left" valign="top"><p>era</p></td>
<td align="left" valign="top"><p>text</p></td>
<td align="left" valign="top"><p>AD; Anno Domini; A</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>u</p></td>
<td align="left" valign="top"><p>year</p></td>
<td align="left" valign="top"><p>year</p></td>
<td align="left" valign="top"><p>2004; 04</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>y</p></td>
<td align="left" valign="top"><p>year-of-era</p></td>
<td align="left" valign="top"><p>year</p></td>
<td align="left" valign="top"><p>2004; 04</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>D</p></td>
<td align="left" valign="top"><p>day-of-year</p></td>
<td align="left" valign="top"><p>number</p></td>
<td align="left" valign="top"><p>189</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>M/L</p></td>
<td align="left" valign="top"><p>month-of-year</p></td>
<td align="left" valign="top"><p>number/text</p></td>
<td align="left" valign="top"><p>7; 07; Jul; July; J</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>d</p></td>
<td align="left" valign="top"><p>day-of-month</p></td>
<td align="left" valign="top"><p>number</p></td>
<td align="left" valign="top"><p>10</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>Q/q</p></td>
<td align="left" valign="top"><p>quarter-of-year</p></td>
<td align="left" valign="top"><p>number/text</p></td>
<td align="left" valign="top"><p>3; 03; Q3; 3rd quarter</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>Y</p></td>
<td align="left" valign="top"><p>week-based-year</p></td>
<td align="left" valign="top"><p>year</p></td>
<td align="left" valign="top"><p>1996; 96</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>w</p></td>
<td align="left" valign="top"><p>week-of-week-based-year</p></td>
<td align="left" valign="top"><p>number</p></td>
<td align="left" valign="top"><p>27</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>W</p></td>
<td align="left" valign="top"><p>week-of-month</p></td>
<td align="left" valign="top"><p>number</p></td>
<td align="left" valign="top"><p>4</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>E</p></td>
<td align="left" valign="top"><p>day-of-week</p></td>
<td align="left" valign="top"><p>text</p></td>
<td align="left" valign="top"><p>Tue; Tuesday; T</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>e/c</p></td>
<td align="left" valign="top"><p>localized day-of-week</p></td>
<td align="left" valign="top"><p>number/text</p></td>
<td align="left" valign="top"><p>2; 02; Tue; Tuesday; T</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>F</p></td>
<td align="left" valign="top"><p>week-of-month</p></td>
<td align="left" valign="top"><p>number</p></td>
<td align="left" valign="top"><p>3</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>a</p></td>
<td align="left" valign="top"><p>am-pm-of-day</p></td>
<td align="left" valign="top"><p>text</p></td>
<td align="left" valign="top"><p>PM</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>h</p></td>
<td align="left" valign="top"><p>clock-hour-of-am-pm (1-12)</p></td>
<td align="left" valign="top"><p>number</p></td>
<td align="left" valign="top"><p>12</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>K</p></td>
<td align="left" valign="top"><p>hour-of-am-pm (0-11)</p></td>
<td align="left" valign="top"><p>number</p></td>
<td align="left" valign="top"><p>0</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>k</p></td>
<td align="left" valign="top"><p>clock-hour-of-am-pm (1-24)</p></td>
<td align="left" valign="top"><p>number</p></td>
<td align="left" valign="top"><p>0</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>H</p></td>
<td align="left" valign="top"><p>hour-of-day (0-23)</p></td>
<td align="left" valign="top"><p>number</p></td>
<td align="left" valign="top"><p>0</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>m</p></td>
<td align="left" valign="top"><p>minute-of-hour</p></td>
<td align="left" valign="top"><p>number</p></td>
<td align="left" valign="top"><p>30</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>s</p></td>
<td align="left" valign="top"><p>second-of-minute</p></td>
<td align="left" valign="top"><p>number</p></td>
<td align="left" valign="top"><p>55</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>S</p></td>
<td align="left" valign="top"><p>fraction-of-second</p></td>
<td align="left" valign="top"><p>fraction</p></td>
<td align="left" valign="top"><p>978</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>A</p></td>
<td align="left" valign="top"><p>milli-of-day</p></td>
<td align="left" valign="top"><p>number</p></td>
<td align="left" valign="top"><p>1234</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>n</p></td>
<td align="left" valign="top"><p>nano-of-second</p></td>
<td align="left" valign="top"><p>number</p></td>
<td align="left" valign="top"><p>987654321</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>N</p></td>
<td align="left" valign="top"><p>nano-of-day</p></td>
<td align="left" valign="top"><p>number</p></td>
<td align="left" valign="top"><p>1234000000</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>V</p></td>
<td align="left" valign="top"><p>time-zone ID</p></td>
<td align="left" valign="top"><p>zone-id</p></td>
<td align="left" valign="top"><p>America/Los_Angeles; Z; -08:30</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>z</p></td>
<td align="left" valign="top"><p>time-zone name</p></td>
<td align="left" valign="top"><p>zone-name</p></td>
<td align="left" valign="top"><p>Pacific Standard Time; PST</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>O</p></td>
<td align="left" valign="top"><p>localized zone-offset</p></td>
<td align="left" valign="top"><p>offset-O</p></td>
<td align="left" valign="top"><p>GMT+8; GMT+08:00; UTC-08:00;</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>X</p></td>
<td align="left" valign="top"><p>zone-offset <em>Z</em> for zero</p></td>
<td align="left" valign="top"><p>offset-X</p></td>
<td align="left" valign="top"><p>Z; -08; -0830; -08:30; -083015; -08:30:15;</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>x</p></td>
<td align="left" valign="top"><p>zone-offset</p></td>
<td align="left" valign="top"><p>offset-x</p></td>
<td align="left" valign="top"><p>+0000; -08; -0830; -08:30; -083015; -08:30:15;</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>Z</p></td>
<td align="left" valign="top"><p>zone-offset</p></td>
<td align="left" valign="top"><p>offset-Z</p></td>
<td align="left" valign="top"><p>+0000; -0800; -08:00;</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>p</p></td>
<td align="left" valign="top"><p>pad next</p></td>
<td align="left" valign="top"><p>pad modifier</p></td>
<td align="left" valign="top"><p>1</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>'</p></td>
<td align="left" valign="top"><p>escape for text</p></td>
<td align="left" valign="top"><p>delimiter</p></td>
<td align="left" valign="top"><p>''</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>single quote</p></td>
<td align="left" valign="top"><p>literal</p></td>
<td align="left" valign="top"><p>'</p></td>
<td align="left" valign="top"><p>[</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>optional section start</p></td>
<td align="left" valign="top"><p>]</p></td>
<td align="left" valign="top"><p>optional section end</p></td>
<td align="left" valign="top"><p>#</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>reserved for future use</p></td>
<td align="left" valign="top"><p>{</p></td>
<td align="left" valign="top"><p>reserved for future use</p></td>
<td align="left" valign="top"><p>}</p></td>
</tr>
</tbody>
</table>
</div>
<p>The count of pattern letters determines the format.</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
Text
</span>
</dt>
<dd>
The text style is determined based on the number of pattern letters
used. Less than 4 pattern letters will use the short form. Exactly 4
pattern letters will use the full form. Exactly 5 pattern letters will use
the narrow form. Pattern letters <code class="literal">L</code>, <code class="literal">c</code>, and <code class="literal">q</code> specify the stand-alone
form of the text styles.
</dd>
<dt>
<span class="term">
Number
</span>
</dt>
<dd>
If the count of letters is one, then the value is output using
the minimum number of digits and without padding. Otherwise, the count of
digits is used as the width of the output field, with the value
zero-padded as necessary. The following pattern letters have constraints
on the count of letters. Only one letter of <code class="literal">c</code> and <code class="literal">F</code> can be specified.
Up to two letters of <code class="literal">d</code>, <code class="literal">H</code>, <code class="literal">h</code>, <code class="literal">K</code>, <code class="literal">k</code>, <code class="literal">m</code>, and <code class="literal">s</code> can be
specified. Up to three letters of <code class="literal">D</code> can be specified.
</dd>
<dt>
<span class="term">
Number/Text
</span>
</dt>
<dd>
If the count of pattern letters is 3 or greater, use the
Text rules above. Otherwise use the Number rules above.
</dd>
<dt>
<span class="term">
Fraction
</span>
</dt>
<dd>
Outputs the nano-of-second field as a fraction-of-second. The
nano-of-second value has nine digits, thus the count of pattern letters is
from 1 to 9. If it is less than 9, then the nano-of-second value is
truncated, with only the most significant digits being output.
</dd>
<dt>
<span class="term">
Year
</span>
</dt>
<dd>
The count of letters determines the minimum field width below which
padding is used. If the count of letters is two, then a reduced two digit
form is used. For printing, this outputs the rightmost two digits. For
parsing, this will parse using the base value of 2000, resulting in a year
within the range 2000 to 2099 inclusive. If the count of letters is less
than four (but not two), then the sign is only output for negative years
as per <code class="literal">SignStyle.NORMAL</code>. Otherwise, the sign is output if the pad width is
exceeded, as per <code class="literal">SignStyle.EXCEEDS_PAD</code>.
</dd>
<dt>
<span class="term">
ZoneId
</span>
</dt>
<dd>
This outputs the time-zone ID, such as <code class="literal">Europe/Paris</code>. If the
count of letters is two, then the time-zone ID is output. Any other count
of letters throws <code class="literal">IllegalArgumentException</code>.
</dd>
<dt>
<span class="term">
Zone names
</span>
</dt>
<dd>
This outputs the display name of the time-zone ID. If the
count of letters is one, two or three, then the short name is output. If
the count of letters is four, then the full name is output. Five or more
letters throws <code class="literal">IllegalArgumentException</code>.
</dd>
<dt>
<span class="term">
Offset X and x
</span>
</dt>
<dd>
This formats the offset based on the number of pattern
letters. One letter outputs just the hour, such as <code class="literal">+01</code>, unless the
minute is non-zero in which case the minute is also output, such as
<code class="literal">+0130</code>. Two letters outputs the hour and minute, without a colon, such as
<code class="literal">+0130</code>. Three letters outputs the hour and minute, with a colon, such as
<code class="literal">+01:30</code>. Four letters outputs the hour and minute and optional second,
without a colon, such as <code class="literal">+013015</code>. Five letters outputs the hour and
minute and optional second, with a colon, such as <code class="literal">+01:30:15</code>. Six or
more letters throws <code class="literal">IllegalArgumentException</code>. Pattern letter <code class="literal">X</code> (upper
case) will output <code class="literal">Z</code> when the offset to be output would be zero,
whereas pattern letter <code class="literal">x</code> (lower case) will output <code class="literal">+00</code>, <code class="literal">+0000</code>, or
<code class="literal">+00:00</code>.
</dd>
<dt>
<span class="term">
Offset O
</span>
</dt>
<dd>
This formats the localized offset based on the number of
pattern letters. One letter outputs the short form of the localized
offset, which is localized offset text, such as <code class="literal">GMT</code>, with hour without
leading zero, optional 2-digit minute and second if non-zero, and colon,
for example <code class="literal">GMT+8</code>. Four letters outputs the full form, which is
localized offset text, such as <code class="literal">GMT, with 2-digit hour and minute
field, optional second field if non-zero, and colon, for example
`GMT+08:00</code>. Any other count of letters throws
<code class="literal">IllegalArgumentException</code>.
</dd>
<dt>
<span class="term">
Offset Z
</span>
</dt>
<dd>
This formats the offset based on the number of pattern letters.
One, two or three letters outputs the hour and minute, without a colon,
such as <code class="literal">+0130</code>. The output will be <code class="literal">+0000</code> when the offset is zero.
Four letters outputs the full form of localized offset, equivalent to
four letters of Offset-O. The output will be the corresponding localized
offset text if the offset is zero. Five letters outputs the hour,
minute, with optional second if non-zero, with colon. It outputs <code class="literal">Z</code> if
the offset is zero. Six or more letters throws IllegalArgumentException.
</dd>
<dt>
<span class="term">
Optional section
</span>
</dt>
<dd>
The optional section markers work exactly like calling
<code class="literal">DateTimeFormatterBuilder.optionalStart()</code> and
<code class="literal">DateTimeFormatterBuilder.optionalEnd()</code>.
</dd>
<dt>
<span class="term">
Pad modifier
</span>
</dt>
<dd>
Modifies the pattern that immediately follows to be padded
with spaces. The pad width is determined by the number of pattern letters.
This is the same as calling <code class="literal">DateTimeFormatterBuilder.padNext(int)</code>.
</dd>
</dl>
</div>
<p>For example, <code class="literal">ppH</code> outputs the hour-of-day padded on the left with spaces to a width of 2.</p>
<p>Any unrecognized letter is an error. Any non-letter character, other than
<code class="literal">[</code>, <code class="literal">]</code>, <code class="literal">{</code>, <code class="literal">}</code>, <code class="literal">#</code> and the single quote will be output directly.
Despite this, it is recommended to use single quotes around all characters
that you want to output directly to ensure that future changes do not
break your application.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="time-zones"></a>Time zone in date range aggregations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/daterange-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Dates can be converted from another time zone to UTC by specifying the
<code class="literal">time_zone</code> parameter.</p>
<p>Time zones may either be specified as an ISO 8601 UTC offset (e.g. +01:00 or
-08:00) or as one of the time zone ids from the TZ database.</p>
<p>The <code class="literal">time_zone</code> parameter is also applied to rounding in date math expressions.
As an example, to round to the beginning of the day in the CET time zone, you
can do the following:</p>
<a id="daterange-aggregation-timezone-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
   "aggs": {
       "range": {
           "date_range": {
               "field": "date",
               "time_zone": "CET",
               "ranges": [
                  { "to": "2016/02/01" }, <a id="CO273-1"></a><i class="conum" data-value="1"></i>
                  { "from": "2016/02/01", "to" : "now/d" }, <a id="CO273-2"></a><i class="conum" data-value="2"></i>
                  { "from": "now/d" }
              ]
          }
      }
   }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1237.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO273-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>This date will be converted to <code class="literal">2016-02-01T00:00:00.000+01:00</code>.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO273-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p><code class="literal">now/d</code> will be rounded to the beginning of the day in the CET time zone.</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_keyed_response"></a>Keyed Response<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/daterange-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Setting the <code class="literal">keyed</code> flag to <code class="literal">true</code> will associate a unique string key with each
bucket and return the ranges as a hash rather than an array:</p>
<a id="daterange-aggregation-keyed-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "range": {
      "date_range": {
        "field": "date",
        "format": "MM-yyy",
        "ranges": [
          { "to": "now-10M/M" },
          { "from": "now-10M/M" }
        ],
        "keyed": true
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1238.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "range": {
      "buckets": {
        "*-10-2015": {
          "to": 1.4436576E12,
          "to_as_string": "10-2015",
          "doc_count": 7
        },
        "10-2015-*": {
          "from": 1.4436576E12,
          "from_as_string": "10-2015",
          "doc_count": 0
        }
      }
    }
  }
}</pre>
</div>
<p>It is also possible to customize the key for each range:</p>
<a id="daterange-aggregation-keyed-multiple-keys-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "range": {
      "date_range": {
        "field": "date",
        "format": "MM-yyy",
        "ranges": [
          { "from": "01-2015", "to": "03-2015", "key": "quarter_01" },
          { "from": "03-2015", "to": "06-2015", "key": "quarter_02" }
        ],
        "keyed": true
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1239.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "range": {
      "buckets": {
        "quarter_01": {
          "from": 1.4200704E12,
          "from_as_string": "01-2015",
          "to": 1.425168E12,
          "to_as_string": "03-2015",
          "doc_count": 5
        },
        "quarter_02": {
          "from": 1.425168E12,
          "from_as_string": "03-2015",
          "to": 1.4331168E12,
          "to_as_string": "06-2015",
          "doc_count": 2
        }
      }
    }
  }
}</pre>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-diversified-sampler-aggregation"></a>Diversified sampler aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/diversified-sampler-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>Like the <code class="literal">sampler</code> aggregation this is a filtering aggregation used to limit any sub aggregations' processing to a sample of the top-scoring documents.
The <code class="literal">diversified_sampler</code> aggregation adds the ability to limit the number of matches that share a common value such as an "author".</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>Any good market researcher will tell you that when working with samples of data it is important
that the sample represents a healthy variety of opinions rather than being skewed by any single voice.
The same is true with aggregations and sampling with these diversify settings can offer a way to remove the bias in your content (an over-populated geography,
a large spike in a timeline or an over-active forum spammer).</p>
</div>
</div>
<div class="ulist itemizedlist">
<p class="title"><strong>Example use cases:</strong></p>
<ul class="itemizedlist">
<li class="listitem">
Tightening the focus of analytics to high-relevance matches rather than the potentially very long tail of low-quality matches
</li>
<li class="listitem">
Removing bias from analytics by ensuring fair representation of content from different sources
</li>
<li class="listitem">
Reducing the running cost of aggregations that can produce useful results using only samples e.g. <code class="literal">significant_terms</code>
</li>
</ul>
</div>
<p>The <code class="literal">field</code> setting is used to provide values used for de-duplication and the <code class="literal">max_docs_per_value</code> setting controls the maximum
number of documents collected on any one shard which share a common value. The default setting for <code class="literal">max_docs_per_value</code> is 1.</p>
<p>The aggregation will throw an error if the <code class="literal">field</code> produces multiple values for a single document (de-duplication using multi-valued fields is not supported due to efficiency concerns).</p>
<p>Example:</p>
<p>We might want to see which tags are strongly associated with <code class="literal">#elasticsearch</code> on StackOverflow
forum posts but ignoring the effects of some prolific users with a tendency to misspell #Kibana as #Cabana.</p>
<a id="diversified-sampler-aggregation-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /stackoverflow/_search?size=0
{
  "query": {
    "query_string": {
      "query": "tags:elasticsearch"
    }
  },
  "aggs": {
    "my_unbiased_sample": {
      "diversified_sampler": {
        "shard_size": 200,
        "field": "author"
      },
      "aggs": {
        "keywords": {
          "significant_terms": {
            "field": "tags",
            "exclude": [ "elasticsearch" ]
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1240.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "my_unbiased_sample": {
      "doc_count": 151,           <a id="CO274-1"></a><i class="conum" data-value="1"></i>
      "keywords": {               <a id="CO274-2"></a><i class="conum" data-value="2"></i>
        "doc_count": 151,
        "bg_count": 650,
        "buckets": [
          {
            "key": "kibana",
            "doc_count": 150,
            "score": 2.213,
            "bg_count": 200
          }
        ]
      }
    }
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO274-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>151 documents were sampled in total.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO274-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>The results of the significant_terms aggregation are not skewed by any single author&#8217;s quirks because we asked for a maximum of one post from any one author in our sample.</p>
</td>
</tr>
</table>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_scripted_example"></a>Scripted example<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/diversified-sampler-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>In this scenario we might want to diversify on a combination of field values. We can use a <a class="xref" href="runtime.html" title="Runtime fields">runtime field</a> to
produce a hash of the multiple values in a tags field to ensure we don&#8217;t have a sample that consists of the same
repeated combinations of tags.</p>
<a id="diversified-sampler-aggregation-runtime-field-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /stackoverflow/_search?size=0
{
  "query": {
    "query_string": {
      "query": "tags:kibana"
    }
  },
  "runtime_mappings": {
    "tags.hash": {
      "type": "long",
      "script": "emit(doc['tags'].hashCode())"
    }
  },
  "aggs": {
    "my_unbiased_sample": {
      "diversified_sampler": {
        "shard_size": 200,
        "max_docs_per_value": 3,
        "field": "tags.hash"
      },
      "aggs": {
        "keywords": {
          "significant_terms": {
            "field": "tags",
            "exclude": [ "kibana" ]
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1241.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "my_unbiased_sample": {
      "doc_count": 6,
      "keywords": {
        "doc_count": 6,
        "bg_count": 650,
        "buckets": [
          {
            "key": "logstash",
            "doc_count": 3,
            "score": 2.213,
            "bg_count": 50
          },
          {
            "key": "elasticsearch",
            "doc_count": 3,
            "score": 1.34,
            "bg_count": 200
          }
        ]
      }
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_shard_size"></a>shard_size<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/diversified-sampler-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">shard_size</code> parameter limits how many top-scoring documents are collected in the sample processed on each shard.
The default value is 100.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_max_docs_per_value"></a>max_docs_per_value<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/diversified-sampler-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">max_docs_per_value</code> is an optional parameter and limits how many documents are permitted per choice of de-duplicating value.
The default setting is "1".</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_execution_hint"></a>execution_hint<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/diversified-sampler-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The optional <code class="literal">execution_hint</code> setting can influence the management of the values used for de-duplication.
Each option will hold up to <code class="literal">shard_size</code> values in memory while performing de-duplication but the type of value held can be controlled as follows:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
hold field values directly (<code class="literal">map</code>)
</li>
<li class="listitem">
hold ordinals of the field as determined by the Lucene index (<code class="literal">global_ordinals</code>)
</li>
<li class="listitem">
hold hashes of the field values - with potential for hash collisions (<code class="literal">bytes_hash</code>)
</li>
</ul>
</div>
<p>The default setting is to use <a class="xref" href="mapping-params.html#eager-global-ordinals" title="eager_global_ordinals"><code class="literal">global_ordinals</code></a> if this information is available from the Lucene index and reverting to <code class="literal">map</code> if not.
The <code class="literal">bytes_hash</code> setting may prove faster in some cases but introduces the possibility of false positives in de-duplication logic due to the possibility of hash collisions.
Please note that Elasticsearch will ignore the choice of execution hint if it is not applicable and that there is no backward compatibility guarantee on these hints.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_limitations_4"></a>Limitations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/diversified-sampler-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="div-sampler-breadth-first-nested-agg"></a>Cannot be nested under <code class="literal">breadth_first</code> aggregations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/diversified-sampler-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>Being a quality-based filter the diversified_sampler aggregation needs access to the relevance score produced for each document.
It therefore cannot be nested under a <code class="literal">terms</code> aggregation which has the <code class="literal">collect_mode</code> switched from the default <code class="literal">depth_first</code> mode to <code class="literal">breadth_first</code> as this discards scores.
In this situation an error will be thrown.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_limited_de_dup_logic"></a>Limited de-dup logic.<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/diversified-sampler-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>The de-duplication logic applies only at a shard level so will not apply across shards.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="spec-syntax-geo-date-fields"></a>No specialized syntax for geo/date fields<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/diversified-sampler-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>Currently the syntax for defining the diversifying values is defined by a choice of <code class="literal">field</code> or
<code class="literal">script</code> - there is no added syntactical sugar for expressing geo or date units such as "7d" (7
days). This support may be added in a later release and users will currently have to create these
sorts of values using a script.</p>
</div>

</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-filter-aggregation"></a>Filter aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/filter-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A single bucket aggregation that narrows the set of documents
to those that match a <a class="xref" href="query-dsl.html" title="Query DSL">query</a>.</p>
<p>Example:</p>
<a id="filter-aggregation-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0&amp;filter_path=aggregations
{
  "aggs": {
    "avg_price": { "avg": { "field": "price" } },
    "t_shirts": {
      "filter": { "term": { "type": "t-shirt" } },
      "aggs": {
        "avg_price": { "avg": { "field": "price" } }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1242.console"></div>
<p>The previous example calculates the average price of all sales as well as
the average price of all T-shirt sales.</p>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "aggregations": {
    "avg_price": { "value": 140.71428571428572 },
    "t_shirts": {
      "doc_count": 3,
      "avg_price": { "value": 128.33333333333334 }
    }
  }
}</pre>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="use-top-level-query-to-limit-all-aggs"></a>Use a top-level <code class="literal">query</code> to limit all aggregations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/filter-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>To limit the documents on which all aggregations in a search run, use a
top-level <code class="literal">query</code>. This is faster than a single <code class="literal">filter</code> aggregation with
sub-aggregations.</p>
<p>For example, use this:</p>
<a id="filter-aggregation-top-good"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0&amp;filter_path=aggregations
{
  "query": { "term": { "type": "t-shirt" } },
  "aggs": {
    "avg_price": { "avg": { "field": "price" } }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1243.console"></div>
<p>Instead of this:</p>
<a id="filter-aggregation-top-bad"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0&amp;filter_path=aggregations
{
  "aggs": {
    "t_shirts": {
      "filter": { "term": { "type": "t-shirt" } },
      "aggs": {
        "avg_price": { "avg": { "field": "price" } }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1244.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="use-filters-agg-for-multiple-filters"></a>Use the <code class="literal">filters</code> aggregation for multiple filters<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/filter-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>To group documents using multiple filters, use the
<a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-filters-aggregation" title="Filters aggregation"><code class="literal">filters</code> aggregation</a>. This
is faster than multiple <code class="literal">filter</code> aggregations.</p>
<p>For example, use this:</p>
<a id="filter-aggregation-many-good"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0&amp;filter_path=aggregations
{
  "aggs": {
    "f": {
      "filters": {
        "filters": {
          "hats": { "term": { "type": "hat" } },
          "t_shirts": { "term": { "type": "t-shirt" } }
        }
      },
      "aggs": {
        "avg_price": { "avg": { "field": "price" } }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1245.console"></div>
<p>Instead of this:</p>
<a id="filter-aggregation-many-bad"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0&amp;filter_path=aggregations
{
  "aggs": {
    "hats": {
      "filter": { "term": { "type": "hat" } },
      "aggs": {
        "avg_price": { "avg": { "field": "price" } }
      }
    },
    "t_shirts": {
      "filter": { "term": { "type": "t-shirt" } },
      "aggs": {
        "avg_price": { "avg": { "field": "price" } }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1246.console"></div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-filters-aggregation"></a>Filters aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/filters-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A multi-bucket aggregation where each bucket contains the documents
that match a <a class="xref" href="query-dsl.html" title="Query DSL">query</a>.</p>
<p>Example:</p>
<a id="filters-aggregation-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /logs/_bulk?refresh
{ "index" : { "_id" : 1 } }
{ "body" : "warning: page could not be rendered" }
{ "index" : { "_id" : 2 } }
{ "body" : "authentication error" }
{ "index" : { "_id" : 3 } }
{ "body" : "warning: connection timed out" }

GET logs/_search
{
  "size": 0,
  "aggs" : {
    "messages" : {
      "filters" : {
        "filters" : {
          "errors" :   { "match" : { "body" : "error"   }},
          "warnings" : { "match" : { "body" : "warning" }}
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1247.console"></div>
<p>In the above example, we analyze log messages. The aggregation will build two
collection (buckets) of log messages - one for all those containing an error,
and another for all those containing a warning.</p>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "took": 9,
  "timed_out": false,
  "_shards": ...,
  "hits": ...,
  "aggregations": {
    "messages": {
      "buckets": {
        "errors": {
          "doc_count": 1
        },
        "warnings": {
          "doc_count": 2
        }
      }
    }
  }
}</pre>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="anonymous-filters"></a>Anonymous filters<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/filters-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The filters field can also be provided as an array of filters, as in the
following request:</p>
<a id="filters-aggregation-anonymous-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET logs/_search
{
  "size": 0,
  "aggs" : {
    "messages" : {
      "filters" : {
        "filters" : [
          { "match" : { "body" : "error"   }},
          { "match" : { "body" : "warning" }}
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1248.console"></div>
<p>The filtered buckets are returned in the same order as provided in the
request. The response for this example would be:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "took": 4,
  "timed_out": false,
  "_shards": ...,
  "hits": ...,
  "aggregations": {
    "messages": {
      "buckets": [
        {
          "doc_count": 1
        },
        {
          "doc_count": 2
        }
      ]
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="other-bucket"></a><code class="literal">Other</code> Bucket<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/filters-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">other_bucket</code> parameter can be set to add a bucket to the response which will contain all documents that do
not match any of the given filters. The value of this parameter can be as follows:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">false</code>
</span>
</dt>
<dd>
Does not compute the <code class="literal">other</code> bucket
</dd>
<dt>
<span class="term">
<code class="literal">true</code>
</span>
</dt>
<dd>
Returns the <code class="literal">other</code> bucket either in a bucket (named <code class="literal">_other_</code> by default) if named filters are being used,
or as the last bucket if anonymous filters are being used
</dd>
</dl>
</div>
<p>The <code class="literal">other_bucket_key</code> parameter can be used to set the key for the <code class="literal">other</code> bucket to a value other than the default <code class="literal">_other_</code>. Setting
this parameter will implicitly set the <code class="literal">other_bucket</code> parameter to <code class="literal">true</code>.</p>
<p>The following snippet shows a response where the <code class="literal">other</code> bucket is requested to be named <code class="literal">other_messages</code>.</p>
<a id="filters-aggregation-other-bucket-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT logs/_doc/4?refresh
{
  "body": "info: user Bob logged out"
}

GET logs/_search
{
  "size": 0,
  "aggs" : {
    "messages" : {
      "filters" : {
        "other_bucket_key": "other_messages",
        "filters" : {
          "errors" :   { "match" : { "body" : "error"   }},
          "warnings" : { "match" : { "body" : "warning" }}
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1249.console"></div>
<p>The response would be something like the following:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "took": 3,
  "timed_out": false,
  "_shards": ...,
  "hits": ...,
  "aggregations": {
    "messages": {
      "buckets": {
        "errors": {
          "doc_count": 1
        },
        "warnings": {
          "doc_count": 2
        },
        "other_messages": {
          "doc_count": 1
        }
      }
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="non-keyed-response"></a>Non-keyed Response<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/filters-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>By default, the named filters aggregation returns the buckets as an object. But in some sorting cases, such as
<a class="xref" href="search-aggregations-pipeline.html#search-aggregations-pipeline-bucket-sort-aggregation" title="Bucket sort aggregation">bucket sort</a>, the JSON doesn&#8217;t guarantee the order of elements
in the object. You can use the <code class="literal">keyed</code> parameter to specify the buckets as an array of objects. The value of this
parameter can be as follows:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">true</code>
</span>
</dt>
<dd>
(Default) Returns the buckets as an object
</dd>
<dt>
<span class="term">
<code class="literal">false</code>
</span>
</dt>
<dd>
Returns the buckets as an array of objects
</dd>
</dl>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>This parameter is ignored by <a class="xref" href="search-aggregations-bucket.html#anonymous-filters" title="Anonymous filters">Anonymous filters</a>.</p>
</div>
</div>
<p>Example:</p>
<a id="filters-aggregation-sortable-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0&amp;filter_path=aggregations
{
  "aggs": {
    "the_filter": {
      "filters": {
        "keyed": false,
        "filters": {
          "t-shirt": { "term": { "type": "t-shirt" } },
          "hat": { "term": { "type": "hat" } }
        }
      },
      "aggs": {
        "avg_price": { "avg": { "field": "price" } },
        "sort_by_avg_price": {
          "bucket_sort": { "sort": { "avg_price": "asc" } }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1250.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "aggregations": {
    "the_filter": {
      "buckets": [
        {
          "key": "t-shirt",
          "doc_count": 3,
          "avg_price": { "value": 128.33333333333334 }
        },
        {
          "key": "hat",
          "doc_count": 3,
          "avg_price": { "value": 150.0 }
        }
      ]
    }
  }
}</pre>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-frequent-item-sets-aggregation"></a>Frequent item sets aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/frequent-item-sets-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A bucket aggregation which finds frequent item sets. It is a form of association
rules mining that identifies items that often occur together. Items that are
frequently purchased together or log events that tend to co-occur are examples
of frequent item sets. Finding frequent item sets helps to discover
relationships between different data points (items).</p>
<p>The aggregation reports closed item sets. A frequent item set is called closed
if no superset exists with the same ratio of documents (also known as its
<a class="xref" href="search-aggregations-bucket.html#frequent-item-sets-minimum-support" title="Minimum support">support value</a>). For example, we have the two
following candidates for a frequent item set, which have the same support value:
1. <code class="literal">apple, orange, banana</code>
2. <code class="literal">apple, orange, banana, tomato</code>.
Only the second item set (<code class="literal">apple, orange, banana, tomato</code>) is returned, and the
first set – which is a subset of the second one – is skipped. Both item sets
might be returned if their support values are different.</p>
<p>The runtime of the aggregation depends on the data and the provided parameters.
It might take a significant time for the aggregation to complete. For this
reason, it is recommended to use <a class="xref" href="search.html#async-search" title="Async search">async search</a> to run your
requests asynchronously.</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_syntax"></a>Syntax<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/frequent-item-sets-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>A <code class="literal">frequent_item_sets</code> aggregation looks like this in isolation:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">"frequent_item_sets": {
  "minimum_set_size": 3,
  "fields": [
    {"field": "my_field_1"},
    {"field": "my_field_2"}
  ]
}</pre>
</div>
<div class="table">
<p class="title"><strong>Table 49. <code class="literal">frequent_item_sets</code> Parameters</strong></p>
<div class="table-contents">
<table border="1" cellpadding="4px" summary="frequent_item_sets Parameters">
<colgroup>
<col class="col_1"/>
<col class="col_2"/>
<col class="col_3"/>
<col class="col_4"/>
</colgroup>
<tbody>
<tr>
<td align="left" valign="top"><p>Parameter Name</p></td>
<td align="left" valign="top"><p>Description</p></td>
<td align="left" valign="top"><p>Required</p></td>
<td align="left" valign="top"><p>Default Value</p></td>
</tr>
<tr>
<td align="left" valign="top"><p><code class="literal">fields</code></p></td>
<td align="left" valign="top"><p>(array) Fields to analyze.</p></td>
<td align="left" valign="top"><p>Required</p></td>
<td align="left" valign="top"><p></p></td>
</tr>
<tr>
<td align="left" valign="top"><p><code class="literal">minimum_set_size</code></p></td>
<td align="left" valign="top"><p>(integer) The <a class="xref" href="search-aggregations-bucket.html#frequent-item-sets-minimum-set-size" title="Minimum set size">minimum size</a> of one item set.</p></td>
<td align="left" valign="top"><p>Optional</p></td>
<td align="left" valign="top"><p><code class="literal">1</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p><code class="literal">minimum_support</code></p></td>
<td align="left" valign="top"><p>(integer) The <a class="xref" href="search-aggregations-bucket.html#frequent-item-sets-minimum-support" title="Minimum support">minimum support</a> of one item set.</p></td>
<td align="left" valign="top"><p>Optional</p></td>
<td align="left" valign="top"><p><code class="literal">0.1</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p><code class="literal">size</code></p></td>
<td align="left" valign="top"><p>(integer) The number of top item sets to return.</p></td>
<td align="left" valign="top"><p>Optional</p></td>
<td align="left" valign="top"><p><code class="literal">10</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p><code class="literal">filter</code></p></td>
<td align="left" valign="top"><p>(object) Query that filters documents from the analysis</p></td>
<td align="left" valign="top"><p>Optional</p></td>
<td align="left" valign="top"><p><code class="literal">match_all</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<h4><a id="frequent-item-sets-fields"></a>Fields<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/frequent-item-sets-aggregation.asciidoc">edit</a></h4>
<p>Supported field types for the analyzed fields are keyword, numeric, ip, date,
and arrays of these types. You can also add runtime fields to your analyzed
fields.</p>
<p>If the combined cardinality of the analyzed fields are high, the aggregation
might require a significant amount of system resources.</p>
<p>You can filter the values for each field by using the <code class="literal">include</code> and <code class="literal">exclude</code>
parameters. The parameters can be regular expression strings or arrays of
strings of exact terms. The filtered values are removed from the analysis and
therefore reduce the runtime. If both <code class="literal">include</code> and <code class="literal">exclude</code> are defined,
<code class="literal">exclude</code> takes precedence; it means <code class="literal">include</code> is evaluated first and then
<code class="literal">exclude</code>.</p>
<h4><a id="frequent-item-sets-minimum-set-size"></a>Minimum set size<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/frequent-item-sets-aggregation.asciidoc">edit</a></h4>
<p>The minimum set size is the minimum number of items the set needs to contain. A
value of 1 returns the frequency of single items. Only item sets that contain at
least the number of <code class="literal">minimum_set_size</code> items are returned. For example, the item
set <code class="literal">orange, banana, apple</code> is returned only if the minimum set size is 3 or
lower.</p>
<h4><a id="frequent-item-sets-minimum-support"></a>Minimum support<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/frequent-item-sets-aggregation.asciidoc">edit</a></h4>
<p>The minimum support value is the ratio of documents that an item set must exist
in to be considered "frequent". In particular, it is a normalized value between
0 and 1. It is calculated by dividing the number of documents containing the
item set by the total number of documents.</p>
<p>For example, if a given item set is contained by five documents and the total
number of documents is 20, then the support of the item set is 5/20 = 0.25.
Therefore, this set is returned only if the minimum support is 0.25 or lower.
As a higher minimum support prunes more items, the calculation is less resource
intensive. The <code class="literal">minimum_support</code> parameter has an effect on the required memory
and the runtime of the aggregation.</p>
<h4><a id="frequent-item-sets-size"></a>Size<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/frequent-item-sets-aggregation.asciidoc">edit</a></h4>
<p>This parameter defines the maximum number of item sets to return. The result
contains top-k item sets; the item sets with the highest support values. This
parameter has a significant effect on the required memory and the runtime of the
aggregation.</p>
<h4><a id="frequent-item-sets-filter"></a>Filter<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/frequent-item-sets-aggregation.asciidoc">edit</a></h4>
<p>A query to filter documents to use as part of the analysis. Documents that
don&#8217;t match the filter are ignored when generating the item sets, however still
count when calculating the support of an item set.</p>
<p>Use the filter if you want to narrow the item set analysis to fields of interest.
Use a top-level query to filter the data set.</p>
<h4><a id="frequent-item-sets-example"></a>Examples<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/frequent-item-sets-aggregation.asciidoc">edit</a></h4>
<p>In the following examples, we use the e-commerce Kibana sample data set.</p>
<h4><a id="_aggregation_with_two_analyzed_fields_and_an_exclude_parameter"></a>Aggregation with two analyzed fields and an <code class="literal">exclude</code> parameter<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/frequent-item-sets-aggregation.asciidoc">edit</a></h4>
<p>In the first example, the goal is to find out based on transaction data (1.)
from what product categories the customers purchase products frequently together
and (2.) from which cities they make those purchases. We want to exclude results
where location information is not available (where the city name is <code class="literal">other</code>).
Finally, we are interested in sets with three or more items, and want to see the
first three frequent item sets with the highest support.</p>
<p>Note that we use the <a class="xref" href="search.html#async-search" title="Async search">async search</a> endpoint in this first
example.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /kibana_sample_data_ecommerce/_async_search
{
   "size":0,
   "aggs":{
      "my_agg":{
         "frequent_item_sets":{
            "minimum_set_size":3,
            "fields":[
               {
                  "field":"category.keyword"
               },
               {
                  "field":"geoip.city_name",
                  "exclude":"other"
               }
            ],
            "size":3
         }
      }
   }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1251.console"></div>
<p>The response of the API call above contains an identifier (<code class="literal">id</code>) of the async
search request. You can use the identifier to retrieve the search results:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_async_search/&lt;id&gt;</pre>
</div>
<div class="console_widget" data-snippet="snippets/1252.console"></div>
<p>The API returns a response similar to the following one:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">(...)
"aggregations" : {
    "my_agg" : {
      "buckets" : [ <a id="CO275-1"></a><i class="conum" data-value="1"></i>
        {
          "key" : { <a id="CO275-2"></a><i class="conum" data-value="2"></i>
            "category.keyword" : [
              "Women's Clothing",
              "Women's Shoes"
            ],
            "geoip.city_name" : [
              "New York"
            ]
          },
          "doc_count" : 217, <a id="CO275-3"></a><i class="conum" data-value="3"></i>
          "support" : 0.04641711229946524 <a id="CO275-4"></a><i class="conum" data-value="4"></i>
        },
        {
          "key" : {
            "category.keyword" : [
              "Women's Clothing",
              "Women's Accessories"
            ],
            "geoip.city_name" : [
              "New York"
            ]
          },
          "doc_count" : 135,
          "support" : 0.028877005347593583
        },
        {
          "key" : {
            "category.keyword" : [
              "Men's Clothing",
              "Men's Shoes"
            ],
            "geoip.city_name" : [
              "Cairo"
            ]
          },
          "doc_count" : 123,
          "support" : 0.026310160427807486
        }
      ],
    (...)
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO275-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The array of returned item sets.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO275-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">key</code> object contains one item set. In this case, it consists of two
values of the <code class="literal">category.keyword</code> field and one value of the <code class="literal">geoip.city_name</code>.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO275-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>The number of documents that contain the item set.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO275-4"><i class="conum" data-value="4"></i></a></p>
</td>
<td align="left" valign="top">
<p>The support value of the item set. It is calculated by dividing the number
of documents containing the item set by the total number of documents.</p>
</td>
</tr>
</table>
</div>
<p>The response shows that the categories customers purchase from most frequently
together are <code class="literal">Women's Clothing</code> and <code class="literal">Women's Shoes</code> and customers from New York
tend to buy items from these categories frequently together. In other words,
customers who buy products labelled <code class="literal">Women's Clothing</code> more likely buy products
also from the <code class="literal">Women's Shoes</code> category and customers from New York most likely
buy products from these categories together. The item set with the second
highest support is <code class="literal">Women's Clothing</code> and <code class="literal">Women's Accessories</code> with customers
mostly from New York. Finally, the item set with the third highest support is
<code class="literal">Men's Clothing</code> and <code class="literal">Men's Shoes</code> with customers mostly from Cairo.</p>
<h4><a id="_aggregation_with_two_analyzed_fields_and_a_filter"></a>Aggregation with two analyzed fields and a filter<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/frequent-item-sets-aggregation.asciidoc">edit</a></h4>
<p>We take the first example, but want to narrow the item sets to places in Europe.
For that, we add a filter, and this time, we don&#8217;t use the <code class="literal">exclude</code> parameter:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /kibana_sample_data_ecommerce/_async_search
{
  "size": 0,
  "aggs": {
    "my_agg": {
      "frequent_item_sets": {
        "minimum_set_size": 3,
        "fields": [
          { "field": "category.keyword" },
          { "field": "geoip.city_name" }
        ],
        "size": 3,
        "filter": {
          "term": {
            "geoip.continent_name": "Europe"
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1253.console"></div>
<p>The result will only show item sets that created from documents matching the
filter, namely purchases in Europe. Using <code class="literal">filter</code>, the calculated <code class="literal">support</code>
still takes all purchases into acount. That&#8217;s different than specifying a query
at the top-level, in which case <code class="literal">support</code> gets calculated only from purchases in
Europe.</p>
<h4><a id="_analyzing_numeric_values_by_using_a_runtime_field"></a>Analyzing numeric values by using a runtime field<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/frequent-item-sets-aggregation.asciidoc">edit</a></h4>
<p>The frequent items aggregation enables you to bucket numeric values by using
<a class="xref" href="runtime.html" title="Runtime fields">runtime fields</a>. The next example demonstrates how to use a script to
add a runtime field to your documents called <code class="literal">price_range</code>, which is
calculated from the taxful total price of the individual transactions. The
runtime field then can be used in the frequent items aggregation as a field to
analyze.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET kibana_sample_data_ecommerce/_search
{
  "runtime_mappings": {
    "price_range": {
      "type": "keyword",
      "script": {
        "source": """
           def bucket_start = (long) Math.floor(doc['taxful_total_price'].value / 50) * 50;
           def bucket_end = bucket_start + 50;
           emit(bucket_start.toString() + "-" + bucket_end.toString());
        """
      }
    }
  },
  "size": 0,
  "aggs": {
    "my_agg": {
      "frequent_item_sets": {
        "minimum_set_size": 4,
        "fields": [
          {
            "field": "category.keyword"
          },
          {
            "field": "price_range"
          },
          {
            "field": "geoip.city_name"
          }
        ],
        "size": 3
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1254.console"></div>
<p>The API returns a response similar to the following one:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">(...)
"aggregations" : {
    "my_agg" : {
      "buckets" : [
        {
          "key" : {
            "category.keyword" : [
              "Women's Clothing",
              "Women's Shoes"
            ],
            "price_range" : [
              "50-100"
            ],
            "geoip.city_name" : [
              "New York"
            ]
          },
          "doc_count" : 100,
          "support" : 0.0213903743315508
        },
        {
          "key" : {
            "category.keyword" : [
              "Women's Clothing",
              "Women's Shoes"
            ],
            "price_range" : [
              "50-100"
            ],
            "geoip.city_name" : [
              "Dubai"
            ]
          },
          "doc_count" : 59,
          "support" : 0.012620320855614974
        },
        {
          "key" : {
            "category.keyword" : [
              "Men's Clothing",
              "Men's Shoes"
            ],
            "price_range" : [
              "50-100"
            ],
            "geoip.city_name" : [
              "Marrakesh"
            ]
          },
          "doc_count" : 53,
          "support" : 0.011336898395721925
        }
      ],
    (...)
    }
  }</pre>
</div>
<p>The response shows the categories that customers purchase from most frequently
together, the location of the customers who tend to buy items from these
categories, and the most frequent price ranges of these purchases.</p>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-geodistance-aggregation"></a>Geo-distance aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/geodistance-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A multi-bucket aggregation that works on <code class="literal">geo_point</code> fields and conceptually works very similar to the <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-range-aggregation" title="Range aggregation">range</a> aggregation. The user can define a point of origin and a set of distance range buckets. The aggregation evaluates the distance of each document value from the origin point and determines the buckets it belongs to based on the ranges (a document belongs to a bucket if the distance between the document and the origin falls within the distance range of the bucket).</p>
<a id="geodistance-aggregation-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /museums
{
  "mappings": {
    "properties": {
      "location": {
        "type": "geo_point"
      }
    }
  }
}

POST /museums/_bulk?refresh
{"index":{"_id":1}}
{"location": "POINT (4.912350 52.374081)", "name": "NEMO Science Museum"}
{"index":{"_id":2}}
{"location": "POINT (4.901618 52.369219)", "name": "Museum Het Rembrandthuis"}
{"index":{"_id":3}}
{"location": "POINT (4.914722 52.371667)", "name": "Nederlands Scheepvaartmuseum"}
{"index":{"_id":4}}
{"location": "POINT (4.405200 51.222900)", "name": "Letterenhuis"}
{"index":{"_id":5}}
{"location": "POINT (2.336389 48.861111)", "name": "Musée du Louvre"}
{"index":{"_id":6}}
{"location": "POINT (2.327000 48.860000)", "name": "Musée d'Orsay"}

POST /museums/_search?size=0
{
  "aggs": {
    "rings_around_amsterdam": {
      "geo_distance": {
        "field": "location",
        "origin": "POINT (4.894 52.3760)",
        "ranges": [
          { "to": 100000 },
          { "from": 100000, "to": 300000 },
          { "from": 300000 }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1255.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "rings_around_amsterdam": {
      "buckets": [
        {
          "key": "*-100000.0",
          "from": 0.0,
          "to": 100000.0,
          "doc_count": 3
        },
        {
          "key": "100000.0-300000.0",
          "from": 100000.0,
          "to": 300000.0,
          "doc_count": 1
        },
        {
          "key": "300000.0-*",
          "from": 300000.0,
          "doc_count": 2
        }
      ]
    }
  }
}</pre>
</div>
<p>The specified field must be of type <code class="literal">geo_point</code> (which can only be set explicitly in the mappings). And it can also hold an array of <code class="literal">geo_point</code> fields, in which case all will be taken into account during aggregation. The origin point can accept all formats supported by the <a class="xref" href="mapping-types.html#geo-point" title="Geopoint field type"><code class="literal">geo_point</code> type</a>:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Object format: <code class="literal">{ "lat" : 52.3760, "lon" : 4.894 }</code> - this is the safest format as it is the most explicit about the <code class="literal">lat</code> &amp; <code class="literal">lon</code> values
</li>
<li class="listitem">
String format: <code class="literal">"52.3760, 4.894"</code> - where the first number is the <code class="literal">lat</code> and the second is the <code class="literal">lon</code>
</li>
<li class="listitem">
Array format: <code class="literal">[4.894, 52.3760]</code> - which is based on the GeoJSON standard where the first number is the <code class="literal">lon</code> and the second one is the <code class="literal">lat</code>
</li>
</ul>
</div>
<p>By default, the distance unit is <code class="literal">m</code> (meters) but it can also accept: <code class="literal">mi</code> (miles), <code class="literal">in</code> (inches), <code class="literal">yd</code> (yards), <code class="literal">km</code> (kilometers), <code class="literal">cm</code> (centimeters), <code class="literal">mm</code> (millimeters).</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /museums/_search?size=0
{
  "aggs": {
    "rings": {
      "geo_distance": {
        "field": "location",
        "origin": "POINT (4.894 52.3760)",
        "unit": "km", <a id="CO276-1"></a><i class="conum" data-value="1"></i>
        "ranges": [
          { "to": 100 },
          { "from": 100, "to": 300 },
          { "from": 300 }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1256.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO276-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The distances will be computed in kilometers</p>
</td>
</tr>
</table>
</div>
<p>There are two distance calculation modes: <code class="literal">arc</code> (the default), and <code class="literal">plane</code>. The <code class="literal">arc</code> calculation is the most accurate. The <code class="literal">plane</code> is the fastest but least accurate. Consider using <code class="literal">plane</code> when your search context is "narrow", and spans smaller geographical areas (~5km). <code class="literal">plane</code> will return higher error margins for searches across very large areas (e.g. cross continent search). The distance calculation type can be set using the <code class="literal">distance_type</code> parameter:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /museums/_search?size=0
{
  "aggs": {
    "rings": {
      "geo_distance": {
        "field": "location",
        "origin": "POINT (4.894 52.3760)",
        "unit": "km",
        "distance_type": "plane",
        "ranges": [
          { "to": 100 },
          { "from": 100, "to": 300 },
          { "from": 300 }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1257.console"></div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_keyed_response_2"></a>Keyed Response<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/geodistance-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Setting the <code class="literal">keyed</code> flag to <code class="literal">true</code> will associate a unique string key with each bucket and return the ranges as a hash rather than an array:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /museums/_search?size=0
{
  "aggs": {
    "rings_around_amsterdam": {
      "geo_distance": {
        "field": "location",
        "origin": "POINT (4.894 52.3760)",
        "ranges": [
          { "to": 100000 },
          { "from": 100000, "to": 300000 },
          { "from": 300000 }
        ],
        "keyed": true
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1258.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "rings_around_amsterdam": {
      "buckets": {
        "*-100000.0": {
          "from": 0.0,
          "to": 100000.0,
          "doc_count": 3
        },
        "100000.0-300000.0": {
          "from": 100000.0,
          "to": 300000.0,
          "doc_count": 1
        },
        "300000.0-*": {
          "from": 300000.0,
          "doc_count": 2
        }
      }
    }
  }
}</pre>
</div>
<p>It is also possible to customize the key for each range:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /museums/_search?size=0
{
  "aggs": {
    "rings_around_amsterdam": {
      "geo_distance": {
        "field": "location",
        "origin": "POINT (4.894 52.3760)",
        "ranges": [
          { "to": 100000, "key": "first_ring" },
          { "from": 100000, "to": 300000, "key": "second_ring" },
          { "from": 300000, "key": "third_ring" }
        ],
        "keyed": true
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1259.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "rings_around_amsterdam": {
      "buckets": {
        "first_ring": {
          "from": 0.0,
          "to": 100000.0,
          "doc_count": 3
        },
        "second_ring": {
          "from": 100000.0,
          "to": 300000.0,
          "doc_count": 1
        },
        "third_ring": {
          "from": 300000.0,
          "doc_count": 2
        }
      }
    }
  }
}</pre>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-geohashgrid-aggregation"></a>Geohash grid aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/geohashgrid-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A multi-bucket aggregation that groups <a class="xref" href="mapping-types.html#geo-point" title="Geopoint field type"><code class="literal">geo_point</code></a> and
<a class="xref" href="mapping-types.html#geo-shape" title="Geoshape field type"><code class="literal">geo_shape</code></a> values into buckets that represent a grid.
The resulting grid can be sparse and only contains cells that have matching data. Each cell is labeled using a <a href="https://en.wikipedia.org/wiki/Geohash" class="ulink" target="_top">geohash</a> which is of user-definable precision.</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
High precision geohashes have a long string length and represent cells that cover only a small area.
</li>
<li class="listitem">
Low precision geohashes have a short string length and represent cells that each cover a large area.
</li>
</ul>
</div>
<p>Geohashes used in this aggregation can have a choice of precision between 1 and 12.</p>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>The highest-precision geohash of length 12 produces cells that cover less than a square metre of land and so high-precision requests can be very costly in terms of RAM and result sizes.
Please see the example below on how to first filter the aggregation to a smaller geographic area before requesting high-levels of detail.</p>
</div>
</div>
<p>You can only use <code class="literal">geohash_grid</code> to aggregate an explicitly mapped <code class="literal">geo_point</code> or
<code class="literal">geo_shape</code> field. If the <code class="literal">geo_point</code> field contains an array, <code class="literal">geohash_grid</code>
aggregates all the array values.</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_simple_low_precision_request"></a>Simple low-precision request<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/geohashgrid-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<a id="geohashgrid-aggregation-low-precision-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /museums
{
  "mappings": {
    "properties": {
      "location": {
        "type": "geo_point"
      }
    }
  }
}

POST /museums/_bulk?refresh
{"index":{"_id":1}}
{"location": "POINT (4.912350 52.374081)", "name": "NEMO Science Museum"}
{"index":{"_id":2}}
{"location": "POINT (4.901618 52.369219)", "name": "Museum Het Rembrandthuis"}
{"index":{"_id":3}}
{"location": "POINT (4.914722 52.371667)", "name": "Nederlands Scheepvaartmuseum"}
{"index":{"_id":4}}
{"location": "POINT (4.405200 51.222900)", "name": "Letterenhuis"}
{"index":{"_id":5}}
{"location": "POINT (2.336389 48.861111)", "name": "Musée du Louvre"}
{"index":{"_id":6}}
{"location": "POINT (2.327000 48.860000)", "name": "Musée d'Orsay"}

POST /museums/_search?size=0
{
  "aggregations": {
    "large-grid": {
      "geohash_grid": {
        "field": "location",
        "precision": 3
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1260.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
  "large-grid": {
    "buckets": [
      {
        "key": "u17",
        "doc_count": 3
      },
      {
        "key": "u09",
        "doc_count": 2
      },
      {
        "key": "u15",
        "doc_count": 1
      }
    ]
  }
}
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_high_precision_requests"></a>High-precision requests<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/geohashgrid-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>When requesting detailed buckets (typically for displaying a "zoomed in" map) a filter like <a class="xref" href="geo-queries.html#query-dsl-geo-bounding-box-query" title="Geo-bounding box query">geo_bounding_box</a> should be applied to narrow the subject area otherwise potentially millions of buckets will be created and returned.</p>
<a id="geohashgrid-aggregation-high-precision-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /museums/_search?size=0
{
  "aggregations": {
    "zoomed-in": {
      "filter": {
        "geo_bounding_box": {
          "location": {
            "top_left": "POINT (4.9 52.4)",
            "bottom_right": "POINT (5.0 52.3)"
          }
        }
      },
      "aggregations": {
        "zoom1": {
          "geohash_grid": {
            "field": "location",
            "precision": 8
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1261.console"></div>
<p>The geohashes returned by the <code class="literal">geohash_grid</code> aggregation can be also used for zooming in. To zoom into the
first geohash <code class="literal">u17</code> returned in the previous example, it should be specified as both <code class="literal">top_left</code> and <code class="literal">bottom_right</code> corner:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /museums/_search?size=0
{
  "aggregations": {
    "zoomed-in": {
      "filter": {
        "geo_bounding_box": {
          "location": {
            "top_left": "u17",
            "bottom_right": "u17"
          }
        }
      },
      "aggregations": {
        "zoom1": {
          "geohash_grid": {
            "field": "location",
            "precision": 8
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1262.console"></div>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "zoomed-in": {
      "doc_count": 3,
      "zoom1": {
        "buckets": [
          {
            "key": "u173zy3j",
            "doc_count": 1
          },
          {
            "key": "u173zvfz",
            "doc_count": 1
          },
          {
            "key": "u173zt90",
            "doc_count": 1
          }
        ]
      }
    }
  }
}</pre>
</div>
<p>For "zooming in" on the system that don&#8217;t support geohashes, the bucket keys should be translated into bounding boxes using
one of available geohash libraries. For example, for javascript the <a href="https://github.com/sunng87/node-geohash" class="ulink" target="_top">node-geohash</a> library
can be used:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">var geohash = require('ngeohash');

// bbox will contain [ 52.03125, 4.21875, 53.4375, 5.625 ]
//                   [   minlat,  minlon,  maxlat, maxlon]
var bbox = geohash.decode_bbox('u17');</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_requests_with_additional_bounding_box_filtering"></a>Requests with additional bounding box filtering<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/geohashgrid-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">geohash_grid</code> aggregation supports an optional <code class="literal">bounds</code> parameter
that restricts the cells considered to those that intersects the
bounds provided. The <code class="literal">bounds</code> parameter accepts the bounding box in
all the same <a class="xref" href="geo-queries.html#query-dsl-geo-bounding-box-query-accepted-formats" title="Accepted formats">accepted formats</a> of the
bounds specified in the Geo Bounding Box Query. This bounding box can be used with or
without an additional <code class="literal">geo_bounding_box</code> query filtering the points prior to aggregating.
It is an independent bounding box that can intersect with, be equal to, or be disjoint
to any additional <code class="literal">geo_bounding_box</code> queries defined in the context of the aggregation.</p>
<a id="geohashgrid-aggregation-with-bounds"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /museums/_search?size=0
{
  "aggregations": {
    "tiles-in-bounds": {
      "geohash_grid": {
        "field": "location",
        "precision": 8,
        "bounds": {
          "top_left": "POINT (4.21875 53.4375)",
          "bottom_right": "POINT (5.625 52.03125)"
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1263.console"></div>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "tiles-in-bounds": {
      "buckets": [
        {
          "key": "u173zy3j",
          "doc_count": 1
        },
        {
          "key": "u173zvfz",
          "doc_count": 1
        },
        {
          "key": "u173zt90",
          "doc_count": 1
        }
      ]
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_cell_dimensions_at_the_equator"></a>Cell dimensions at the equator<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/geohashgrid-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The table below shows the metric dimensions for cells covered by various string lengths of geohash.
Cell dimensions vary with latitude and so the table is for the worst-case scenario at the equator.</p>
<div class="informaltable">
<table border="0" cellpadding="4px">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody valign="top">
<tr>
<td valign="top">
<p>
<span class="strong strong"><strong>GeoHash length</strong></span>
</p>
</td>
<td valign="top">
<p>
<span class="strong strong"><strong>Area width x height</strong></span>
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
1
</p>
</td>
<td valign="top">
<p>
5,009.4km x 4,992.6km
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
2
</p>
</td>
<td valign="top">
<p>
1,252.3km x 624.1km
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
3
</p>
</td>
<td valign="top">
<p>
156.5km x 156km
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
4
</p>
</td>
<td valign="top">
<p>
39.1km x 19.5km
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
5
</p>
</td>
<td valign="top">
<p>
4.9km x 4.9km
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
6
</p>
</td>
<td valign="top">
<p>
1.2km x 609.4m
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
7
</p>
</td>
<td valign="top">
<p>
152.9m x 152.4m
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
8
</p>
</td>
<td valign="top">
<p>
38.2m x 19m
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
9
</p>
</td>
<td valign="top">
<p>
4.8m x 4.8m
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
10
</p>
</td>
<td valign="top">
<p>
1.2m x 59.5cm
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
11
</p>
</td>
<td valign="top">
<p>
14.9cm x 14.9cm
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
12
</p>
</td>
<td valign="top">
<p>
3.7cm x 1.9cm
</p>
</td>
</tr>
</tbody>
</table>
</div>
<h4 class="xpack"><a id="_aggregating_geo_shape_fields"></a>Aggregating <code class="literal">geo_shape</code> fields<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/geohashgrid-aggregation.asciidoc">edit</a></h4>
<p>Aggregating on <a class="xref" href="mapping-types.html#geo-shape" title="Geoshape field type">Geoshape</a> fields works just as it does for points, except that a single
shape can be counted for in multiple tiles. A shape will contribute to the count of matching values
if any part of its shape intersects with that tile. Below is an image that demonstrates this:</p>
<p><span class="image"><img src="images/spatial/geoshape_grid.png" alt="geoshape grid"></span></p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_options_3"></a>Options<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/geohashgrid-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<div class="informaltable">
<table border="0" cellpadding="4px">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody valign="top">
<tr>
<td valign="top">
<p>
field
</p>
</td>
<td valign="top">
<p>
Mandatory. Field containing indexed geo-point or geo-shape
values. Must be explicitly mapped as a <a class="xref" href="mapping-types.html#geo-point" title="Geopoint field type"><code class="literal">geo_point</code></a>
or a <a class="xref" href="mapping-types.html#geo-shape" title="Geoshape field type"><code class="literal">geo_shape</code></a> field. If the field contains an
array, <code class="literal">geohash_grid</code> aggregates all array values.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
precision
</p>
</td>
<td valign="top">
<p>
Optional. The string length of the geohashes used to define
cells/buckets in the results. Defaults to 5.
The precision can either be defined in terms of the integer
precision levels mentioned above. Values outside of [1,12] will
be rejected.
Alternatively, the precision level can be approximated from a
distance measure like "1km", "10m". The precision level is
calculate such that cells will not exceed the specified
size (diagonal) of the required precision. When this would lead
to precision levels higher than the supported 12 levels,
(e.g. for distances &lt;5.6cm) the value is rejected.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
bounds
</p>
</td>
<td valign="top">
<p>
Optional. The bounding box to filter the points in the bucket.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
size
</p>
</td>
<td valign="top">
<p>
Optional. The maximum number of geohash buckets to return
(defaults to 10,000). When results are trimmed, buckets are
prioritised based on the volumes of documents they contain.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
shard_size
</p>
</td>
<td valign="top">
<p>
Optional. To allow for more accurate counting of the top cells
returned in the final result the aggregation defaults to
returning <code class="literal">max(10,(size x number-of-shards))</code> buckets from each
shard. If this heuristic is undesirable, the number considered
from each shard can be over-ridden using this parameter.
</p>
</td>
</tr>
</tbody>
</table>
</div>
</div>

</div>

<div class="section xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-geohexgrid-aggregation"></a>Geohex grid aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/geohexgrid-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A multi-bucket aggregation that groups <a class="xref" href="mapping-types.html#geo-point" title="Geopoint field type"><code class="literal">geo_point</code></a> and
<a class="xref" href="mapping-types.html#geo-shape" title="Geoshape field type"><code class="literal">geo_shape</code></a> values into buckets that represent a grid.
The resulting grid can be sparse and only
contains cells that have matching data. Each cell corresponds to a
<a href="https://h3geo.org/docs/core-library/h3Indexing#h3-cell-indexp" class="ulink" target="_top">H3 cell index</a> and is
labeled using the <a href="https://h3geo.org/docs/core-library/h3Indexing#h3index-representation" class="ulink" target="_top">H3Index representation</a>.</p>
<p>See <a href="https://h3geo.org/docs/core-library/restable" class="ulink" target="_top">the table of cell areas for H3
resolutions</a> on how precision (zoom) correlates to size on the ground.
Precision for this aggregation can be between 0 and 15, inclusive.</p>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>High-precision requests can be very expensive in terms of RAM and
result sizes. For example, the highest-precision geohex with a precision of 15
produces cells that cover less than one square meter. We recommend you use a
filter to limit high-precision requests to a smaller geographic area. For an example,
refer to <a class="xref" href="search-aggregations-bucket.html#geohexgrid-high-precision" title="High-precision requests">High-precision requests</a>.</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="geohexgrid-low-precision"></a>Simple low-precision request<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/geohexgrid-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<a id="geohexgrid-aggregation-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /museums
{
  "mappings": {
    "properties": {
      "location": {
        "type": "geo_point"
      }
    }
  }
}

POST /museums/_bulk?refresh
{"index":{"_id":1}}
{"location": "POINT (4.912350 52.374081)", "name": "NEMO Science Museum"}
{"index":{"_id":2}}
{"location": "POINT (4.901618 52.369219)", "name": "Museum Het Rembrandthuis"}
{"index":{"_id":3}}
{"location": "POINT (4.914722 52.371667)", "name": "Nederlands Scheepvaartmuseum"}
{"index":{"_id":4}}
{"location": "POINT (4.405200 51.222900)", "name": "Letterenhuis"}
{"index":{"_id":5}}
{"location": "POINT (2.336389 48.861111)", "name": "Musée du Louvre"}
{"index":{"_id":6}}
{"location": "POINT (2.327000 48.860000)", "name": "Musée d'Orsay"}

POST /museums/_search?size=0
{
  "aggregations": {
    "large-grid": {
      "geohex_grid": {
        "field": "location",
        "precision": 4
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1264.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "large-grid": {
      "buckets": [
        {
          "key": "841969dffffffff",
          "doc_count": 3
        },
        {
          "key": "841fb47ffffffff",
          "doc_count": 2
        },
        {
          "key": "841fa4dffffffff",
          "doc_count": 1
        }
      ]
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="geohexgrid-high-precision"></a>High-precision requests<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/geohexgrid-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>When requesting detailed buckets (typically for displaying a "zoomed in" map),
a filter like <a class="xref" href="geo-queries.html#query-dsl-geo-bounding-box-query" title="Geo-bounding box query">geo_bounding_box</a> should be
applied to narrow the subject area. Otherwise, potentially millions of buckets
will be created and returned.</p>
<a id="geohexgrid-high-precision-ex"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /museums/_search?size=0
{
  "aggregations": {
    "zoomed-in": {
      "filter": {
        "geo_bounding_box": {
          "location": {
            "top_left": "POINT (4.9 52.4)",
            "bottom_right": "POINT (5.0 52.3)"
          }
        }
      },
      "aggregations": {
        "zoom1": {
          "geohex_grid": {
            "field": "location",
            "precision": 12
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1265.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "zoomed-in": {
      "doc_count": 3,
      "zoom1": {
        "buckets": [
          {
            "key": "8c1969c9b2617ff",
            "doc_count": 1
          },
          {
            "key": "8c1969526d753ff",
            "doc_count": 1
          },
          {
            "key": "8c1969526d26dff",
            "doc_count": 1
          }
        ]
      }
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="geohexgrid-addtl-bounding-box-filtering"></a>Requests with additional bounding box filtering<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/geohexgrid-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">geohex_grid</code> aggregation supports an optional <code class="literal">bounds</code> parameter
that restricts the cells considered to those that intersect the
provided bounds. The <code class="literal">bounds</code> parameter accepts the same
<a class="xref" href="geo-queries.html#query-dsl-geo-bounding-box-query-accepted-formats" title="Accepted formats">bounding box formats</a>
as the geo-bounding box query. This bounding box can be used with or
without an additional <code class="literal">geo_bounding_box</code> query for filtering the points prior to aggregating.
It is an independent bounding box that can intersect with, be equal to, or be disjoint
to any additional <code class="literal">geo_bounding_box</code> queries defined in the context of the aggregation.</p>
<a id="geohexgrid-aggregation-with-bounds"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /museums/_search?size=0
{
  "aggregations": {
    "tiles-in-bounds": {
      "geohex_grid": {
        "field": "location",
        "precision": 12,
        "bounds": {
          "top_left": "POINT (4.9 52.4)",
          "bottom_right": "POINT (5.0 52.3)"
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1266.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "tiles-in-bounds": {
      "buckets": [
        {
          "key": "8c1969c9b2617ff",
          "doc_count": 1
        },
        {
          "key": "8c1969526d753ff",
          "doc_count": 1
        },
        {
          "key": "8c1969526d26dff",
          "doc_count": 1
        }
      ]
    }
  }
}</pre>
</div>
<h4 class="xpack"><a id="geohexgrid-aggregating-geo-shape"></a>Aggregating <code class="literal">geo_shape</code> fields<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/geohexgrid-aggregation.asciidoc">edit</a></h4>
<p>Aggregating on <a class="xref" href="mapping-types.html#geo-shape" title="Geoshape field type">Geoshape</a> fields works almost as it does for points. There are two key differences:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
When aggregating over <code class="literal">geo_point</code> data, points are considered within a hexagonal tile if they lie
within the edges defined by great circles. In other words the calculation is done using spherical coordinates.
However, when aggregating over <code class="literal">geo_shape</code> data, the shapes are considered within a hexagon if they lie
within the edges defined as straight lines on an equirectangular projection.
The reason is that Elasticsearch and Lucene treat edges using the equirectangular projection at index and search time.
In order to ensure that search results and aggregation results are aligned, we therefore also use equirectangular
projection in aggregations.
For most data, the difference is subtle or not noticed.
However, for low zoom levels (low precision), especially far from the equator,  this can be noticeable.
For example, if the same point data is indexed as <code class="literal">geo_point</code> and <code class="literal">geo_shape</code>, it is possible  to get
different results when aggregating at lower resolutions.
</li>
<li class="listitem">
As is the case with <a class="xref" href="search-aggregations-bucket.html#geotilegrid-aggregating-geo-shape" title="Aggregating geo_shape fields"><code class="literal">geotile_grid</code></a>,
a single shape can be counted for in multiple tiles. A shape will contribute to the count of matching values
if any part of its shape intersects with that tile. Below is an image that demonstrates this:
</li>
</ul>
</div>
<p><span class="image"><img src="images/spatial/geoshape_hexgrid.png" alt="geoshape hexgrid"></span></p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_options_4"></a>Options<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/geohexgrid-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<div class="informaltable">
<table border="0" cellpadding="4px">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody valign="top">
<tr>
<td valign="top">
<p>
field
</p>
</td>
<td valign="top">
<p>
(Required, string) Field containing indexed geo-point or geo-shape values.
Must be explicitly mapped as a <a class="xref" href="mapping-types.html#geo-point" title="Geopoint field type"><code class="literal">geo_point</code></a> or a <a class="xref" href="mapping-types.html#geo-shape" title="Geoshape field type"><code class="literal">geo_shape</code></a> field.
If the field contains an array, <code class="literal">geohex_grid</code> aggregates all array values.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
precision
</p>
</td>
<td valign="top">
<p>
(Optional, integer) Integer zoom of the key used to define cells/buckets in
the results. Defaults to <code class="literal">6</code>. Values outside of [<code class="literal">0</code>,<code class="literal">15</code>] will be rejected.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
bounds
</p>
</td>
<td valign="top">
<p>
(Optional, object) Bounding box used to filter the geo-points or geo-shapes in each bucket.
Accepts the same bounding box formats as the
<a class="xref" href="geo-queries.html#query-dsl-geo-bounding-box-query-accepted-formats" title="Accepted formats">geo-bounding box query</a>.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
size
</p>
</td>
<td valign="top">
<p>
(Optional, integer) Maximum number of buckets to return. Defaults to 10,000.
When results are trimmed, buckets are prioritized based on the volume of
documents they contain.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
shard_size
</p>
</td>
<td valign="top">
<p>
(Optional, integer) Number of buckets returned from each shard. Defaults to
<code class="literal">max(10,(size x number-of-shards))</code> to allow for a more accurate count of the
top cells in the final result. Since each shard could have a different top result order,
using a larger number here reduces the risk of inaccurate counts, but incurs a performance cost.
</p>
</td>
</tr>
</tbody>
</table>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-geotilegrid-aggregation"></a>Geotile grid aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/geotilegrid-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A multi-bucket aggregation that groups <a class="xref" href="mapping-types.html#geo-point" title="Geopoint field type"><code class="literal">geo_point</code></a> and
<a class="xref" href="mapping-types.html#geo-shape" title="Geoshape field type"><code class="literal">geo_shape</code></a> values into buckets that represent a grid.
The resulting grid can be sparse and only
contains cells that have matching data. Each cell corresponds to a
<a href="https://en.wikipedia.org/wiki/Tiled_web_map" class="ulink" target="_top">map tile</a> as used by many online map
sites. Each cell is labeled using a "{zoom}/{x}/{y}" format, where zoom is equal
to the user-specified precision.</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
High precision keys have a larger range for x and y, and represent tiles that
cover only a small area.
</li>
<li class="listitem">
Low precision keys have a smaller range for x and y, and represent tiles that
each cover a large area.
</li>
</ul>
</div>
<p>See <a href="https://wiki.openstreetmap.org/wiki/Zoom_levels" class="ulink" target="_top">zoom level documentation</a>
on how precision (zoom) correlates to size on the ground. Precision for this
aggregation can be between 0 and 29, inclusive.</p>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>The highest-precision geotile of length 29 produces cells that cover
less than a 10cm by 10cm of land and so high-precision requests can be very
costly in terms of RAM and result sizes. Please see the example below on how
to first filter the aggregation to a smaller geographic area before requesting
high-levels of detail.</p>
</div>
</div>
<p>You can only use <code class="literal">geotile_grid</code> to aggregate an explicitly mapped <code class="literal">geo_point</code> or
<code class="literal">geo_shape</code> field. If the <code class="literal">geo_point</code> field contains an array, <code class="literal">geotile_grid</code>
aggregates all the array values.</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_simple_low_precision_request_2"></a>Simple low-precision request<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/geotilegrid-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<a id="geotilegrid-aggregation-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /museums
{
  "mappings": {
    "properties": {
      "location": {
        "type": "geo_point"
      }
    }
  }
}

POST /museums/_bulk?refresh
{"index":{"_id":1}}
{"location": "POINT (4.912350 52.374081)", "name": "NEMO Science Museum"}
{"index":{"_id":2}}
{"location": "POINT (4.901618 52.369219)", "name": "Museum Het Rembrandthuis"}
{"index":{"_id":3}}
{"location": "POINT (4.914722 52.371667)", "name": "Nederlands Scheepvaartmuseum"}
{"index":{"_id":4}}
{"location": "POINT (4.405200 51.222900)", "name": "Letterenhuis"}
{"index":{"_id":5}}
{"location": "POINT (2.336389 48.861111)", "name": "Musée du Louvre"}
{"index":{"_id":6}}
{"location": "POINT (2.327000 48.860000)", "name": "Musée d'Orsay"}

POST /museums/_search?size=0
{
  "aggregations": {
    "large-grid": {
      "geotile_grid": {
        "field": "location",
        "precision": 8
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1267.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "large-grid": {
      "buckets": [
        {
          "key": "8/131/84",
          "doc_count": 3
        },
        {
          "key": "8/129/88",
          "doc_count": 2
        },
        {
          "key": "8/131/85",
          "doc_count": 1
        }
      ]
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="geotilegrid-high-precision"></a>High-precision requests<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/geotilegrid-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>When requesting detailed buckets (typically for displaying a "zoomed in" map),
a filter like <a class="xref" href="geo-queries.html#query-dsl-geo-bounding-box-query" title="Geo-bounding box query">geo_bounding_box</a> should be
applied to narrow the subject area. Otherwise, potentially millions of buckets
will be created and returned.</p>
<a id="geotilegrid-high-precision-ex"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /museums/_search?size=0
{
  "aggregations": {
    "zoomed-in": {
      "filter": {
        "geo_bounding_box": {
          "location": {
            "top_left": "POINT (4.9 52.4)",
            "bottom_right": "POINT (5.0 52.3)"
          }
        }
      },
      "aggregations": {
        "zoom1": {
          "geotile_grid": {
            "field": "location",
            "precision": 22
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1268.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "zoomed-in": {
      "doc_count": 3,
      "zoom1": {
        "buckets": [
          {
            "key": "22/2154412/1378379",
            "doc_count": 1
          },
          {
            "key": "22/2154385/1378332",
            "doc_count": 1
          },
          {
            "key": "22/2154259/1378425",
            "doc_count": 1
          }
        ]
      }
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="geotilegrid-addtl-bounding-box-filtering"></a>Requests with additional bounding box filtering<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/geotilegrid-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">geotile_grid</code> aggregation supports an optional <code class="literal">bounds</code> parameter
that restricts the cells considered to those that intersect the
provided bounds. The <code class="literal">bounds</code> parameter accepts the same
<a class="xref" href="geo-queries.html#query-dsl-geo-bounding-box-query-accepted-formats" title="Accepted formats">bounding box formats</a>
as the geo-bounding box query. This bounding box can be used with or
without an additional <code class="literal">geo_bounding_box</code> query for filtering the points prior to aggregating.
It is an independent bounding box that can intersect with, be equal to, or be disjoint
to any additional <code class="literal">geo_bounding_box</code> queries defined in the context of the aggregation.</p>
<a id="geotilegrid-aggregation-with-bounds"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /museums/_search?size=0
{
  "aggregations": {
    "tiles-in-bounds": {
      "geotile_grid": {
        "field": "location",
        "precision": 22,
        "bounds": {
          "top_left": "POINT (4.9 52.4)",
          "bottom_right": "POINT (5.0 52.3)"
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1269.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "tiles-in-bounds": {
      "buckets": [
        {
          "key": "22/2154412/1378379",
          "doc_count": 1
        },
        {
          "key": "22/2154385/1378332",
          "doc_count": 1
        },
        {
          "key": "22/2154259/1378425",
          "doc_count": 1
        }
      ]
    }
  }
}</pre>
</div>
<h4 class="xpack"><a id="geotilegrid-aggregating-geo-shape"></a>Aggregating <code class="literal">geo_shape</code> fields<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/geotilegrid-aggregation.asciidoc">edit</a></h4>
<p>Aggregating on <a class="xref" href="mapping-types.html#geo-shape" title="Geoshape field type">Geoshape</a> fields works almost as it does for points, except that a single
shape can be counted for in multiple tiles. A shape will contribute to the count of matching values
if any part of its shape intersects with that tile. Below is an image that demonstrates this:</p>
<p><span class="image"><img src="images/spatial/geoshape_grid.png" alt="geoshape grid"></span></p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_options_5"></a>Options<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/geotilegrid-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<div class="informaltable">
<table border="0" cellpadding="4px">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody valign="top">
<tr>
<td valign="top">
<p>
field
</p>
</td>
<td valign="top">
<p>
(Required, string) Field containing indexed geo-point or geo-shape values.
Must be explicitly mapped as a <a class="xref" href="mapping-types.html#geo-point" title="Geopoint field type"><code class="literal">geo_point</code></a> or a <a class="xref" href="mapping-types.html#geo-shape" title="Geoshape field type"><code class="literal">geo_shape</code></a> field.
If the field contains an array, <code class="literal">geotile_grid</code> aggregates all array values.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
precision
</p>
</td>
<td valign="top">
<p>
(Optional, integer) Integer zoom of the key used to define cells/buckets in
the results. Defaults to <code class="literal">7</code>. Values outside of [<code class="literal">0</code>,<code class="literal">29</code>] will be rejected.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
bounds
</p>
</td>
<td valign="top">
<p>
(Optional, object) Bounding box used to filter the geo-points or geo-shapes in each bucket.
Accepts the same bounding box formats as the
<a class="xref" href="geo-queries.html#query-dsl-geo-bounding-box-query-accepted-formats" title="Accepted formats">geo-bounding box query</a>.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
size
</p>
</td>
<td valign="top">
<p>
(Optional, integer) Maximum number of buckets to return. Defaults to 10,000.
When results are trimmed, buckets are prioritized based on the volume of
documents they contain.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
shard_size
</p>
</td>
<td valign="top">
<p>
(Optional, integer) Number of buckets returned from each shard. Defaults to
<code class="literal">max(10,(size x number-of-shards))</code> to allow for a more accurate count of the
top cells in the final result. Since each shard could have a different top result order,
using a larger number here reduces the risk of inaccurate counts, but incurs a performance cost.
</p>
</td>
</tr>
</tbody>
</table>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-global-aggregation"></a>Global aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/global-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>Defines a single bucket of all the documents within the search execution
context. This context is defined by the indices and the document types you&#8217;re
searching on, but is <span class="strong strong"><strong>not</strong></span> influenced by the search query itself.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>Global aggregators can only be placed as top level aggregators because
        it doesn&#8217;t make sense to embed a global aggregator within another
        bucket aggregator.</p>
</div>
</div>
<p>Example:</p>
<a id="global-aggregation-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "query": {
    "match": { "type": "t-shirt" }
  },
  "aggs": {
    "all_products": {
      "global": {}, <a id="CO277-1"></a><i class="conum" data-value="1"></i>
      "aggs": {     <a id="CO277-2"></a><i class="conum" data-value="2"></i>
      "avg_price": { "avg": { "field": "price" } }
      }
    },
    "t_shirts": { "avg": { "field": "price" } }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1270.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO277-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">global</code> aggregation has an empty body</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO277-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>The sub-aggregations that are registered for this <code class="literal">global</code> aggregation</p>
</td>
</tr>
</table>
</div>
<p>The above aggregation demonstrates how one would compute aggregations
(<code class="literal">avg_price</code> in this example) on all the documents in the search context,
regardless of the query (in our example, it will compute the average price over
all products in our catalog, not just on the "shirts").</p>
<p>The response for the above aggregation:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "all_products": {
      "doc_count": 7, <a id="CO278-1"></a><i class="conum" data-value="1"></i>
      "avg_price": {
        "value": 140.71428571428572 <a id="CO278-2"></a><i class="conum" data-value="2"></i>
      }
    },
    "t_shirts": {
      "value": 128.33333333333334 <a id="CO278-3"></a><i class="conum" data-value="3"></i>
    }
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO278-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The number of documents that were aggregated (in our case, all documents
within the search context)</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO278-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>The average price of all products in the index</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO278-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>The average price of all t-shirts</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-histogram-aggregation"></a>Histogram aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/histogram-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A multi-bucket values source based aggregation that can be applied on numeric values or numeric range values extracted
from the documents. It dynamically builds fixed size (a.k.a. interval) buckets over the values. For example, if the
documents have a field that holds a price (numeric), we can configure this aggregation to dynamically build buckets with
interval <code class="literal">5</code> (in case of price it may represent $5). When the aggregation executes, the price field of every document
will be evaluated and will be rounded down to its closest bucket - for example, if the price is <code class="literal">32</code> and the bucket size
is <code class="literal">5</code> then the rounding will yield <code class="literal">30</code> and thus the document will "fall" into the bucket that is associated with the
key <code class="literal">30</code>.
To make this more formal, here is the rounding function that is used:</p>
<div class="pre_wrapper lang-java">
<pre class="programlisting prettyprint lang-java">bucket_key = Math.floor((value - offset) / interval) * interval + offset</pre>
</div>
<p>For range values, a document can fall into multiple buckets. The first bucket is computed from the lower
bound of the range in the same way as a bucket for a single value is computed. The final bucket is computed in the same
way from the upper bound of the range, and the range is counted in all buckets in between and including those two.</p>
<p>The <code class="literal">interval</code> must be a positive decimal, while the <code class="literal">offset</code> must be a decimal in <code class="literal">[0, interval)</code>
(a decimal greater than or equal to <code class="literal">0</code> and less than <code class="literal">interval</code>)</p>
<p>The following snippet "buckets" the products based on their <code class="literal">price</code> by interval of <code class="literal">50</code>:</p>
<a id="histogram-aggregation-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "prices": {
      "histogram": {
        "field": "price",
        "interval": 50
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1271.console"></div>
<p>And the following may be the response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "prices": {
      "buckets": [
        {
          "key": 0.0,
          "doc_count": 1
        },
        {
          "key": 50.0,
          "doc_count": 1
        },
        {
          "key": 100.0,
          "doc_count": 0
        },
        {
          "key": 150.0,
          "doc_count": 2
        },
        {
          "key": 200.0,
          "doc_count": 3
        }
      ]
    }
  }
}</pre>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_minimum_document_count"></a>Minimum document count<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/histogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The response above show that no documents has a price that falls within the range of <code class="literal">[100, 150)</code>. By default the
response will fill gaps in the histogram with empty buckets. It is possible to change that and request buckets with
a higher minimum count thanks to the <code class="literal">min_doc_count</code> setting:</p>
<a id="histogram-aggregation-min-doc-count-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "prices": {
      "histogram": {
        "field": "price",
        "interval": 50,
        "min_doc_count": 1
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1272.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "prices": {
      "buckets": [
        {
          "key": 0.0,
          "doc_count": 1
        },
        {
          "key": 50.0,
          "doc_count": 1
        },
        {
          "key": 150.0,
          "doc_count": 2
        },
        {
          "key": 200.0,
          "doc_count": 3
        }
      ]
    }
  }
}</pre>
</div>
<p><a id="search-aggregations-bucket-histogram-aggregation-extended-bounds"></a>By default the <code class="literal">histogram</code> returns all the buckets within the range of the data itself, that is, the documents with
the smallest values (on which with histogram) will determine the min bucket (the bucket with the smallest key) and the
documents with the highest values will determine the max bucket (the bucket with the highest key). Often, when
requesting empty buckets, this causes a confusion, specifically, when the data is also filtered.</p>
<p>To understand why, let&#8217;s look at an example:</p>
<p>Lets say the you&#8217;re filtering your request to get all docs with values between <code class="literal">0</code> and <code class="literal">500</code>, in addition you&#8217;d like
to slice the data per price using a histogram with an interval of <code class="literal">50</code>. You also specify <code class="literal">"min_doc_count" : 0</code> as you&#8217;d
like to get all buckets even the empty ones. If it happens that all products (documents) have prices higher than <code class="literal">100</code>,
the first bucket you&#8217;ll get will be the one with <code class="literal">100</code> as its key. This is confusing, as many times, you&#8217;d also like
to get those buckets between <code class="literal">0 - 100</code>.</p>
<p>With <code class="literal">extended_bounds</code> setting, you now can "force" the histogram aggregation to start building buckets on a specific
<code class="literal">min</code> value and also keep on building buckets up to a <code class="literal">max</code> value (even if there are no documents anymore). Using
<code class="literal">extended_bounds</code> only makes sense when <code class="literal">min_doc_count</code> is 0 (the empty buckets will never be returned if <code class="literal">min_doc_count</code>
is greater than 0).</p>
<p>Note that (as the name suggest) <code class="literal">extended_bounds</code> is <span class="strong strong"><strong>not</strong></span> filtering buckets. Meaning, if the <code class="literal">extended_bounds.min</code> is higher
than the values extracted from the documents, the documents will still dictate what the first bucket will be (and the
same goes for the <code class="literal">extended_bounds.max</code> and the last bucket). For filtering buckets, one should nest the histogram aggregation
under a range <code class="literal">filter</code> aggregation with the appropriate <code class="literal">from</code>/<code class="literal">to</code> settings.</p>
<p>Example:</p>
<a id="histogram-aggregation-extended-bounds-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "query": {
    "constant_score": { "filter": { "range": { "price": { "to": "500" } } } }
  },
  "aggs": {
    "prices": {
      "histogram": {
        "field": "price",
        "interval": 50,
        "extended_bounds": {
          "min": 0,
          "max": 500
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1273.console"></div>
<p>When aggregating ranges, buckets are based on the values of the returned documents. This means the response may include
buckets outside of a query&#8217;s range. For example, if your query looks for values greater than 100, and you have a range
covering 50 to 150, and an interval of 50, that document will land in 3 buckets - 50, 100, and 150. In general, it&#8217;s
best to think of the query and aggregation steps as independent - the query selects a set of documents, and then the
aggregation buckets those documents without regard to how they were selected.
See <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-range-field-note" title="Subtleties of bucketing range fields">note on bucketing range
fields</a> for more information and an example.</p>
<p><a id="search-aggregations-bucket-histogram-aggregation-hard-bounds"></a>The <code class="literal">hard_bounds</code> is a counterpart of <code class="literal">extended_bounds</code> and can limit the range of buckets in the histogram. It is
particularly useful in the case of open <a class="xref" href="mapping-types.html#range" title="Range field types">data ranges</a> that can result in a very large number of buckets.</p>
<p>Example:</p>
<a id="histogram-aggregation-hard-bounds-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "query": {
    "constant_score": { "filter": { "range": { "price": { "to": "500" } } } }
  },
  "aggs": {
    "prices": {
      "histogram": {
        "field": "price",
        "interval": 50,
        "hard_bounds": {
          "min": 100,
          "max": 200
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1274.console"></div>
<p>In this example even though the range specified in the query is up to 500, the histogram will only have 2 buckets starting at 100 and 150.
All other buckets will be omitted even if documents that should go to this buckets are present in the results.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_order_2"></a>Order<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/histogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>By default the returned buckets are sorted by their <code class="literal">key</code> ascending, though the order behaviour can be controlled using
the <code class="literal">order</code> setting. Supports the same <code class="literal">order</code> functionality as the <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation-order" title="Order"><code class="literal">Terms Aggregation</code></a>.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_offset"></a>Offset<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/histogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>By default the bucket keys start with 0 and then continue in even spaced steps
of <code class="literal">interval</code>, e.g. if the interval is <code class="literal">10</code>, the first three buckets (assuming
there is data inside them) will be <code class="literal">[0, 10)</code>, <code class="literal">[10, 20)</code>, <code class="literal">[20, 30)</code>. The bucket
boundaries can be shifted by using the <code class="literal">offset</code> option.</p>
<p>This can be best illustrated with an example. If there are 10 documents with values ranging from 5 to 14, using interval <code class="literal">10</code> will result in
two buckets with 5 documents each. If an additional offset <code class="literal">5</code> is used, there will be only one single bucket <code class="literal">[5, 15)</code> containing all the 10
documents.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_response_format"></a>Response Format<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/histogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>By default, the buckets are returned as an ordered array. It is also possible to request the response as a hash
instead keyed by the buckets keys:</p>
<a id="histogram-aggregation-keyed-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "prices": {
      "histogram": {
        "field": "price",
        "interval": 50,
        "keyed": true
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1275.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "prices": {
      "buckets": {
        "0.0": {
          "key": 0.0,
          "doc_count": 1
        },
        "50.0": {
          "key": 50.0,
          "doc_count": 1
        },
        "100.0": {
          "key": 100.0,
          "doc_count": 0
        },
        "150.0": {
          "key": 150.0,
          "doc_count": 2
        },
        "200.0": {
          "key": 200.0,
          "doc_count": 3
        }
      }
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_missing_value_2"></a>Missing value<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/histogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">missing</code> parameter defines how documents that are missing a value should be treated.
By default they will be ignored but it is also possible to treat them as if they
had a value.</p>
<a id="histogram-aggregation-missing-value-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "quantity": {
      "histogram": {
        "field": "quantity",
        "interval": 10,
        "missing": 0 <a id="CO279-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1276.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO279-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Documents without a value in the <code class="literal">quantity</code> field will fall into the same bucket as documents that have the value <code class="literal">0</code>.</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-bucket-histogram-aggregation-histogram-fields"></a>Histogram fields<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/histogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Running a histogram aggregation over histogram fields computes the total number of counts for each interval.</p>
<p>For example, executing a histogram aggregation against the following index that stores pre-aggregated histograms
with latency metrics (in milliseconds) for different networks:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT metrics_index
{
  "mappings": {
    "properties": {
      "network": {
        "properties": {
          "name": {
            "type": "keyword"
          }
        }
      },
      "latency_histo": {
         "type": "histogram"
      }
    }
  }
}

PUT metrics_index/_doc/1?refresh
{
  "network.name" : "net-1",
  "latency_histo" : {
      "values" : [1, 3, 8, 12, 15],
      "counts" : [3, 7, 23, 12, 6]
   }
}

PUT metrics_index/_doc/2?refresh
{
  "network.name" : "net-2",
  "latency_histo" : {
      "values" : [1, 6, 8, 12, 14],
      "counts" : [8, 17, 8, 7, 6]
   }
}

POST /metrics_index/_search?size=0
{
  "aggs": {
    "latency_buckets": {
      "histogram": {
        "field": "latency_histo",
        "interval": 5
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1277.console"></div>
<p>The <code class="literal">histogram</code> aggregation will sum the counts of each interval computed based on the <code class="literal">values</code> and
return the following output:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "latency_buckets": {
      "buckets": [
        {
          "key": 0.0,
          "doc_count": 18
        },
        {
          "key": 5.0,
          "doc_count": 48
        },
        {
          "key": 10.0,
          "doc_count": 25
        },
        {
          "key": 15.0,
          "doc_count": 6
        }
      ]
    }
  }
}</pre>
</div>
<div class="important admon">
<div class="icon"></div>
<div class="admon_content">
<p>Histogram aggregation is a bucket aggregation, which partitions documents into buckets rather than calculating metrics over fields like
metrics aggregations do. Each bucket represents a collection of documents which sub-aggregations can run on.
On the other hand, a histogram field is a pre-aggregated field representing multiple values inside a single field:
buckets of numerical data and a count of items/documents for each bucket. This mismatch between the histogram aggregations expected input
(expecting raw documents) and the histogram field (that provides summary information) limits the outcome of the aggregation
to only the doc counts for each bucket.</p>
<p><span class="strong strong"><strong>Consequently, when executing a histogram aggregation over a histogram field, no sub-aggregations are allowed.</strong></span></p>
</div>
</div>
<p>Also, when running histogram aggregation over histogram field the <code class="literal">missing</code> parameter is not supported.</p>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-ipprefix-aggregation"></a>IP prefix aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/ipprefix-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A bucket aggregation that groups documents based on the network or sub-network of an IP address. An IP address consists of two groups of bits: the most significant bits which represent the network prefix, and the least significant bits which represent the host.</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="ipprefix-agg-ex"></a>Example<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/ipprefix-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>For example, consider the following index:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT network-traffic
{
    "mappings": {
        "properties": {
            "ipv4": { "type": "ip" },
            "ipv6": { "type": "ip" }
        }
    }
}

POST /network-traffic/_bulk?refresh
{"index":{"_id":0}}
{"ipv4":"192.168.1.10","ipv6":"2001:db8:a4f8:112a:6001:0:12:7f10"}
{"index":{"_id":1}}
{"ipv4":"192.168.1.12","ipv6":"2001:db8:a4f8:112a:6001:0:12:7f12"}
{"index":{"_id":2}}
{ "ipv4":"192.168.1.33","ipv6":"2001:db8:a4f8:112a:6001:0:12:7f33"}
{"index":{"_id":3}}
{"ipv4":"192.168.1.10","ipv6":"2001:db8:a4f8:112a:6001:0:12:7f10"}
{"index":{"_id":4}}
{"ipv4":"192.168.2.41","ipv6":"2001:db8:a4f8:112c:6001:0:12:7f41"}
{"index":{"_id":5}}
{"ipv4":"192.168.2.10","ipv6":"2001:db8:a4f8:112c:6001:0:12:7f10"}
{"index":{"_id":6}}
{"ipv4":"192.168.2.23","ipv6":"2001:db8:a4f8:112c:6001:0:12:7f23"}
{"index":{"_id":7}}
{"ipv4":"192.168.3.201","ipv6":"2001:db8:a4f8:114f:6001:0:12:7201"}
{"index":{"_id":8}}
{"ipv4":"192.168.3.107","ipv6":"2001:db8:a4f8:114f:6001:0:12:7307"}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1278.console"></div>
<p>The following aggregation groups documents into buckets. Each bucket identifies a different sub-network. The sub-network is calculated by applying a netmask with prefix length of <code class="literal">24</code> to each IP address in the <code class="literal">ipv4</code> field:</p>
<a id="ip-prefix-ipv4-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /network-traffic/_search
{
  "size": 0,
  "aggs": {
    "ipv4-subnets": {
      "ip_prefix": {
        "field": "ipv4",
        "prefix_length": 24
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1279.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...

  "aggregations": {
    "ipv4-subnets": {
      "buckets": [
        {
          "key": "192.168.1.0",
          "is_ipv6": false,
          "doc_count": 4,
          "prefix_length": 24,
          "netmask": "255.255.255.0"
        },
        {
          "key": "192.168.2.0",
          "is_ipv6": false,
          "doc_count": 3,
          "prefix_length": 24,
          "netmask": "255.255.255.0"
        },
        {
           "key": "192.168.3.0",
           "is_ipv6": false,
           "doc_count": 2,
           "prefix_length": 24,
           "netmask": "255.255.255.0"
        }
      ]
    }
  }
}</pre>
</div>
<p>To aggregate IPv6 addresses, set <code class="literal">is_ipv6</code> to <code class="literal">true</code>.</p>
<a id="ip-prefix-ipv6-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /network-traffic/_search
{
  "size": 0,
  "aggs": {
    "ipv6-subnets": {
      "ip_prefix": {
        "field": "ipv6",
        "prefix_length": 64,
        "is_ipv6": true
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1280.console"></div>
<p>If <code class="literal">is_ipv6</code> is <code class="literal">true</code>, the response doesn&#8217;t include a <code class="literal">netmask</code> for each bucket.</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...

  "aggregations": {
    "ipv6-subnets": {
      "buckets": [
        {
          "key": "2001:db8:a4f8:112a::",
          "is_ipv6": true,
          "doc_count": 4,
          "prefix_length": 64
        },
        {
          "key": "2001:db8:a4f8:112c::",
          "is_ipv6": true,
          "doc_count": 3,
          "prefix_length": 64
        },
        {
          "key": "2001:db8:a4f8:114f::",
          "is_ipv6": true,
          "doc_count": 2,
          "prefix_length": 64
        }
      ]
    }
  }
}</pre>
</div>
</div>

<div class="section child_attributes">
<div class="titlepage"><div><div>
<h3 class="title"><a id="ip-prefix-agg-params"></a>Parameters<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/ipprefix-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">field</code>
</span>
</dt>
<dd>
(Required, string)
The document IP address field to aggregate on. The field mapping type must be <a class="xref" href="mapping-types.html#ip" title="IP field type"><code class="literal">ip</code></a>.
</dd>
<dt>
<span class="term">
<code class="literal">prefix_length</code>
</span>
</dt>
<dd>
(Required, integer)
Length of the network prefix. For IPv4 addresses, the accepted range is <code class="literal">[0, 32]</code>. For IPv6 addresses, the accepted range is <code class="literal">[0, 128]</code>.
</dd>
<dt>
<span class="term">
<code class="literal">is_ipv6</code>
</span>
</dt>
<dd>
(Optional, boolean)
Defines whether the prefix applies to IPv6 addresses. Just specifying the <code class="literal">prefix_length</code> parameter is not enough to know if an IP prefix applies to IPv4 or IPv6 addresses. Defaults to <code class="literal">false</code>.
</dd>
<dt>
<span class="term">
<code class="literal">append_prefix_length</code>
</span>
</dt>
<dd>
(Optional, boolean)
Defines whether the prefix length is appended to IP address keys in the response. Defaults to <code class="literal">false</code>.
</dd>
<dt>
<span class="term">
<code class="literal">keyed</code>
</span>
</dt>
<dd>
(Optional, boolean)
Defines whether buckets are returned as a hash rather than an array in the response. Defaults to <code class="literal">false</code>.
</dd>
<dt>
<span class="term">
<code class="literal">min_doc_count</code>
</span>
</dt>
<dd>
(Optional, integer)
Defines the minimum number of documents for buckets to be included in the response. Defaults to <code class="literal">1</code>.
</dd>
</dl>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="ipprefix-agg-response"></a>Response body<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/ipprefix-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">key</code>
</span>
</dt>
<dd>
(string)
The IPv6 or IPv4 subnet.
</dd>
<dt>
<span class="term">
<code class="literal">prefix_length</code>
</span>
</dt>
<dd>
(integer)
The length of the prefix used to aggregate the bucket.
</dd>
<dt>
<span class="term">
<code class="literal">doc_count</code>
</span>
</dt>
<dd>
(integer)
Number of documents matching a specific IP prefix.
</dd>
<dt>
<span class="term">
<code class="literal">is_ipv6</code>
</span>
</dt>
<dd>
(boolean)
Defines whether the netmask is an IPv6 netmask.
</dd>
<dt>
<span class="term">
<code class="literal">netmask</code>
</span>
</dt>
<dd>
(string)
The IPv4 netmask. If <code class="literal">is_ipv6</code> is <code class="literal">true</code> in the request, this field is missing in the response.
</dd>
</dl>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="ipprefix-agg-keyed-response"></a>Keyed Response<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/ipprefix-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Set the <code class="literal">keyed</code> flag of <code class="literal">true</code> to associate an unique IP address key with each bucket and return sub-networks as a hash rather than an array.</p>
<p>Example:</p>
<a id="ip-prefix-keyed-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /network-traffic/_search
{
  "size": 0,
  "aggs": {
    "ipv4-subnets": {
      "ip_prefix": {
        "field": "ipv4",
        "prefix_length": 24,
        "keyed": true
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1281.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...

  "aggregations": {
    "ipv4-subnets": {
      "buckets": {
        "192.168.1.0": {
          "is_ipv6": false,
          "doc_count": 4,
          "prefix_length": 24,
          "netmask": "255.255.255.0"
        },
        "192.168.2.0": {
          "is_ipv6": false,
          "doc_count": 3,
          "prefix_length": 24,
          "netmask": "255.255.255.0"
        },
        "192.168.3.0": {
          "is_ipv6": false,
          "doc_count": 2,
          "prefix_length": 24,
          "netmask": "255.255.255.0"
        }
      }
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="ipprefix-agg-append-prefix-length"></a>Append the prefix length to the IP address key<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/ipprefix-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Set the <code class="literal">append_prefix_length</code> flag to <code class="literal">true</code> to catenate IP address keys with the prefix length of the sub-network.</p>
<p>Example:</p>
<a id="ip-prefix-append-prefix-len-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /network-traffic/_search
{
  "size": 0,
  "aggs": {
    "ipv4-subnets": {
      "ip_prefix": {
        "field": "ipv4",
        "prefix_length": 24,
        "append_prefix_length": true
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1282.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...

  "aggregations": {
    "ipv4-subnets": {
      "buckets": [
        {
          "key": "192.168.1.0/24",
          "is_ipv6": false,
          "doc_count": 4,
          "prefix_length": 24,
          "netmask": "255.255.255.0"
        },
        {
          "key": "192.168.2.0/24",
          "is_ipv6": false,
          "doc_count": 3,
          "prefix_length": 24,
          "netmask": "255.255.255.0"
        },
        {
          "key": "192.168.3.0/24",
          "is_ipv6": false,
          "doc_count": 2,
          "prefix_length": 24,
          "netmask": "255.255.255.0"
        }
      ]
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="ipprefix-agg-min-doc-count"></a>Minimum document count<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/ipprefix-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Use the <code class="literal">min_doc_count</code> parameter to only return buckets with a minimum number of documents.</p>
<a id="ip-prefix-min-doc-count-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /network-traffic/_search
{
  "size": 0,
  "aggs": {
    "ipv4-subnets": {
      "ip_prefix": {
        "field": "ipv4",
        "prefix_length": 24,
        "min_doc_count": 3
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1283.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...

  "aggregations": {
    "ipv4-subnets": {
      "buckets": [
        {
          "key": "192.168.1.0",
          "is_ipv6": false,
          "doc_count": 4,
          "prefix_length": 24,
          "netmask": "255.255.255.0"
        },
        {
          "key": "192.168.2.0",
          "is_ipv6": false,
          "doc_count": 3,
          "prefix_length": 24,
          "netmask": "255.255.255.0"
        }
      ]
    }
  }
}</pre>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-iprange-aggregation"></a>IP range aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/iprange-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>Just like the dedicated <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-daterange-aggregation" title="Date range aggregation">date</a> range aggregation, there is also a dedicated range aggregation for IP typed fields:</p>
<p>Example:</p>
<a id="ip-range-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /ip_addresses/_search
{
  "size": 10,
  "aggs": {
    "ip_ranges": {
      "ip_range": {
        "field": "ip",
        "ranges": [
          { "to": "10.0.0.5" },
          { "from": "10.0.0.5" }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1284.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...

  "aggregations": {
    "ip_ranges": {
      "buckets": [
        {
          "key": "*-10.0.0.5",
          "to": "10.0.0.5",
          "doc_count": 10
        },
        {
          "key": "10.0.0.5-*",
          "from": "10.0.0.5",
          "doc_count": 260
        }
      ]
    }
  }
}</pre>
</div>
<p>IP ranges can also be defined as CIDR masks:</p>
<a id="ip-range-cidr-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /ip_addresses/_search
{
  "size": 0,
  "aggs": {
    "ip_ranges": {
      "ip_range": {
        "field": "ip",
        "ranges": [
          { "mask": "10.0.0.0/25" },
          { "mask": "10.0.0.127/25" }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1285.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...

  "aggregations": {
    "ip_ranges": {
      "buckets": [
        {
          "key": "10.0.0.0/25",
          "from": "10.0.0.0",
          "to": "10.0.0.128",
          "doc_count": 128
        },
        {
          "key": "10.0.0.127/25",
          "from": "10.0.0.0",
          "to": "10.0.0.128",
          "doc_count": 128
        }
      ]
    }
  }
}</pre>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_keyed_response_3"></a>Keyed Response<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/iprange-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Setting the <code class="literal">keyed</code> flag to <code class="literal">true</code> will associate a unique string key with each bucket and return the ranges as a hash rather than an array:</p>
<a id="ip-range-keyed-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /ip_addresses/_search
{
  "size": 0,
  "aggs": {
    "ip_ranges": {
      "ip_range": {
        "field": "ip",
        "ranges": [
          { "to": "10.0.0.5" },
          { "from": "10.0.0.5" }
        ],
        "keyed": true
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1286.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...

  "aggregations": {
    "ip_ranges": {
      "buckets": {
        "*-10.0.0.5": {
          "to": "10.0.0.5",
          "doc_count": 10
        },
        "10.0.0.5-*": {
          "from": "10.0.0.5",
          "doc_count": 260
        }
      }
    }
  }
}</pre>
</div>
<p>It is also possible to customize the key for each range:</p>
<a id="ip-range-keyed-customized-keys-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /ip_addresses/_search
{
  "size": 0,
  "aggs": {
    "ip_ranges": {
      "ip_range": {
        "field": "ip",
        "ranges": [
          { "key": "infinity", "to": "10.0.0.5" },
          { "key": "and-beyond", "from": "10.0.0.5" }
        ],
        "keyed": true
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1287.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...

  "aggregations": {
    "ip_ranges": {
      "buckets": {
        "infinity": {
          "to": "10.0.0.5",
          "doc_count": 10
        },
        "and-beyond": {
          "from": "10.0.0.5",
          "doc_count": 260
        }
      }
    }
  }
}</pre>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-missing-aggregation"></a>Missing aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/missing-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A field data based single bucket aggregation, that creates a bucket of all documents in the current document set context that are missing a field value (effectively, missing a field or having the configured NULL value set). This aggregator will often be used in conjunction with other field data bucket aggregators (such as ranges) to return information for all the documents that could not be placed in any of the other buckets due to missing field data values.</p>
<p>Example:</p>
<a id="missing-aggregation-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "products_without_a_price": {
      "missing": { "field": "price" }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1288.console"></div>
<p>In the above example, we get the total number of products that do not have a price.</p>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "products_without_a_price": {
      "doc_count": 0
    }
  }
}</pre>
</div>
</div>

<div class="section xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-multi-terms-aggregation"></a>Multi Terms aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/multi-terms-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A multi-bucket value source based aggregation where buckets are dynamically built - one per unique set of values. The multi terms
aggregation is very similar to the <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation-order" title="Order"><code class="literal">terms aggregation</code></a>, however in most cases
it will be slower than the terms aggregation and will consume more memory. Therefore, if the same set of fields is constantly used,
it would be more efficient to index a combined key for this fields as a separate field and use the terms aggregation on this field.</p>
<p>The multi_term aggregations are the most useful when you need to sort by a number of document or a metric aggregation on a composite
key and get top N results. If sorting is not required and all values are expected to be retrieved using nested terms aggregation or
<a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-composite-aggregation" title="Composite aggregation"><code class="literal">composite aggregations</code></a> will be a faster and more memory efficient solution.</p>
<p>Example:</p>
<a id="multi-terms-aggregation-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /products/_search
{
  "aggs": {
    "genres_and_products": {
      "multi_terms": {
        "terms": [{
          "field": "genre" <a id="CO280-1"></a><i class="conum" data-value="1"></i>
        }, {
          "field": "product"
        }]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1289.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO280-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p><code class="literal">multi_terms</code> aggregation can work with the same field types as a
<a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation-order" title="Order"><code class="literal">terms aggregation</code></a> and supports most of the terms aggregation parameters.</p>
</td>
</tr>
</table>
</div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations" : {
    "genres_and_products" : {
      "doc_count_error_upper_bound" : 0,  <a id="CO281-1"></a><i class="conum" data-value="1"></i>
      "sum_other_doc_count" : 0,          <a id="CO281-2"></a><i class="conum" data-value="2"></i>
      "buckets" : [                       <a id="CO281-3"></a><i class="conum" data-value="3"></i>
        {
          "key" : [                       <a id="CO281-4"></a><i class="conum" data-value="4"></i>
            "rock",
            "Product A"
          ],
          "key_as_string" : "rock|Product A",
          "doc_count" : 2
        },
        {
          "key" : [
            "electronic",
            "Product B"
          ],
          "key_as_string" : "electronic|Product B",
          "doc_count" : 1
        },
        {
          "key" : [
            "jazz",
            "Product B"
          ],
          "key_as_string" : "jazz|Product B",
          "doc_count" : 1
        },
        {
          "key" : [
            "rock",
            "Product B"
          ],
          "key_as_string" : "rock|Product B",
          "doc_count" : 1
        }
      ]
    }
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO281-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>an upper bound of the error on the document counts for each term, see &lt;&lt;search-aggregations-bucket-multi-terms-aggregation-approximate-counts,below&gt;</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO281-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>when there are lots of unique terms, Elasticsearch only returns the top terms; this number is the sum of the document counts for all buckets that are not part of the response</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO281-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>the list of the top buckets.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO281-4"><i class="conum" data-value="4"></i></a></p>
</td>
<td align="left" valign="top">
<p>the keys are arrays of values ordered the same ways as expression in the <code class="literal">terms</code> parameter of the aggregation</p>
</td>
</tr>
</table>
</div>
<p>By default, the <code class="literal">multi_terms</code> aggregation will return the buckets for the top ten terms ordered by the <code class="literal">doc_count</code>. One can
change this default behaviour by setting the <code class="literal">size</code> parameter.</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-bucket-multi-terms-aggregation-parameters"></a>Aggregation Parameters<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/multi-terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The following parameters are supported. See <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation-order" title="Order"><code class="literal">terms aggregation</code></a> for more detailed
explanation of these parameters.</p>
<div class="informaltable">
<table border="0" cellpadding="4px">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody valign="top">
<tr>
<td valign="top">
<p>
size
</p>
</td>
<td valign="top">
<p>
Optional. Defines how many term buckets should be returned out of the overall terms list. Defaults to 10.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
shard_size
</p>
</td>
<td valign="top">
<p>
Optional. The higher the requested <code class="literal">size</code> is, the more accurate the results will be, but also, the more
expensive it will be to compute the final results. The default <code class="literal">shard_size</code> is <code class="literal">(size * 1.5 + 10)</code>.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
show_term_doc_count_error
</p>
</td>
<td valign="top">
<p>
Optional. Calculates the doc count error on per term basis. Defaults to <code class="literal">false</code>
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
order
</p>
</td>
<td valign="top">
<p>
Optional. Specifies the order of the buckets. Defaults to the number of documents per bucket. The bucket terms
value is used as a tiebreaker for buckets with the same document count.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
min_doc_count
</p>
</td>
<td valign="top">
<p>
Optional. The minimal number of documents in a bucket for it to be returned. Defaults to 1.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
shard_min_doc_count
</p>
</td>
<td valign="top">
<p>
Optional. The minimal number of documents in a bucket on each shard for it to be returned. Defaults to
<code class="literal">min_doc_count</code>.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
collect_mode
</p>
</td>
<td valign="top">
<p>
Optional. Specifies the strategy for data collection. The <code class="literal">depth_first</code> or <code class="literal">breadth_first</code> modes are
supported. Defaults to <code class="literal">breadth_first</code>.
</p>
</td>
</tr>
</tbody>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-bucket-multi-terms-aggregation-script"></a>Script<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/multi-terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Generating the terms using a script:</p>
<a id="multi-terms-aggregation-runtime-field-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /products/_search
{
  "runtime_mappings": {
    "genre.length": {
      "type": "long",
      "script": "emit(doc['genre'].value.length())"
    }
  },
  "aggs": {
    "genres_and_products": {
      "multi_terms": {
        "terms": [
          {
            "field": "genre.length"
          },
          {
            "field": "product"
          }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1290.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations" : {
    "genres_and_products" : {
      "doc_count_error_upper_bound" : 0,
      "sum_other_doc_count" : 0,
      "buckets" : [
        {
          "key" : [
            4,
            "Product A"
          ],
          "key_as_string" : "4|Product A",
          "doc_count" : 2
        },
        {
          "key" : [
            4,
            "Product B"
          ],
          "key_as_string" : "4|Product B",
          "doc_count" : 2
        },
        {
          "key" : [
            10,
            "Product B"
          ],
          "key_as_string" : "10|Product B",
          "doc_count" : 1
        }
      ]
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_missing_value_3"></a>Missing value<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/multi-terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">missing</code> parameter defines how documents that are missing a value should be treated.
By default if any of the key components are missing the entire document will be ignored
but it is also possible to treat them as if they had a value by using the <code class="literal">missing</code> parameter.</p>
<a id="multi-terms-aggregation-missing-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /products/_search
{
  "aggs": {
    "genres_and_products": {
      "multi_terms": {
        "terms": [
          {
            "field": "genre"
          },
          {
            "field": "product",
            "missing": "Product Z"
          }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1291.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
   ...
   "aggregations" : {
    "genres_and_products" : {
      "doc_count_error_upper_bound" : 0,
      "sum_other_doc_count" : 0,
      "buckets" : [
        {
          "key" : [
            "rock",
            "Product A"
          ],
          "key_as_string" : "rock|Product A",
          "doc_count" : 2
        },
        {
          "key" : [
            "electronic",
            "Product B"
          ],
          "key_as_string" : "electronic|Product B",
          "doc_count" : 1
        },
        {
          "key" : [
            "electronic",
            "Product Z"
          ],
          "key_as_string" : "electronic|Product Z",  <a id="CO282-1"></a><i class="conum" data-value="1"></i>
          "doc_count" : 1
        },
        {
          "key" : [
            "jazz",
            "Product B"
          ],
          "key_as_string" : "jazz|Product B",
          "doc_count" : 1
        },
        {
          "key" : [
            "rock",
            "Product B"
          ],
          "key_as_string" : "rock|Product B",
          "doc_count" : 1
        }
      ]
    }
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO282-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Documents without a value in the <code class="literal">product</code> field will fall into the same bucket as documents that have the value <code class="literal">Product Z</code>.</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_mixing_field_types"></a>Mixing field types<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/multi-terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>When aggregating on multiple indices the type of the aggregated field may not be the same in all indices.
Some types are compatible with each other (<code class="literal">integer</code> and <code class="literal">long</code> or <code class="literal">float</code> and <code class="literal">double</code>) but when the types are a mix
of decimal and non-decimal number the terms aggregation will promote the non-decimal numbers to decimal numbers.
This can result in a loss of precision in the bucket values.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_sub_aggregation_and_sorting_examples"></a>Sub aggregation and sorting examples<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/multi-terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>As most bucket aggregations the <code class="literal">multi_term</code> supports sub aggregations and ordering the buckets by metrics sub-aggregation:</p>
<a id="multi-terms-aggregation-subaggregation-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /products/_search
{
  "aggs": {
    "genres_and_products": {
      "multi_terms": {
        "terms": [
          {
            "field": "genre"
          },
          {
            "field": "product"
          }
        ],
        "order": {
          "total_quantity": "desc"
        }
      },
      "aggs": {
        "total_quantity": {
          "sum": {
            "field": "quantity"
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1292.console"></div>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations" : {
    "genres_and_products" : {
      "doc_count_error_upper_bound" : 0,
      "sum_other_doc_count" : 0,
      "buckets" : [
        {
          "key" : [
            "jazz",
            "Product B"
          ],
          "key_as_string" : "jazz|Product B",
          "doc_count" : 1,
          "total_quantity" : {
            "value" : 10.0
          }
        },
        {
          "key" : [
            "rock",
            "Product A"
          ],
          "key_as_string" : "rock|Product A",
          "doc_count" : 2,
          "total_quantity" : {
            "value" : 9.0
          }
        },
        {
          "key" : [
            "electronic",
            "Product B"
          ],
          "key_as_string" : "electronic|Product B",
          "doc_count" : 1,
          "total_quantity" : {
            "value" : 3.0
          }
        },
        {
          "key" : [
            "rock",
            "Product B"
          ],
          "key_as_string" : "rock|Product B",
          "doc_count" : 1,
          "total_quantity" : {
            "value" : 1.0
          }
        }
      ]
    }
  }
}</pre>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-nested-aggregation"></a>Nested aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/nested-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A special single bucket aggregation that enables aggregating nested documents.</p>
<p>For example, lets say we have an index of products, and each product holds the list of resellers - each having its own
price for the product. The mapping could look like:</p>
<a id="nested-aggregation-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /products
{
  "mappings": {
    "properties": {
      "resellers": { <a id="CO283-1"></a><i class="conum" data-value="1"></i>
        "type": "nested",
        "properties": {
          "reseller": {
            "type": "keyword"
          },
          "price": {
            "type": "double"
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1293.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO283-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p><code class="literal">resellers</code> is an array that holds nested documents.</p>
</td>
</tr>
</table>
</div>
<p>The following request adds a product with two resellers:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /products/_doc/0?refresh
{
  "name": "LED TV", <a id="CO284-1"></a><i class="conum" data-value="1"></i>
  "resellers": [
    {
      "reseller": "companyA",
      "price": 350
    },
    {
      "reseller": "companyB",
      "price": 500
    }
  ]
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1294.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO284-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>We are using a dynamic mapping for the <code class="literal">name</code> attribute.</p>
</td>
</tr>
</table>
</div>
<p>The following request returns the minimum price a product can be purchased for:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /products/_search?size=0
{
  "query": {
    "match": {
      "name": "led tv"
    }
  },
  "aggs": {
    "resellers": {
      "nested": {
        "path": "resellers"
      },
      "aggs": {
        "min_price": {
          "min": {
            "field": "resellers.price"
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1295.console"></div>
<p>As you can see above, the nested aggregation requires the <code class="literal">path</code> of the nested documents within the top level documents.
Then one can define any type of aggregation over these nested documents.</p>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "resellers": {
      "doc_count": 2,
      "min_price": {
        "value": 350.0
      }
    }
  }
}</pre>
</div>
<p>You can use a <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-filter-aggregation" title="Filter aggregation"><code class="literal">filter</code></a>
sub-aggregation to return results for a specific reseller.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /products/_search?size=0
{
  "query": {
    "match": {
      "name": "led tv"
    }
  },
  "aggs": {
    "resellers": {
      "nested": {
        "path": "resellers"
      },
      "aggs": {
        "filter_reseller": {
          "filter": {
            "bool": {
              "filter": [
                {
                  "term": {
                    "resellers.reseller": "companyB"
                  }
                }
              ]
            }
          },
          "aggs": {
            "min_price": {
              "min": {
                "field": "resellers.price"
              }
            }
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1296.console"></div>
<p>The search returns:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "resellers": {
      "doc_count": 2,
      "filter_reseller": {
        "doc_count": 1,
        "min_price": {
          "value": 500.0
        }
      }
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-parent-aggregation"></a>Parent aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/parent-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A special single bucket aggregation that selects parent documents that have the specified type, as defined in a <a class="xref" href="mapping-types.html#parent-join" title="Join field type"><code class="literal">join</code> field</a>.</p>
<p>This aggregation has a single option:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<code class="literal">type</code> - The child type that should be selected.
</li>
</ul>
</div>
<p>For example, let&#8217;s say we have an index of questions and answers. The answer type has the following <code class="literal">join</code> field in the mapping:</p>
<a id="parent-aggregation-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT parent_example
{
  "mappings": {
     "properties": {
       "join": {
         "type": "join",
         "relations": {
           "question": "answer"
         }
       }
     }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1297.console"></div>
<p>The <code class="literal">question</code> document contain a tag field and the <code class="literal">answer</code> documents contain an owner field. With the <code class="literal">parent</code>
aggregation the owner buckets can be mapped to the tag buckets in a single request even though the two fields exist in
two different kinds of documents.</p>
<p>An example of a question document:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT parent_example/_doc/1
{
  "join": {
    "name": "question"
  },
  "body": "&lt;p&gt;I have Windows 2003 server and i bought a new Windows 2008 server...",
  "title": "Whats the best way to file transfer my site from server to a newer one?",
  "tags": [
    "windows-server-2003",
    "windows-server-2008",
    "file-transfer"
  ]
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1298.console"></div>
<p>Examples of <code class="literal">answer</code> documents:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT parent_example/_doc/2?routing=1
{
  "join": {
    "name": "answer",
    "parent": "1"
  },
  "owner": {
    "location": "Norfolk, United Kingdom",
    "display_name": "Sam",
    "id": 48
  },
  "body": "&lt;p&gt;Unfortunately you're pretty much limited to FTP...",
  "creation_date": "2009-05-04T13:45:37.030"
}

PUT parent_example/_doc/3?routing=1&amp;refresh
{
  "join": {
    "name": "answer",
    "parent": "1"
  },
  "owner": {
    "location": "Norfolk, United Kingdom",
    "display_name": "Troll",
    "id": 49
  },
  "body": "&lt;p&gt;Use Linux...",
  "creation_date": "2009-05-05T13:45:37.030"
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1299.console"></div>
<p>The following request can be built that connects the two together:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST parent_example/_search?size=0
{
  "aggs": {
    "top-names": {
      "terms": {
        "field": "owner.display_name.keyword",
        "size": 10
      },
      "aggs": {
        "to-questions": {
          "parent": {
            "type" : "answer" <a id="CO285-1"></a><i class="conum" data-value="1"></i>
          },
          "aggs": {
            "top-tags": {
              "terms": {
                "field": "tags.keyword",
                "size": 10
              }
            }
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1300.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO285-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">type</code> points to type / mapping with the name <code class="literal">answer</code>.</p>
</td>
</tr>
</table>
</div>
<p>The above example returns the top answer owners and per owner the top question tags.</p>
<p>Possible response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "took": 9,
  "timed_out": false,
  "_shards": {
    "total": 1,
    "successful": 1,
    "skipped": 0,
    "failed": 0
  },
  "hits": {
    "total" : {
      "value": 3,
      "relation": "eq"
    },
    "max_score": null,
    "hits": []
  },
  "aggregations": {
    "top-names": {
      "doc_count_error_upper_bound": 0,
      "sum_other_doc_count": 0,
      "buckets": [
        {
          "key": "Sam",
          "doc_count": 1, <a id="CO286-1"></a><i class="conum" data-value="1"></i>
          "to-questions": {
            "doc_count": 1, <a id="CO286-2"></a><i class="conum" data-value="2"></i>
            "top-tags": {
              "doc_count_error_upper_bound": 0,
              "sum_other_doc_count": 0,
              "buckets": [
                {
                  "key": "file-transfer",
                  "doc_count": 1
                },
                {
                  "key": "windows-server-2003",
                  "doc_count": 1
                },
                {
                  "key": "windows-server-2008",
                  "doc_count": 1
                }
              ]
            }
          }
        },
        {
          "key": "Troll",
          "doc_count": 1,
          "to-questions": {
            "doc_count": 1,
            "top-tags": {
              "doc_count_error_upper_bound": 0,
              "sum_other_doc_count": 0,
              "buckets": [
                {
                  "key": "file-transfer",
                  "doc_count": 1
                },
                {
                  "key": "windows-server-2003",
                  "doc_count": 1
                },
                {
                  "key": "windows-server-2008",
                  "doc_count": 1
                }
              ]
            }
          }
        }
      ]
    }
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO286-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The number of answer documents with the tag <code class="literal">Sam</code>, <code class="literal">Troll</code>, etc.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO286-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>The number of question documents that are related to answer documents with the tag <code class="literal">Sam</code>, <code class="literal">Troll</code>, etc.</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-random-sampler-aggregation"></a>Random sampler aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/random-sampler-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>This functionality is in technical preview and may be changed or removed in a future release. Elastic will apply best effort to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.</p>
</div>
</div>
<p>The <code class="literal">random_sampler</code> aggregation is a single bucket aggregation that randomly
includes documents in the aggregated results. Sampling provides significant
speed improvement at the cost of accuracy.</p>
<p>The sampling is accomplished by providing a random subset of the entire set of
documents in a shard. If a filter query is provided in the search request, that
filter is applied over the sampled subset. Consequently, if a filter is
restrictive, very few documents might match; therefore, the statistics might not
be as accurate.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>This aggregation is not to be confused with the
<a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-sampler-aggregation" title="Sampler aggregation">sampler aggregation</a>. The
sampler aggregation is not over all documents; rather, it samples the first <code class="literal">n</code>
documents matched by the query.</p>
</div>
</div>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET kibana_sample_data_ecommerce/_search?size=0&amp;track_total_hits=false
{
  "aggregations": {
    "sampling": {
      "random_sampler": {
        "probability": 0.1
      },
      "aggs": {
        "price_percentiles": {
          "percentiles": {
            "field": "taxful_total_price"
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1301.console"></div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="random-sampler-top-level-params"></a>Top-level parameters for random_sampler<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/random-sampler-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">probability</code>
</span>
</dt>
<dd>
(Required, float) The probability that a document will be included in the
aggregated data. Must be greater than 0, less than <code class="literal">0.5</code>, or exactly <code class="literal">1</code>. The
lower the probability, the fewer documents are matched.
</dd>
<dt>
<span class="term">
<code class="literal">seed</code>
</span>
</dt>
<dd>
(Optional, integer) The seed to generate the random sampling of documents. When
a seed is provided, the random subset of documents is the same between calls.
</dd>
</dl>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="random-sampler-inner-workings"></a>How does the sampling work?<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/random-sampler-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The aggregation is a random sample of all the documents in the index. In other
words, the sampling is over the background set of documents. If a query is
provided, a document is returned if it is matched by the query and if the
document is in the random sampling. The sampling is not done over the matched
documents.</p>
<p>Consider the set of documents <code class="literal">[1, 2, 3, 4, 5]</code>. Your query matches <code class="literal">[1, 3, 5]</code>
and the randomly sampled set is <code class="literal">[2, 4, 5]</code>. In this case, the document returned
would be <code class="literal">[5]</code>.</p>
<p>This type of sampling provides almost linear improvement in query latency in relation to the amount
by which sampling reduces the document set size:</p>
<div class="imageblock text-center">
<div class="content">
<img src="images/aggregations/random-sampler-agg-graph.png" alt="Graph of the median speedup by sampling factor">
</div>
</div>
<p>This graph is typical of the speed up for the majority of aggregations for a test data set of 63 million documents. The exact constants will depend on the data set size and the number of shards, but the form of the relationship between speed up and probability holds widely. For certain aggregations, the speed up may not
be as dramatic. These aggregations have some constant overhead unrelated to the number of documents seen. Even for
those aggregations, the speed improvements can be significant.</p>
<p>The sample set is generated by skipping documents using a geometric distribution
(<code class="literal">(1-p)^(k-1)*p</code>) with success probability being the provided <code class="literal">probability</code> (<code class="literal">p</code> in the distribution equation).
The values returned from the distribution indicate how many documents to skip in
the background. This is equivalent to selecting documents uniformly at random. It follows that the expected number of failures before a success is
<code class="literal">(1-p)/p</code>. For example, with the <code class="literal">"probability": 0.01</code>, the expected number of failures (or
average number of documents skipped) would be <code class="literal">99</code> with a variance of <code class="literal">9900</code>.
Consequently, if you had only 80 documents in your index or matched by your
filter, you would most likely receive no results.</p>
<div class="imageblock text-center">
<div class="content">
<img src="images/aggregations/relative-error-vs-doc-count.png" alt="Graph of the relative error by sampling probability and doc count">
</div>
</div>
<p>In the above image <code class="literal">p</code> is the probability provided to the aggregation, and <code class="literal">n</code> is the number of documents matched by whatever
query is provided. You can see the impact of outliers on <code class="literal">sum</code> and <code class="literal">mean</code>, but when many documents are still matched at
higher sampling rates, the relative error is still low.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>This represents the result of aggregations against a typical positively skewed APM data set which also has outliers in the upper tail. The linear dependence of the relative error on the sample size is found to hold widely, but the slope depends on the variation in the quantity being aggregated. As such, the variance in your own data may
      cause relative error rates to increase or decrease at a different rate.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="random-sampler-special-cases"></a>Random sampling special cases<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/random-sampler-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>All counts returned by the random sampler aggregation are scaled to ease visualizations and calculations. For example,
when randomly sampling a <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-datehistogram-aggregation" title="Date histogram aggregation">date histogram aggregation</a> every
<code class="literal">doc_count</code> value for every bucket is scaled by the inverse of the random_sampler <code class="literal">probability</code> value. So, if <code class="literal">doc_count</code>
for a bucket is <code class="literal">10,000</code> with <code class="literal">probability: 0.1</code>, the actual number of documents aggregated is <code class="literal">1,000</code>.</p>
<p>An exception to this is <a class="xref" href="search-aggregations-metrics.html#search-aggregations-metrics-cardinality-aggregation" title="Cardinality aggregation">cardinality aggregation</a>. Unique item
counts are not suitable for automatic scaling. When interpreting the cardinality count, compare it
to the number of sampled docs provided in the top level <code class="literal">doc_count</code> within the random_sampler aggregation. It gives
you an idea of unique values as a percentage of total values. It may not reflect, however, the exact number of unique values
for the given field.</p>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-range-aggregation"></a>Range aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/range-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A multi-bucket value source based aggregation that enables the user to define a set of ranges - each representing a bucket. During the aggregation process, the values extracted from each document will be checked against each bucket range and "bucket" the relevant/matching document.
Note that this aggregation includes the <code class="literal">from</code> value and excludes the <code class="literal">to</code> value for each range.</p>
<p>Example:</p>
<a id="range-aggregation-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET sales/_search
{
  "aggs": {
    "price_ranges": {
      "range": {
        "field": "price",
        "ranges": [
          { "to": 100.0 },
          { "from": 100.0, "to": 200.0 },
          { "from": 200.0 }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1302.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "price_ranges": {
      "buckets": [
        {
          "key": "*-100.0",
          "to": 100.0,
          "doc_count": 2
        },
        {
          "key": "100.0-200.0",
          "from": 100.0,
          "to": 200.0,
          "doc_count": 2
        },
        {
          "key": "200.0-*",
          "from": 200.0,
          "doc_count": 3
        }
      ]
    }
  }
}</pre>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_keyed_response_4"></a>Keyed Response<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/range-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Setting the <code class="literal">keyed</code> flag to <code class="literal">true</code> will associate a unique string key with each bucket and return the ranges as a hash rather than an array:</p>
<a id="range-aggregation-keyed-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET sales/_search
{
  "aggs": {
    "price_ranges": {
      "range": {
        "field": "price",
        "keyed": true,
        "ranges": [
          { "to": 100 },
          { "from": 100, "to": 200 },
          { "from": 200 }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1303.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "price_ranges": {
      "buckets": {
        "*-100.0": {
          "to": 100.0,
          "doc_count": 2
        },
        "100.0-200.0": {
          "from": 100.0,
          "to": 200.0,
          "doc_count": 2
        },
        "200.0-*": {
          "from": 200.0,
          "doc_count": 3
        }
      }
    }
  }
}</pre>
</div>
<p>It is also possible to customize the key for each range:</p>
<a id="range-aggregation-custom-keys-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET sales/_search
{
  "aggs": {
    "price_ranges": {
      "range": {
        "field": "price",
        "keyed": true,
        "ranges": [
          { "key": "cheap", "to": 100 },
          { "key": "average", "from": 100, "to": 200 },
          { "key": "expensive", "from": 200 }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1304.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "price_ranges": {
      "buckets": {
        "cheap": {
          "to": 100.0,
          "doc_count": 2
        },
        "average": {
          "from": 100.0,
          "to": 200.0,
          "doc_count": 2
        },
        "expensive": {
          "from": 200.0,
          "doc_count": 3
        }
      }
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_script"></a>Script<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/range-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>If the data in your documents doesn&#8217;t exactly match what you&#8217;d like to aggregate,
use a <a class="xref" href="runtime.html" title="Runtime fields">runtime field</a>. For example, if you need to
apply a particular currency conversion rate:</p>
<a id="range-aggregation-runtime-field-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET sales/_search
{
  "runtime_mappings": {
    "price.euros": {
      "type": "double",
      "script": {
        "source": """
          emit(doc['price'].value * params.conversion_rate)
        """,
        "params": {
          "conversion_rate": 0.835526591
        }
      }
    }
  },
  "aggs": {
    "price_ranges": {
      "range": {
        "field": "price.euros",
        "ranges": [
          { "to": 100 },
          { "from": 100, "to": 200 },
          { "from": 200 }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1305.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_sub_aggregations_2"></a>Sub Aggregations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/range-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The following example, not only "bucket" the documents to the different buckets but also computes statistics over the prices in each price range</p>
<a id="range-aggregation-sub-aggregation-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET sales/_search
{
  "aggs": {
    "price_ranges": {
      "range": {
        "field": "price",
        "ranges": [
          { "to": 100 },
          { "from": 100, "to": 200 },
          { "from": 200 }
        ]
      },
      "aggs": {
        "price_stats": {
          "stats": { "field": "price" }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1306.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "price_ranges": {
      "buckets": [
        {
          "key": "*-100.0",
          "to": 100.0,
          "doc_count": 2,
          "price_stats": {
            "count": 2,
            "min": 10.0,
            "max": 50.0,
            "avg": 30.0,
            "sum": 60.0
          }
        },
        {
          "key": "100.0-200.0",
          "from": 100.0,
          "to": 200.0,
          "doc_count": 2,
          "price_stats": {
            "count": 2,
            "min": 150.0,
            "max": 175.0,
            "avg": 162.5,
            "sum": 325.0
          }
        },
        {
          "key": "200.0-*",
          "from": 200.0,
          "doc_count": 3,
          "price_stats": {
            "count": 3,
            "min": 200.0,
            "max": 200.0,
            "avg": 200.0,
            "sum": 600.0
          }
        }
      ]
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-bucket-range-aggregation-histogram-fields"></a>Histogram fields<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/range-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Running a range aggregation over histogram fields computes the total number of counts for each configured range.</p>
<p>This is done without interpolating between the histogram field values. Consequently, it is possible to have a range
that is "in-between" two histogram values. The resulting range bucket would have a zero doc count.</p>
<p>Here is an example, executing a range aggregation against the following index that stores pre-aggregated histograms
with latency metrics (in milliseconds) for different networks:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT metrics_index
{
  "mappings": {
    "properties": {
      "network": {
        "properties": {
          "name": {
            "type": "keyword"
          }
        }
      },
      "latency_histo": {
         "type": "histogram"
      }
    }
  }
}

PUT metrics_index/_doc/1?refresh
{
  "network.name" : "net-1",
  "latency_histo" : {
      "values" : [1, 3, 8, 12, 15],
      "counts" : [3, 7, 23, 12, 6]
   }
}

PUT metrics_index/_doc/2?refresh
{
  "network.name" : "net-2",
  "latency_histo" : {
      "values" : [1, 6, 8, 12, 14],
      "counts" : [8, 17, 8, 7, 6]
   }
}

GET metrics_index/_search?size=0&amp;filter_path=aggregations
{
  "aggs": {
    "latency_ranges": {
      "range": {
        "field": "latency_histo",
        "ranges": [
          {"to": 2},
          {"from": 2, "to": 3},
          {"from": 3, "to": 10},
          {"from": 10}
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1307.console"></div>
<p>The <code class="literal">range</code> aggregation will sum the counts of each range computed based on the <code class="literal">values</code> and
return the following output:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "aggregations": {
    "latency_ranges": {
      "buckets": [
        {
          "key": "*-2.0",
          "to": 2.0,
          "doc_count": 11
        },
        {
          "key": "2.0-3.0",
          "from": 2.0,
          "to": 3.0,
          "doc_count": 0
        },
        {
          "key": "3.0-10.0",
          "from": 3.0,
          "to": 10.0,
          "doc_count": 55
        },
        {
          "key": "10.0-*",
          "from": 10.0,
          "doc_count": 31
        }
      ]
    }
  }
}</pre>
</div>
<div class="important admon">
<div class="icon"></div>
<div class="admon_content">
<p>Range aggregation is a bucket aggregation, which partitions documents into buckets rather than calculating metrics over fields like
metrics aggregations do. Each bucket represents a collection of documents which sub-aggregations can run on.
On the other hand, a histogram field is a pre-aggregated field representing multiple values inside a single field:
buckets of numerical data and a count of items/documents for each bucket. This mismatch between the range aggregations expected input
(expecting raw documents) and the histogram field (that provides summary information) limits the outcome of the aggregation
to only the doc counts for each bucket.</p>
<p><span class="strong strong"><strong>Consequently, when executing a range aggregation over a histogram field, no sub-aggregations are allowed.</strong></span></p>
</div>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-rare-terms-aggregation"></a>Rare terms aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/rare-terms-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A multi-bucket value source based aggregation which finds "rare" terms&#8201;&#8212;&#8201;terms that are at the long-tail
of the distribution and are not frequent. Conceptually, this is like a <code class="literal">terms</code> aggregation that is
sorted by <code class="literal">_count</code> ascending. As noted in the <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation-order" title="Order">terms aggregation docs</a>,
actually ordering a <code class="literal">terms</code> agg by count ascending has unbounded error. Instead, you should use the <code class="literal">rare_terms</code>
aggregation</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_syntax_2"></a>Syntax<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/rare-terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>A <code class="literal">rare_terms</code> aggregation looks like this in isolation:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "rare_terms": {
    "field": "the_field",
    "max_doc_count": 1
  }
}</pre>
</div>
<div class="table">
<p class="title"><strong>Table 50. <code class="literal">rare_terms</code> Parameters</strong></p>
<div class="table-contents">
<table border="1" cellpadding="4px" summary="rare_terms Parameters">
<colgroup>
<col class="col_1"/>
<col class="col_2"/>
<col class="col_3"/>
<col class="col_4"/>
</colgroup>
<tbody>
<tr>
<td align="left" valign="top"><p>Parameter Name</p></td>
<td align="left" valign="top"><p>Description</p></td>
<td align="left" valign="top"><p>Required</p></td>
<td align="left" valign="top"><p>Default Value</p></td>
</tr>
<tr>
<td align="left" valign="top"><p><code class="literal">field</code></p></td>
<td align="left" valign="top"><p>The field we wish to find rare terms in</p></td>
<td align="left" valign="top"><p>Required</p></td>
<td align="left" valign="top"><p></p></td>
</tr>
<tr>
<td align="left" valign="top"><p><code class="literal">max_doc_count</code></p></td>
<td align="left" valign="top"><p>The maximum number of documents a term should appear in.</p></td>
<td align="left" valign="top"><p>Optional</p></td>
<td align="left" valign="top"><p><code class="literal">1</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p><code class="literal">precision</code></p></td>
<td align="left" valign="top"><p>The precision of the internal CuckooFilters. Smaller precision leads to
better approximation, but higher memory usage. Cannot be smaller than <code class="literal">0.00001</code></p></td>
<td align="left" valign="top"><p>Optional</p></td>
<td align="left" valign="top"><p><code class="literal">0.001</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p><code class="literal">include</code></p></td>
<td align="left" valign="top"><p>Terms that should be included in the aggregation</p></td>
<td align="left" valign="top"><p>Optional</p></td>
<td align="left" valign="top"><p></p></td>
</tr>
<tr>
<td align="left" valign="top"><p><code class="literal">exclude</code></p></td>
<td align="left" valign="top"><p>Terms that should be excluded from the aggregation</p></td>
<td align="left" valign="top"><p>Optional</p></td>
<td align="left" valign="top"><p></p></td>
</tr>
<tr>
<td align="left" valign="top"><p><code class="literal">missing</code></p></td>
<td align="left" valign="top"><p>The value that should be used if a document does not have the field being aggregated</p></td>
<td align="left" valign="top"><p>Optional</p></td>
<td align="left" valign="top"><p></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<p>Example:</p>
<a id="rare-terms-aggregation-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "genres": {
      "rare_terms": {
        "field": "genre"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1308.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "genres": {
      "buckets": [
        {
          "key": "swing",
          "doc_count": 1
        }
      ]
    }
  }
}</pre>
</div>
<p>In this example, the only bucket that we see is the "swing" bucket, because it is the only term that appears in
one document. If we increase the <code class="literal">max_doc_count</code> to <code class="literal">2</code>, we&#8217;ll see some more buckets:</p>
<a id="rare-terms-aggregation-max-doc-count-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "genres": {
      "rare_terms": {
        "field": "genre",
        "max_doc_count": 2
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1309.console"></div>
<p>This now shows the "jazz" term which has a <code class="literal">doc_count</code> of 2":</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "genres": {
      "buckets": [
        {
          "key": "swing",
          "doc_count": 1
        },
        {
          "key": "jazz",
          "doc_count": 2
        }
      ]
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-bucket-rare-terms-aggregation-max-doc-count"></a>Maximum document count<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/rare-terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">max_doc_count</code> parameter is used to control the upper bound of document counts that a term can have. There
is not a size limitation on the <code class="literal">rare_terms</code> agg like <code class="literal">terms</code> agg has. This means that terms
which match the <code class="literal">max_doc_count</code> criteria will be returned. The aggregation functions in this manner to avoid
the order-by-ascending issues that afflict the <code class="literal">terms</code> aggregation.</p>
<p>This does, however, mean that a large number of results can be returned if chosen incorrectly.
To limit the danger of this setting, the maximum <code class="literal">max_doc_count</code> is 100.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-bucket-rare-terms-aggregation-max-buckets"></a>Max Bucket Limit<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/rare-terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The Rare Terms aggregation is more liable to trip the <code class="literal">search.max_buckets</code> soft limit than other aggregations due
to how it works. The <code class="literal">max_bucket</code> soft-limit is evaluated on a per-shard basis while the aggregation is collecting
results. It is possible for a term to be "rare" on a shard but become "not rare" once all the shard results are
merged together. This means that individual shards tend to collect more buckets than are truly rare, because
they only have their own local view. This list is ultimately pruned to the correct, smaller list of rare
terms on the coordinating node&#8230;&#8203; but a shard may have already tripped the <code class="literal">max_buckets</code> soft limit and aborted
the request.</p>
<p>When aggregating on fields that have potentially many "rare" terms, you may need to increase the <code class="literal">max_buckets</code> soft
limit. Alternatively, you might need to find a way to filter the results to return fewer rare values (smaller time
span, filter by category, etc), or re-evaluate your definition of "rare" (e.g. if something
appears 100,000 times, is it truly "rare"?)</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-bucket-rare-terms-aggregation-approximate-counts"></a>Document counts are approximate<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/rare-terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The naive way to determine the "rare" terms in a dataset is to place all the values in a map, incrementing counts
as each document is visited, then return the bottom <code class="literal">n</code> rows. This does not scale beyond even modestly sized data
sets. A sharded approach where only the "top n" values are retained from each shard (ala the <code class="literal">terms</code> aggregation)
fails because the long-tail nature of the problem means it is impossible to find the "top n" bottom values without
simply collecting all the values from all shards.</p>
<p>Instead, the Rare Terms aggregation uses a different approximate algorithm:</p>
<div class="olist orderedlist">
<ol class="orderedlist">
<li class="listitem">
Values are placed in a map the first time they are seen.
</li>
<li class="listitem">
Each addition occurrence of the term increments a counter in the map
</li>
<li class="listitem">
If the counter &gt; the <code class="literal">max_doc_count</code> threshold, the term is removed from the map and placed in a
<a href="https://www.cs.cmu.edu/~dga/papers/cuckoo-conext2014.pdf" class="ulink" target="_top">CuckooFilter</a>
</li>
<li class="listitem">
The CuckooFilter is consulted on each term. If the value is inside the filter, it is known to be above the
threshold already and skipped.
</li>
</ol>
</div>
<p>After execution, the map of values is the map of "rare" terms under the <code class="literal">max_doc_count</code> threshold. This map and CuckooFilter
are then merged with all other shards. If there are terms that are greater than the threshold (or appear in
a different shard&#8217;s CuckooFilter) the term is removed from the merged list. The final map of values is returned
to the user as the "rare" terms.</p>
<p>CuckooFilters have the possibility of returning false positives (they can say a value exists in their collection when
it actually does not). Since the CuckooFilter is being used to see if a term is over threshold, this means a false positive
from the CuckooFilter will mistakenly say a value is common when it is not (and thus exclude it from it final list of buckets).
Practically, this means the aggregations exhibits false-negative behavior since the filter is being used "in reverse"
of how people generally think of approximate set membership sketches.</p>
<p>CuckooFilters are described in more detail in the paper:</p>
<p><a href="https://www.cs.cmu.edu/~dga/papers/cuckoo-conext2014.pdf" class="ulink" target="_top">Fan, Bin, et al. "Cuckoo filter: Practically better than bloom."</a>
Proceedings of the 10th ACM International on Conference on emerging Networking Experiments and Technologies. ACM, 2014.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_precision"></a>Precision<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/rare-terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Although the internal CuckooFilter is approximate in nature, the false-negative rate can be controlled with a
<code class="literal">precision</code> parameter. This allows the user to trade more runtime memory for more accurate results.</p>
<p>The default precision is <code class="literal">0.001</code>, and the smallest (e.g. most accurate and largest memory overhead) is <code class="literal">0.00001</code>.
Below are some charts which demonstrate how the accuracy of the aggregation is affected by precision and number
of distinct terms.</p>
<p>The X-axis shows the number of distinct values the aggregation has seen, and the Y-axis shows the percent error.
Each line series represents one "rarity" condition (ranging from one rare item to 100,000 rare items). For example,
the orange "10" line means ten of the values were "rare" (<code class="literal">doc_count == 1</code>), out of 1-20m distinct values (where the
rest of the values had <code class="literal">doc_count &gt; 1</code>)</p>
<p>This first chart shows precision <code class="literal">0.01</code>:</p>
<p><span class="image"><img src="images/rare_terms/accuracy_01.png" alt="accuracy 01"></span></p>
<p>And precision <code class="literal">0.001</code> (the default):</p>
<p><span class="image"><img src="images/rare_terms/accuracy_001.png" alt="accuracy 001"></span></p>
<p>And finally <code class="literal">precision 0.0001</code>:</p>
<p><span class="image"><img src="images/rare_terms/accuracy_0001.png" alt="accuracy 0001"></span></p>
<p>The default precision of <code class="literal">0.001</code> maintains an accuracy of &lt; 2.5% for the tested conditions, and accuracy slowly
degrades in a controlled, linear fashion as the number of distinct values increases.</p>
<p>The default precision of <code class="literal">0.001</code> has a memory profile of <code class="literal">1.748⁻⁶ * n</code> bytes, where <code class="literal">n</code> is the number
of distinct values the aggregation has seen (it can also be roughly eyeballed, e.g. 20 million unique values is about
30mb of memory). The memory usage is linear to the number of distinct values regardless of which precision is chosen,
the precision only affects the slope of the memory profile as seen in this chart:</p>
<p><span class="image"><img src="images/rare_terms/memory.png" alt="memory"></span></p>
<p>For comparison, an equivalent terms aggregation at 20 million buckets would be roughly
<code class="literal">20m * 69b == ~1.38gb</code> (with 69 bytes being a very optimistic estimate of an empty bucket cost, far lower than what
the circuit breaker accounts for). So although the <code class="literal">rare_terms</code> agg is relatively heavy, it is still orders of
magnitude smaller than the equivalent terms aggregation</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_filtering_values"></a>Filtering Values<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/rare-terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>It is possible to filter the values for which buckets will be created. This can be done using the <code class="literal">include</code> and
<code class="literal">exclude</code> parameters which are based on regular expression strings or arrays of exact values. Additionally,
<code class="literal">include</code> clauses can filter using <code class="literal">partition</code> expressions.</p>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_filtering_values_with_regular_expressions"></a>Filtering Values with regular expressions<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/rare-terms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<a id="rare-terms-aggregation-regex-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "genres": {
      "rare_terms": {
        "field": "genre",
        "include": "swi*",
        "exclude": "electro*"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1310.console"></div>
<p>In the above example, buckets will be created for all the tags that starts with <code class="literal">swi</code>, except those starting
with <code class="literal">electro</code> (so the tag <code class="literal">swing</code> will be aggregated but not <code class="literal">electro_swing</code>). The <code class="literal">include</code> regular expression will determine what
values are "allowed" to be aggregated, while the <code class="literal">exclude</code> determines the values that should not be aggregated. When
both are defined, the <code class="literal">exclude</code> has precedence, meaning, the <code class="literal">include</code> is evaluated first and only then the <code class="literal">exclude</code>.</p>
<p>The syntax is the same as <a class="xref" href="regexp-syntax.html" title="Regular expression syntax">regexp queries</a>.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_filtering_values_with_exact_values"></a>Filtering Values with exact values<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/rare-terms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>For matching based on exact values the <code class="literal">include</code> and <code class="literal">exclude</code> parameters can simply take an array of
strings that represent the terms as they are found in the index:</p>
<a id="rare-terms-aggregation-exact-value-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "genres": {
      "rare_terms": {
        "field": "genre",
        "include": [ "swing", "rock" ],
        "exclude": [ "jazz" ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1311.console"></div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_missing_value_4"></a>Missing value<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/rare-terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">missing</code> parameter defines how documents that are missing a value should be treated.
By default they will be ignored but it is also possible to treat them as if they
had a value.</p>
<a id="rare-terms-aggregation-missing-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "genres": {
      "rare_terms": {
        "field": "genre",
        "missing": "N/A" <a id="CO287-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1312.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO287-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Documents without a value in the <code class="literal">tags</code> field will fall into the same bucket as documents that have the value <code class="literal">N/A</code>.</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_nested_rareterms_and_scoring_sub_aggregations"></a>Nested, RareTerms, and scoring sub-aggregations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/rare-terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The RareTerms aggregation has to operate in <code class="literal">breadth_first</code> mode, since it needs to prune terms as doc count thresholds
are breached. This requirement means the RareTerms aggregation is incompatible with certain combinations of aggregations
that require <code class="literal">depth_first</code>. In particular, scoring sub-aggregations that are inside a <code class="literal">nested</code> force the entire aggregation tree to run
in <code class="literal">depth_first</code> mode. This will throw an exception since RareTerms is unable to process <code class="literal">depth_first</code>.</p>
<p>As a concrete example, if <code class="literal">rare_terms</code> aggregation is the child of a <code class="literal">nested</code> aggregation, and one of the child aggregations of <code class="literal">rare_terms</code>
needs document scores (like a <code class="literal">top_hits</code> aggregation), this will throw an exception.</p>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-reverse-nested-aggregation"></a>Reverse nested aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/reverse-nested-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A special single bucket aggregation that enables aggregating on parent docs from nested documents. Effectively this
aggregation can break out of the nested block structure and link to other nested structures or the root document,
which allows nesting other aggregations that aren&#8217;t part of the nested object in a nested aggregation.</p>
<p>The <code class="literal">reverse_nested</code> aggregation must be defined inside a <code class="literal">nested</code> aggregation.</p>
<div class="ulist itemizedlist">
<p class="title"><strong>Options:</strong></p>
<ul class="itemizedlist">
<li class="listitem">
<code class="literal">path</code> - Which defines to what nested object field should be joined back. The default is empty,
which means that it joins back to the root / main document level. The path cannot contain a reference to
a nested object field that falls outside the <code class="literal">nested</code> aggregation&#8217;s nested structure a <code class="literal">reverse_nested</code> is in.
</li>
</ul>
</div>
<p>For example, lets say we have an index for a ticket system with issues and comments. The comments are inlined into
the issue documents as nested documents. The mapping could look like:</p>
<a id="reversed-nested-aggregation-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /issues
{
  "mappings": {
    "properties": {
      "tags": { "type": "keyword" },
      "comments": {                            <a id="CO288-1"></a><i class="conum" data-value="1"></i>
        "type": "nested",
        "properties": {
          "username": { "type": "keyword" },
          "comment": { "type": "text" }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1313.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO288-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">comments</code> is an array that holds nested documents under the <code class="literal">issue</code> object.</p>
</td>
</tr>
</table>
</div>
<p>The following aggregations will return the top commenters' username that have commented and per top commenter the top
tags of the issues the user has commented on:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /issues/_search
{
  "query": {
    "match_all": {}
  },
  "aggs": {
    "comments": {
      "nested": {
        "path": "comments"
      },
      "aggs": {
        "top_usernames": {
          "terms": {
            "field": "comments.username"
          },
          "aggs": {
            "comment_to_issue": {
              "reverse_nested": {}, <a id="CO289-1"></a><i class="conum" data-value="1"></i>
              "aggs": {
                "top_tags_per_comment": {
                  "terms": {
                    "field": "tags"
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1314.console"></div>
<p>As you can see above, the <code class="literal">reverse_nested</code> aggregation is put in to a <code class="literal">nested</code> aggregation as this is the only place
in the dsl where the <code class="literal">reverse_nested</code> aggregation can be used. Its sole purpose is to join back to a parent doc higher
up in the nested structure.</p>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO289-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>A <code class="literal">reverse_nested</code> aggregation that joins back to the root / main document level, because no <code class="literal">path</code> has been defined.
Via the <code class="literal">path</code> option the <code class="literal">reverse_nested</code> aggregation can join back to a different level, if multiple layered nested
object types have been defined in the mapping</p>
</td>
</tr>
</table>
</div>
<p>Possible response snippet:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "aggregations": {
    "comments": {
      "doc_count": 1,
      "top_usernames": {
        "doc_count_error_upper_bound" : 0,
        "sum_other_doc_count" : 0,
        "buckets": [
          {
            "key": "username_1",
            "doc_count": 1,
            "comment_to_issue": {
              "doc_count": 1,
              "top_tags_per_comment": {
                "doc_count_error_upper_bound" : 0,
                "sum_other_doc_count" : 0,
                "buckets": [
                  {
                    "key": "tag_1",
                    "doc_count": 1
                  }
                  ...
                ]
              }
            }
          }
          ...
        ]
      }
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-sampler-aggregation"></a>Sampler aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/sampler-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A filtering aggregation used to limit any sub aggregations' processing to a sample of the top-scoring documents.</p>
<div class="ulist itemizedlist">
<p class="title"><strong>Example use cases:</strong></p>
<ul class="itemizedlist">
<li class="listitem">
Tightening the focus of analytics to high-relevance matches rather than the potentially very long tail of low-quality matches
</li>
<li class="listitem">
Reducing the running cost of aggregations that can produce useful results using only samples e.g. <code class="literal">significant_terms</code>
</li>
</ul>
</div>
<p>Example:</p>
<p>A query on StackOverflow data for the popular term <code class="literal">javascript</code> OR the rarer term
<code class="literal">kibana</code> will match many documents - most of them missing the word Kibana. To focus
the <code class="literal">significant_terms</code> aggregation on top-scoring documents that are more likely to match
the most interesting parts of our query we use a sample.</p>
<a id="sampler-aggregation-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /stackoverflow/_search?size=0
{
  "query": {
    "query_string": {
      "query": "tags:kibana OR tags:javascript"
    }
  },
  "aggs": {
    "sample": {
      "sampler": {
        "shard_size": 200
      },
      "aggs": {
        "keywords": {
          "significant_terms": {
            "field": "tags",
            "exclude": [ "kibana", "javascript" ]
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1315.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "sample": {
      "doc_count": 200, <a id="CO290-1"></a><i class="conum" data-value="1"></i>
      "keywords": {
        "doc_count": 200,
        "bg_count": 650,
        "buckets": [
          {
            "key": "elasticsearch",
            "doc_count": 150,
            "score": 1.078125,
            "bg_count": 200
          },
          {
            "key": "logstash",
            "doc_count": 50,
            "score": 0.5625,
            "bg_count": 50
          }
        ]
      }
    }
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO290-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>200 documents were sampled in total. The cost of performing the nested significant_terms aggregation was
therefore limited rather than unbounded.</p>
</td>
</tr>
</table>
</div>
<p>Without the <code class="literal">sampler</code> aggregation the request query considers the full "long tail" of low-quality matches and therefore identifies
less significant terms such as <code class="literal">jquery</code> and <code class="literal">angular</code> rather than focusing on the more insightful Kibana-related terms.</p>
<a id="sampler-aggregation-no-sampler-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /stackoverflow/_search?size=0
{
  "query": {
    "query_string": {
      "query": "tags:kibana OR tags:javascript"
    }
  },
  "aggs": {
    "low_quality_keywords": {
      "significant_terms": {
        "field": "tags",
        "size": 3,
        "exclude": [ "kibana", "javascript" ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1316.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "low_quality_keywords": {
      "doc_count": 600,
      "bg_count": 650,
      "buckets": [
        {
          "key": "angular",
          "doc_count": 200,
          "score": 0.02777,
          "bg_count": 200
        },
        {
          "key": "jquery",
          "doc_count": 200,
          "score": 0.02777,
          "bg_count": 200
        },
        {
          "key": "logstash",
          "doc_count": 50,
          "score": 0.0069,
          "bg_count": 50
        }
      ]
    }
  }
}</pre>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_shard_size_2"></a>shard_size<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/sampler-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">shard_size</code> parameter limits how many top-scoring documents are collected in the sample processed on each shard.
The default value is 100.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_limitations_5"></a>Limitations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/sampler-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="sampler-breadth-first-nested-agg"></a>Cannot be nested under <code class="literal">breadth_first</code> aggregations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/sampler-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>Being a quality-based filter the sampler aggregation needs access to the relevance score produced for each document.
It therefore cannot be nested under a <code class="literal">terms</code> aggregation which has the <code class="literal">collect_mode</code> switched from the default <code class="literal">depth_first</code> mode to <code class="literal">breadth_first</code> as this discards scores.
In this situation an error will be thrown.</p>
</div>

</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-significantterms-aggregation"></a>Significant terms aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>An aggregation that returns interesting or unusual occurrences of terms in a set.</p>
<div class="ulist itemizedlist">
<p class="title"><strong>Example use cases:</strong></p>
<ul class="itemizedlist">
<li class="listitem">
Suggesting "H5N1" when users search for "bird flu" in text
</li>
<li class="listitem">
Identifying the merchant that is the "common point of compromise" from the transaction history of credit card owners reporting loss
</li>
<li class="listitem">
Suggesting keywords relating to stock symbol $ATI for an automated news classifier
</li>
<li class="listitem">
Spotting the fraudulent doctor who is diagnosing more than their fair share of whiplash injuries
</li>
<li class="listitem">
Spotting the tire manufacturer who has a disproportionate number of blow-outs
</li>
</ul>
</div>
<p>In all these cases the terms being selected are not simply the most popular terms in a set.
They are the terms that have undergone a significant change in popularity measured between a <em>foreground</em> and <em>background</em> set.
If the term "H5N1" only exists in 5 documents in a 10 million document index and yet is found in 4 of the 100 documents that make up a user&#8217;s search results
that is significant and probably very relevant to their search. 5/10,000,000 vs 4/100 is a big swing in frequency.</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_single_set_analysis"></a>Single-set analysis<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>In the simplest case, the <em>foreground</em> set of interest is the search results matched by a query and the <em>background</em>
set used for statistical comparisons is the index or indices from which the results were gathered.</p>
<p>Example:</p>
<a id="significantterms-aggregation-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "query": {
    "terms": { "force": [ "British Transport Police" ] }
  },
  "aggregations": {
    "significant_crime_types": {
      "significant_terms": { "field": "crime_type" }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1317.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "significant_crime_types": {
      "doc_count": 47347,
      "bg_count": 5064554,
      "buckets": [
        {
          "key": "Bicycle theft",
          "doc_count": 3640,
          "score": 0.371235374214817,
          "bg_count": 66799
        }
              ...
      ]
    }
  }
}</pre>
</div>
<p>When querying an index of all crimes from all police forces, what these results show is that the British Transport Police force
stand out as a force dealing with a disproportionately large number of bicycle thefts. Ordinarily, bicycle thefts represent only 1% of crimes (66799/5064554)
but for the British Transport Police, who handle crime on railways and stations, 7% of crimes (3640/47347) is
a bike theft. This is a significant seven-fold increase in frequency and so this anomaly was highlighted as the top crime type.</p>
<p>The problem with using a query to spot anomalies is it only gives us one subset to use for comparisons.
To discover all the other police forces' anomalies we would have to repeat the query for each of the different forces.</p>
<p>This can be a tedious way to look for unusual patterns in an index.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_multi_set_analysis"></a>Multi-set analysis<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>A simpler way to perform analysis across multiple categories is to use a parent-level aggregation to segment the data ready for analysis.</p>
<p>Example using a parent aggregation for segmentation:</p>
<a id="significantterms-aggregation-multiset--example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggregations": {
    "forces": {
      "terms": { "field": "force" },
      "aggregations": {
        "significant_crime_types": {
          "significant_terms": { "field": "crime_type" }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1318.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
 ...
 "aggregations": {
    "forces": {
        "doc_count_error_upper_bound": 1375,
        "sum_other_doc_count": 7879845,
        "buckets": [
            {
                "key": "Metropolitan Police Service",
                "doc_count": 894038,
                "significant_crime_types": {
                    "doc_count": 894038,
                    "bg_count": 5064554,
                    "buckets": [
                        {
                            "key": "Robbery",
                            "doc_count": 27617,
                            "score": 0.0599,
                            "bg_count": 53182
                        }
                        ...
                    ]
                }
            },
            {
                "key": "British Transport Police",
                "doc_count": 47347,
                "significant_crime_types": {
                    "doc_count": 47347,
                    "bg_count": 5064554,
                    "buckets": [
                        {
                            "key": "Bicycle theft",
                            "doc_count": 3640,
                            "score": 0.371,
                            "bg_count": 66799
                        }
                        ...
                    ]
                }
            }
        ]
    }
  }
}</pre>
</div>
<p>Now we have anomaly detection for each of the police forces using a single request.</p>
<p>We can use other forms of top-level aggregations to segment our data, for example segmenting by geographic
area to identify unusual hot-spots of a particular crime type:</p>
<a id="significantterms-aggregation-hotspot-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "hotspots": {
      "geohash_grid": {
        "field": "location",
        "precision": 5
      },
      "aggs": {
        "significant_crime_types": {
          "significant_terms": { "field": "crime_type" }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1319.console"></div>
<p>This example uses the <code class="literal">geohash_grid</code> aggregation to create result buckets that represent geographic areas, and inside each
bucket we can identify anomalous levels of a crime type in these tightly-focused areas e.g.</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Airports exhibit unusual numbers of weapon confiscations
</li>
<li class="listitem">
Universities show uplifts of bicycle thefts
</li>
</ul>
</div>
<p>At a higher geohash_grid zoom-level with larger coverage areas we would start to see where an entire police-force may be
tackling an unusual volume of a particular crime type.</p>
<p>Obviously a time-based top-level segmentation would help identify current trends for each point in time
where a simple <code class="literal">terms</code> aggregation would typically show the very popular "constants" that persist across all time slots.</p>
<div class="sidebar">
<div class="titlepage"><div><div>
<p class="title"><strong>How are the scores calculated?</strong></p>
</div></div></div>
<p>The numbers returned for scores are primarily intended for ranking different suggestions sensibly rather than something easily understood by end users. The scores are derived from the doc frequencies in <em>foreground</em> and <em>background</em> sets. In brief, a term is considered significant if there is a noticeable difference in the frequency in which a term appears in the subset and in the background. The way the terms are ranked can be configured, see "Parameters" section.</p>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_use_on_free_text_fields"></a>Use on free-text fields<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The significant_terms aggregation can be used effectively on tokenized free-text fields to suggest:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
keywords for refining end-user searches
</li>
<li class="listitem">
keywords for use in percolator queries
</li>
</ul>
</div>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>Picking a free-text field as the subject of a significant terms analysis can be expensive! It will attempt
to load every unique word into RAM. It is recommended to only use this on smaller indices.</p>
</div>
</div>
<div class="sidebar">
<div class="titlepage"><div><div>
<p class="title"><strong>Use the <em>"like this but not this"</em> pattern</strong></p>
</div></div></div>
<p>You can spot mis-categorized content by first searching a structured field e.g. <code class="literal">category:adultMovie</code> and use significant_terms on the
free-text "movie_description" field. Take the suggested words (I&#8217;ll leave them to your imagination) and then search for all movies NOT marked as category:adultMovie but containing these keywords.
You now have a ranked list of badly-categorized movies that you should reclassify or at least remove from the "familyFriendly" category.</p>
<p>The significance score from each term can also provide a useful <code class="literal">boost</code> setting to sort matches.
Using the <code class="literal">minimum_should_match</code> setting of the <code class="literal">terms</code> query with the keywords will help control the balance of precision/recall in the result set i.e
a high setting would have a small number of relevant results packed full of keywords and a setting of "1" would produce a more exhaustive results set with all documents containing <em>any</em> keyword.</p>
</div>
<div class="tip admon">
<div class="icon"></div>
<div class="admon_content">
<p><strong>Show significant_terms in context</strong>Free-text significant_terms are much more easily understood when viewed in context. Take the results of <code class="literal">significant_terms</code> suggestions from a
free-text field and use them in a <code class="literal">terms</code> query on the same field with a <code class="literal">highlight</code> clause to present users with example snippets of documents. When the terms
are presented unstemmed, highlighted, with the right case, in the right order and with some context, their significance/meaning is more readily apparent.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_custom_background_sets"></a>Custom background sets<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Ordinarily, the foreground set of documents is "diffed" against a background set of all the documents in your index.
However, sometimes it may prove useful to use a narrower background set as the basis for comparisons.
For example, a query on documents relating to "Madrid" in an index with content from all over the world might reveal that "Spanish"
was a significant term. This may be true but if you want some more focused terms you could use a <code class="literal">background_filter</code>
on the term <em>spain</em> to establish a narrower set of documents as context. With this as a background "Spanish" would now
be seen as commonplace and therefore not as significant as words like "capital" that relate more strongly with Madrid.
Note that using a background filter will slow things down - each term&#8217;s background frequency must now be derived on-the-fly from filtering posting lists rather than reading the index&#8217;s pre-computed count for a term.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_limitations_6"></a>Limitations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_significant_terms_must_be_indexed_values"></a>Significant terms must be indexed values<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>Unlike the terms aggregation it is currently not possible to use script-generated terms for counting purposes.
Because of the way the significant_terms aggregation must consider both <em>foreground</em> and <em>background</em> frequencies
it would be prohibitively expensive to use a script on the entire index to obtain background frequencies for comparisons.
Also DocValues are not supported as sources of term data for similar reasons.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_no_analysis_of_floating_point_fields"></a>No analysis of floating point fields<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>Floating point fields are currently not supported as the subject of significant_terms analysis.
While integer or long fields can be used to represent concepts like bank account numbers or category numbers which
can be interesting to track, floating point fields are usually used to represent quantities of something.
As such, individual floating point terms are not useful for this form of frequency analysis.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_use_as_a_parent_aggregation"></a>Use as a parent aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>If there is the equivalent of a <code class="literal">match_all</code> query or no query criteria providing a subset of the index the significant_terms aggregation should not be used as the
top-most aggregation - in this scenario the <em>foreground</em> set is exactly the same as the <em>background</em> set and
so there is no difference in document frequencies to observe and from which to make sensible suggestions.</p>
<p>Another consideration is that the significant_terms aggregation produces many candidate results at shard level
that are only later pruned on the reducing node once all statistics from all shards are merged. As a result,
it can be inefficient and costly in terms of RAM to embed large child aggregations under a significant_terms
aggregation that later discards many candidate terms. It is advisable in these cases to perform two searches - the first to provide a rationalized list of
significant_terms and then add this shortlist of terms to a second query to go back and fetch the required child aggregations.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_approximate_counts"></a>Approximate counts<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>The counts of how many documents contain a term provided in results are based on summing the samples returned from each shard and
as such may be:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
low if certain shards did not provide figures for a given term in their top sample
</li>
<li class="listitem">
high when considering the background frequency as it may count occurrences found in deleted documents
</li>
</ul>
</div>
<p>Like most design decisions, this is the basis of a trade-off in which we have chosen to provide fast performance at the cost of some (typically small) inaccuracies.
However, the <code class="literal">size</code> and <code class="literal">shard size</code> settings covered in the next section provide tools to help control the accuracy levels.</p>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="significantterms-aggregation-parameters"></a>Parameters<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_jlh_score"></a>JLH score<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>The JLH score can be used as a significance score by adding the parameter</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">	 "jlh": {
	 }</pre>
</div>
<p>The scores are derived from the doc frequencies in <em>foreground</em> and <em>background</em> sets. The <em>absolute</em> change in popularity (foregroundPercent - backgroundPercent) would favor common terms whereas the <em>relative</em> change in popularity (foregroundPercent/ backgroundPercent) would favor rare terms. Rare vs common is essentially a precision vs recall balance and so the absolute and relative changes are multiplied to provide a sweet spot between precision and recall.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_mutual_information"></a>Mutual information<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>Mutual information as described in "Information Retrieval", Manning et al., Chapter 13.5.1 can be used as significance score by adding the parameter</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">	 "mutual_information": {
	      "include_negatives": true
	 }</pre>
</div>
<p>Mutual information does not differentiate between terms that are descriptive for the subset or for documents outside the subset. The significant terms therefore can contain terms that appear more or less frequent in the subset than outside the subset. To filter out the terms that appear less often in the subset than in documents outside the subset, <code class="literal">include_negatives</code> can be set to <code class="literal">false</code>.</p>
<p>Per default, the assumption is that the documents in the bucket are also contained in the background. If instead you defined a custom background filter that represents a different set of documents that you want to compare to, set</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">"background_is_superset": false</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_chi_square"></a>Chi square<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>Chi square as described in "Information Retrieval", Manning et al., Chapter 13.5.2 can be used as significance score by adding the parameter</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">	 "chi_square": {
	 }</pre>
</div>
<p>Chi square behaves like mutual information and can be configured with the same parameters <code class="literal">include_negatives</code> and <code class="literal">background_is_superset</code>.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_google_normalized_distance"></a>Google normalized distance<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>Google normalized distance as described in <a href="https://arxiv.org/pdf/cs/0412098v3.pdf" class="ulink" target="_top">"The Google Similarity Distance", Cilibrasi and Vitanyi, 2007</a> can be used as significance score by adding the parameter</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">	 "gnd": {
	 }</pre>
</div>
<p><code class="literal">gnd</code> also accepts the <code class="literal">background_is_superset</code> parameter.</p>
</div>

<div class="section xpack">
<div class="titlepage"><div><div>
<h4 class="title"><a id="p-value-score"></a>p-value score<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>The p-value is the probability of obtaining test results at least as extreme as
the results actually observed, under the assumption that the null hypothesis is
correct. The p-value is calculated assuming that the foreground set and the
background set are independent
<a href="https://en.wikipedia.org/wiki/Bernoulli_trial" class="ulink" target="_top">Bernoulli trials</a>, with the null
hypothesis that the probabilities are the same.</p>
<div class="section">
<div class="titlepage"><div><div>
<h5 class="title"><a id="_example_usage"></a>Example usage<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h5>
</div></div></div>
<p>This example calculates the p-value score for terms <code class="literal">user_agent.version</code> given
the foreground set of "ended in failure" versus "NOT ended in failure".</p>
<p><code class="literal">"background_is_superset": false</code> indicates that the background set does
not contain the counts of the foreground set as they are filtered out.</p>
<p><code class="literal">"normalize_above": 1000</code> facilitates returning consistent significance results
at various scales. <code class="literal">1000</code> indicates that term counts greater than <code class="literal">1000</code> are
scaled down by a factor of <code class="literal">1000/term_count</code>.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "query": {
    "bool": {
      "filter": [
        {
          "term": {
            "event.outcome": "failure"
          }
        },
        {
          "range": {
            "@timestamp": {
              "gte": "2021-02-01",
              "lt": "2021-02-04"
            }
          }
        },
        {
          "term": {
            "service.name": {
              "value": "frontend-node"
            }
          }
        }
      ]
    }
  },
  "aggs": {
    "failure_p_value": {
      "significant_terms": {
        "field": "user_agent.version",
        "background_filter": {
          "bool": {
            "must_not": [
              {
                "term": {
                  "event.outcome": "failure"
                }
              }
            ],
            "filter": [
              {
                "range": {
                  "@timestamp": {
                    "gte": "2021-02-01",
                    "lt": "2021-02-04"
                  }
                }
              },
              {
                "term": {
                  "service.name": {
                    "value": "frontend-node"
                  }
                }
              }
            ]
          }
        },
        "p_value": {"background_is_superset": false, "normalize_above": 1000}
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1320.console"></div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_percentage"></a>Percentage<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>A simple calculation of the number of documents in the foreground sample with a term divided by the number of documents in the background with the term.
By default this produces a score greater than zero and less than one.</p>
<p>The benefit of this heuristic is that the scoring logic is simple to explain to anyone familiar with a "per capita" statistic. However, for fields with high cardinality there is a tendency for this heuristic to select the rarest terms such as typos that occur only once because they score 1/1 = 100%.</p>
<p>It would be hard for a seasoned boxer to win a championship if the prize was awarded purely on the basis of percentage of fights won - by these rules a newcomer with only one fight under their belt would be impossible to beat.
Multiple observations are typically required to reinforce a view so it is recommended in these cases to set both <code class="literal">min_doc_count</code> and <code class="literal">shard_min_doc_count</code> to a higher value such as 10 in order to filter out the low-frequency terms that otherwise take precedence.</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">	 "percentage": {
	 }</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_which_one_is_best"></a>Which one is best?<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>Roughly, <code class="literal">mutual_information</code> prefers high frequent terms even if they occur also frequently in the background. For example, in an analysis of natural language text this might lead to selection of stop words. <code class="literal">mutual_information</code> is unlikely to select very rare terms like misspellings. <code class="literal">gnd</code> prefers terms with a high co-occurrence and avoids selection of stopwords. It might be better suited for synonym detection. However, <code class="literal">gnd</code> has a tendency to select very rare terms that are, for example, a result of misspelling. <code class="literal">chi_square</code> and <code class="literal">jlh</code> are somewhat in-between.</p>
<p>It is hard to say which one of the different heuristics will be the best choice as it depends on what the significant terms are used for (see for example <a href="http://courses.ischool.berkeley.edu/i256/f06/papers/yang97comparative.pdf" class="ulink" target="_top">Yang and Pedersen, "A Comparative Study on Feature Selection in Text Categorization", 1997</a> for a study on using significant terms for feature selection for text classification).</p>
<p>If none of the above measures suits your usecase than another option is to implement a custom significance measure:</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_scripted"></a>Scripted<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>Customized scores can be implemented via a script:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">	    "script_heuristic": {
              "script": {
	        "lang": "painless",
	        "source": "params._subset_freq/(params._superset_freq - params._subset_freq + 1)"
	      }
            }</pre>
</div>
<p>Scripts can be inline (as in above example), indexed or stored on disk. For details on the options, see <a class="xref" href="modules-scripting.html" title="Scripting">script documentation</a>.</p>
<p>Available parameters in the script are</p>
<div class="informaltable">
<table border="0" cellpadding="4px">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody valign="top">
<tr>
<td valign="top">
<p>
<code class="literal">_subset_freq</code>
</p>
</td>
<td valign="top">
<p>
Number of documents the term appears in the subset.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">_superset_freq</code>
</p>
</td>
<td valign="top">
<p>
Number of documents the term appears in the superset.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">_subset_size</code>
</p>
</td>
<td valign="top">
<p>
Number of documents in the subset.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">_superset_size</code>
</p>
</td>
<td valign="top">
<p>
Number of documents in the superset.
</p>
</td>
</tr>
</tbody>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="sig-terms-shard-size"></a>Size &amp; Shard Size<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>The <code class="literal">size</code> parameter can be set to define how many term buckets should be returned out of the overall terms list. By
default, the node coordinating the search process will request each shard to provide its own top term buckets
and once all shards respond, it will reduce the results to the final list that will then be returned to the client.
If the number of unique terms is greater than <code class="literal">size</code>, the returned list can be slightly off and not accurate
(it could be that the term counts are slightly off and it could even be that a term that should have been in the top
size buckets was not returned).</p>
<p>To ensure better accuracy a multiple of the final <code class="literal">size</code> is used as the number of terms to request from each shard
(<code class="literal">2 * (size * 1.5 + 10)</code>). To take manual control of this setting the <code class="literal">shard_size</code> parameter
can be used to control the volumes of candidate terms produced by each shard.</p>
<p>Low-frequency terms can turn out to be the most interesting ones once all results are combined so the
significant_terms aggregation can produce higher-quality results when the <code class="literal">shard_size</code> parameter is set to
values significantly higher than the <code class="literal">size</code> setting. This ensures that a bigger volume of promising candidate terms are given
a consolidated review by the reducing node before the final selection. Obviously large candidate term lists
will cause extra network traffic and RAM usage so this is quality/cost trade off that needs to be balanced. If <code class="literal">shard_size</code> is set to -1 (the default) then <code class="literal">shard_size</code> will be automatically estimated based on the number of shards and the <code class="literal">size</code> parameter.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p><code class="literal">shard_size</code> cannot be smaller than <code class="literal">size</code> (as it doesn&#8217;t make much sense). When it is, Elasticsearch will
        override it and reset it to be equal to <code class="literal">size</code>.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_minimum_document_count_2"></a>Minimum document count<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>It is possible to only return terms that match more than a configured number of hits using the <code class="literal">min_doc_count</code> option:</p>
<a id="significantterms-aggregation-min-document-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "tags": {
      "significant_terms": {
        "field": "tag",
        "min_doc_count": 10
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1321.console"></div>
<p>The above aggregation would only return tags which have been found in 10 hits or more. Default value is <code class="literal">3</code>.</p>
<p>Terms that score highly will be collected on a shard level and merged with the terms collected from other shards in a second step. However, the shard does not have the information about the global term frequencies available. The decision if a term is added to a candidate list depends only on the score computed on the shard using local shard frequencies, not the global frequencies of the word. The <code class="literal">min_doc_count</code> criterion is only applied after merging local terms statistics of all shards. In a way the decision to add the term as a candidate is made without being very <em>certain</em> about if the term will actually reach the required <code class="literal">min_doc_count</code>. This might cause many (globally) high frequent terms to be missing in the final result if low frequent but high scoring terms populated the candidate lists. To avoid this, the <code class="literal">shard_size</code> parameter can be increased to allow more candidate terms on the shards. However, this increases memory consumption and network traffic.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="search-aggregations-bucket-significantterms-shard-min-doc-count"></a><code class="literal">shard_min_doc_count</code><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>The parameter <code class="literal">shard_min_doc_count</code> regulates the <em>certainty</em> a shard has if the term should actually be added to the candidate list or not with respect to the <code class="literal">min_doc_count</code>. Terms will only be considered if their local shard frequency within the set is higher than the <code class="literal">shard_min_doc_count</code>. If your dictionary contains many low frequent terms and you are not interested in those (for example misspellings), then you can set the <code class="literal">shard_min_doc_count</code> parameter to filter out candidate terms on a shard level that will with a reasonable certainty not reach the required <code class="literal">min_doc_count</code> even after merging the local counts. <code class="literal">shard_min_doc_count</code> is set to <code class="literal">0</code> per default and has no effect unless you explicitly set it.</p>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>Setting <code class="literal">min_doc_count</code> to <code class="literal">1</code> is generally not advised as it tends to return terms that
         are typos or other bizarre curiosities. Finding more than one instance of a term helps
         reinforce that, while still rare, the term was not the result of a one-off accident. The
         default value of 3 is used to provide a minimum weight-of-evidence.
         Setting <code class="literal">shard_min_doc_count</code> too high will cause significant candidate terms to be filtered out on a shard level. This value should be set much lower than <code class="literal">min_doc_count/#shards</code>.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_custom_background_context"></a>Custom background context<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>The default source of statistical information for background term frequencies is the entire index and this
scope can be narrowed through the use of a <code class="literal">background_filter</code> to focus in on significant terms within a narrower
context:</p>
<a id="significantterms-aggregation-custom-background-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "query": {
    "match": {
      "city": "madrid"
    }
  },
  "aggs": {
    "tags": {
      "significant_terms": {
        "field": "tag",
        "background_filter": {
          "term": { "text": "spain" }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1322.console"></div>
<p>The above filter would help focus in on terms that were peculiar to the city of Madrid rather than revealing
terms like "Spanish" that are unusual in the full index&#8217;s worldwide context but commonplace in the subset of documents containing the
word "Spain".</p>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>Use of background filters will slow the query as each term&#8217;s postings must be filtered to determine a frequency</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_filtering_values_2"></a>Filtering Values<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>It is possible (although rarely required) to filter the values for which buckets will be created. This can be done using the <code class="literal">include</code> and
<code class="literal">exclude</code> parameters which are based on a regular expression string or arrays of exact terms. This functionality mirrors the features
described in the <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation" title="Terms aggregation">terms aggregation</a> documentation.</p>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_collect_mode"></a>Collect mode<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>To avoid memory issues, the <code class="literal">significant_terms</code> aggregation always computes child aggregations in <code class="literal">breadth_first</code> mode.
A description of the different collection modes can be found in the
<a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation-collect" title="Collect mode">terms aggregation</a> documentation.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_execution_hint_2"></a>Execution hint<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>There are different mechanisms by which terms aggregations can be executed:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
by using field values directly in order to aggregate data per-bucket (<code class="literal">map</code>)
</li>
<li class="listitem">
by using <a class="xref" href="mapping-params.html#eager-global-ordinals" title="eager_global_ordinals">global ordinals</a> of the field and allocating one bucket per global ordinal (<code class="literal">global_ordinals</code>)
</li>
</ul>
</div>
<p>Elasticsearch tries to have sensible defaults so this is something that generally doesn&#8217;t need to be configured.</p>
<p><code class="literal">global_ordinals</code> is the default option for <code class="literal">keyword</code> field, it uses global ordinals to allocates buckets dynamically
so memory usage is linear to the number of values of the documents that are part of the aggregation scope.</p>
<p><code class="literal">map</code> should only be considered when very few documents match a query. Otherwise the ordinals-based execution mode
is significantly faster. By default, <code class="literal">map</code> is only used when running an aggregation on scripts, since they don&#8217;t have
ordinals.</p>
<a id="significantterms-aggregation-execution-hint-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "tags": {
      "significant_terms": {
        "field": "tags",
        "execution_hint": "map" <a id="CO291-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1323.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO291-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>the possible values are <code class="literal">map</code>, <code class="literal">global_ordinals</code></p>
</td>
</tr>
</table>
</div>
<p>Please note that Elasticsearch will ignore this execution hint if it is not applicable.</p>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-significanttext-aggregation"></a>Significant text aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/significanttext-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>An aggregation that returns interesting or unusual occurrences of free-text terms in a set.
It is like the <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-significantterms-aggregation" title="Significant terms aggregation">significant terms</a> aggregation but differs in that:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
It is specifically designed for use on type <code class="literal">text</code> fields
</li>
<li class="listitem">
It does not require field data or doc-values
</li>
<li class="listitem">
It re-analyzes text content on-the-fly meaning it can also filter duplicate sections of
noisy text that otherwise tend to skew statistics.
</li>
</ul>
</div>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>Re-analyzing <em>large</em> result sets will require a lot of time and memory. It is recommended that the significant_text
         aggregation is used as a child of either the <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-sampler-aggregation" title="Sampler aggregation">sampler</a> or
         <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-diversified-sampler-aggregation" title="Diversified sampler aggregation">diversified sampler</a> aggregation to limit the analysis
         to a <em>small</em> selection of top-matching documents e.g. 200. This will typically improve speed, memory use and quality of
         results.</p>
</div>
</div>
<div class="ulist itemizedlist">
<p class="title"><strong>Example use cases:</strong></p>
<ul class="itemizedlist">
<li class="listitem">
Suggesting "H5N1" when users search for "bird flu" to help expand queries
</li>
<li class="listitem">
Suggesting keywords relating to stock symbol $ATI for use in an automated news classifier
</li>
</ul>
</div>
<p>In these cases the words being selected are not simply the most popular terms in results. The most popular words tend to be
very boring (<em>and, of, the, we, I, they</em> &#8230;&#8203;).
The significant words are the ones that have undergone a significant change in popularity measured between a <em>foreground</em> and <em>background</em> set.
If the term "H5N1" only exists in 5 documents in a 10 million document index and yet is found in 4 of the 100 documents that make up a user&#8217;s search results
that is significant and probably very relevant to their search. 5/10,000,000 vs 4/100 is a big swing in frequency.</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_basic_use_2"></a>Basic use<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/significanttext-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>In the typical use case, the <em>foreground</em> set of interest is a selection of the top-matching search results for a query
and the <em>background</em> set used for statistical comparisons is the index or indices from which the results were gathered.</p>
<p>Example:</p>
<a id="significanttext-aggregation-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET news/_search
{
  "query": {
    "match": { "content": "Bird flu" }
  },
  "aggregations": {
    "my_sample": {
      "sampler": {
        "shard_size": 100
      },
      "aggregations": {
        "keywords": {
          "significant_text": { "field": "content" }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1324.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "took": 9,
  "timed_out": false,
  "_shards": ...,
  "hits": ...,
    "aggregations" : {
        "my_sample": {
            "doc_count": 100,
            "keywords" : {
                "doc_count": 100,
                "buckets" : [
                    {
                        "key": "h5n1",
                        "doc_count": 4,
                        "score": 4.71235374214817,
                        "bg_count": 5
                    }
                    ...
                ]
            }
        }
    }
}</pre>
</div>
<p>The results show that "h5n1" is one of several terms strongly associated with bird flu.
It only occurs 5 times in our index as a whole (see the <code class="literal">bg_count</code>) and yet 4 of these
were lucky enough to appear in our 100 document sample of "bird flu" results. That suggests
a significant word and one which the user can potentially add to their search.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="filter-duplicate-text-noisy-data"></a>Dealing with noisy data using <code class="literal">filter_duplicate_text</code><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/significanttext-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Free-text fields often contain a mix of original content and mechanical copies of text (cut-and-paste biographies, email reply chains,
retweets, boilerplate headers/footers, page navigation menus, sidebar news links, copyright notices, standard disclaimers, addresses).</p>
<p>In real-world data these duplicate sections of text tend to feature heavily in <code class="literal">significant_text</code> results if they aren&#8217;t filtered out.
Filtering near-duplicate text is a difficult task at index-time but we can cleanse the data on-the-fly at query time using the
<code class="literal">filter_duplicate_text</code> setting.</p>
<p>First let&#8217;s look at an unfiltered real-world example using the <a href="https://research.signalmedia.co/newsir16/signal-dataset.html" class="ulink" target="_top">Signal media dataset</a> of
a million news articles covering a wide variety of news. Here are the raw significant text results for a search for the articles
mentioning "elasticsearch":</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  ...
  "aggregations": {
    "sample": {
      "doc_count": 35,
      "keywords": {
        "doc_count": 35,
        "buckets": [
          {
            "key": "elasticsearch",
            "doc_count": 35,
            "score": 28570.428571428572,
            "bg_count": 35
          },
          ...
          {
            "key": "currensee",
            "doc_count": 8,
            "score": 6530.383673469388,
            "bg_count": 8
          },
          ...
          {
            "key": "pozmantier",
            "doc_count": 4,
            "score": 3265.191836734694,
            "bg_count": 4
          },
          ...

}</pre>
</div>
<p>The uncleansed documents have thrown up some odd-looking terms that are, on the face of it, statistically
correlated with appearances of our search term "elasticsearch" e.g. "pozmantier".
We can drill down into examples of these documents to see why pozmantier is connected using this query:</p>
<a id="significanttext-aggregation-pozmantier-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET news/_search
{
  "query": {
    "simple_query_string": {
      "query": "+elasticsearch  +pozmantier"
    }
  },
  "_source": [
    "title",
    "source"
  ],
  "highlight": {
    "fields": {
      "content": {}
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1325.console"></div>
<p>The results show a series of very similar news articles about a judging panel for a number of tech projects:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  ...
  "hits": {
    "hits": [
      {
        ...
        "_source": {
          "source": "Presentation Master",
          "title": "T.E.N. Announces Nominees for the 2015 ISE® North America Awards"
        },
        "highlight": {
          "content": [
            "City of San Diego Mike &lt;em&gt;Pozmantier&lt;/em&gt;, Program Manager, Cyber Security Division, Department of",
            " Janus, Janus &lt;em&gt;ElasticSearch&lt;/em&gt; Security Visualization Engine "
          ]
        }
      },
      {
        ...
        "_source": {
          "source": "RCL Advisors",
          "title": "T.E.N. Announces Nominees for the 2015 ISE(R) North America Awards"
        },
        "highlight": {
          "content": [
            "Mike &lt;em&gt;Pozmantier&lt;/em&gt;, Program Manager, Cyber Security Division, Department of Homeland Security S&amp;T",
            "Janus, Janus &lt;em&gt;ElasticSearch&lt;/em&gt; Security Visualization Engine"
          ]
        }
      },
      ...</pre>
</div>
<p>Mike Pozmantier was one of many judges on a panel and elasticsearch was used in one of many projects being judged.</p>
<p>As is typical, this lengthy press release was cut-and-paste by a variety of news sites and consequently any rare names, numbers or
typos they contain become statistically correlated with our matching query.</p>
<p>Fortunately similar documents tend to rank similarly so as part of examining the stream of top-matching documents the significant_text
aggregation can apply a filter to remove sequences of any 6 or more tokens that have already been seen. Let&#8217;s try this same query now but
with the <code class="literal">filter_duplicate_text</code> setting turned on:</p>
<a id="significanttext-aggregation-filter-duplicate-text-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET news/_search
{
  "query": {
    "match": {
      "content": "elasticsearch"
    }
  },
  "aggs": {
    "sample": {
      "sampler": {
        "shard_size": 100
      },
      "aggs": {
        "keywords": {
          "significant_text": {
            "field": "content",
            "filter_duplicate_text": true
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1326.console"></div>
<p>The results from analysing our deduplicated text are obviously of higher quality to anyone familiar with the elastic stack:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  ...
  "aggregations": {
    "sample": {
      "doc_count": 35,
      "keywords": {
        "doc_count": 35,
        "buckets": [
          {
            "key": "elasticsearch",
            "doc_count": 22,
            "score": 11288.001166180758,
            "bg_count": 35
          },
          {
            "key": "logstash",
            "doc_count": 3,
            "score": 1836.648979591837,
            "bg_count": 4
          },
          {
            "key": "kibana",
            "doc_count": 3,
            "score": 1469.3020408163263,
            "bg_count": 5
          }
        ]
      }
    }
  }
}</pre>
</div>
<p>Mr Pozmantier and other one-off associations with elasticsearch no longer appear in the aggregation
results as a consequence of copy-and-paste operations or other forms of mechanical repetition.</p>
<p>If your duplicate or near-duplicate content is identifiable via a single-value indexed field  (perhaps
a hash of the article&#8217;s <code class="literal">title</code> text or an <code class="literal">original_press_release_url</code> field) then it would be more
efficient to use a parent <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-diversified-sampler-aggregation" title="Diversified sampler aggregation">diversified sampler</a> aggregation
to eliminate these documents from the sample set based on that single key. The less duplicate content you can feed into
the significant_text aggregation up front the better in terms of performance.</p>
<div class="sidebar">
<div class="titlepage"><div><div>
<p class="title"><strong>How are the significance scores calculated?</strong></p>
</div></div></div>
<p>The numbers returned for scores are primarily intended for ranking different suggestions sensibly rather than something easily
understood by end users. The scores are derived from the doc frequencies in <em>foreground</em> and <em>background</em> sets. In brief, a
term is considered significant if there is a noticeable difference in the frequency in which a term appears in the subset and
in the background. The way the terms are ranked can be configured, see "Parameters" section.</p>
</div>
<div class="sidebar">
<div class="titlepage"><div><div>
<p class="title"><strong>Use the <em>"like this but not this"</em> pattern</strong></p>
</div></div></div>
<p>You can spot mis-categorized content by first searching a structured field e.g. <code class="literal">category:adultMovie</code> and use significant_text on the
text "movie_description" field. Take the suggested words (I&#8217;ll leave them to your imagination) and then search for all movies NOT marked as category:adultMovie but containing these keywords.
You now have a ranked list of badly-categorized movies that you should reclassify or at least remove from the "familyFriendly" category.</p>
<p>The significance score from each term can also provide a useful <code class="literal">boost</code> setting to sort matches.
Using the <code class="literal">minimum_should_match</code> setting of the <code class="literal">terms</code> query with the keywords will help control the balance of precision/recall in the result set i.e
a high setting would have a small number of relevant results packed full of keywords and a setting of "1" would produce a more exhaustive results set with all documents containing <em>any</em> keyword.</p>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_limitations_7"></a>Limitations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/significanttext-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_no_support_for_child_aggregations"></a>No support for child aggregations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/significanttext-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>The significant_text aggregation intentionally does not support the addition of child aggregations because:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
It would come with a high memory cost
</li>
<li class="listitem">
It isn&#8217;t a generally useful feature and there is a workaround for those that need it
</li>
</ul>
</div>
<p>The volume of candidate terms is generally very high and these are pruned heavily before the final
results are returned. Supporting child aggregations would generate additional churn and be inefficient.
Clients can always take the heavily-trimmed set of results from a <code class="literal">significant_text</code> request and
make a subsequent follow-up query using a <code class="literal">terms</code> aggregation with an <code class="literal">include</code> clause and child
aggregations to perform further analysis of selected keywords in a more efficient fashion.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_no_support_for_nested_objects"></a>No support for nested objects<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/significanttext-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>The significant_text aggregation currently also cannot be used with text fields in
nested objects, because it works with the document JSON source. This makes this
feature inefficient when matching nested docs from stored JSON given a matching
Lucene docID.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_approximate_counts_2"></a>Approximate counts<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/significanttext-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>The counts of how many documents contain a term provided in results are based on summing the samples returned from each shard and
as such may be:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
low if certain shards did not provide figures for a given term in their top sample
</li>
<li class="listitem">
high when considering the background frequency as it may count occurrences found in deleted documents
</li>
</ul>
</div>
<p>Like most design decisions, this is the basis of a trade-off in which we have chosen to provide fast performance at the cost of some (typically small) inaccuracies.
However, the <code class="literal">size</code> and <code class="literal">shard size</code> settings covered in the next section provide tools to help control the accuracy levels.</p>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="significanttext-aggregation-parameters"></a>Parameters<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/significanttext-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_significance_heuristics"></a>Significance heuristics<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/significanttext-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>This aggregation supports the same scoring heuristics (JLH, mutual_information, gnd, chi_square etc) as the <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-significantterms-aggregation" title="Significant terms aggregation">significant terms</a> aggregation</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="sig-text-shard-size"></a>Size &amp; Shard Size<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/significanttext-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>The <code class="literal">size</code> parameter can be set to define how many term buckets should be returned out of the overall terms list. By
default, the node coordinating the search process will request each shard to provide its own top term buckets
and once all shards respond, it will reduce the results to the final list that will then be returned to the client.
If the number of unique terms is greater than <code class="literal">size</code>, the returned list can be slightly off and not accurate
(it could be that the term counts are slightly off and it could even be that a term that should have been in the top
size buckets was not returned).</p>
<p>To ensure better accuracy a multiple of the final <code class="literal">size</code> is used as the number of terms to request from each shard
(<code class="literal">2 * (size * 1.5 + 10)</code>). To take manual control of this setting the <code class="literal">shard_size</code> parameter
can be used to control the volumes of candidate terms produced by each shard.</p>
<p>Low-frequency terms can turn out to be the most interesting ones once all results are combined so the
significant_terms aggregation can produce higher-quality results when the <code class="literal">shard_size</code> parameter is set to
values significantly higher than the <code class="literal">size</code> setting. This ensures that a bigger volume of promising candidate terms are given
a consolidated review by the reducing node before the final selection. Obviously large candidate term lists
will cause extra network traffic and RAM usage so this is quality/cost trade off that needs to be balanced. If <code class="literal">shard_size</code> is set to -1 (the default) then <code class="literal">shard_size</code> will be automatically estimated based on the number of shards and the <code class="literal">size</code> parameter.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p><code class="literal">shard_size</code> cannot be smaller than <code class="literal">size</code> (as it doesn&#8217;t make much sense). When it is, elasticsearch will
        override it and reset it to be equal to <code class="literal">size</code>.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_minimum_document_count_3"></a>Minimum document count<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/significanttext-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>It is possible to only return terms that match more than a configured number of hits using the <code class="literal">min_doc_count</code> option.
The Default value is 3.</p>
<p>Terms that score highly will be collected on a shard level and merged with the terms collected from other shards in a second step.
However, the shard does not have the information about the global term frequencies available. The decision if a term is added to a
candidate list depends only on the score computed on the shard using local shard frequencies, not the global frequencies of the word.
The <code class="literal">min_doc_count</code> criterion is only applied after merging local terms statistics of all shards. In a way the decision to add the
term as a candidate is made without being very <em>certain</em> about if the term will actually reach the required <code class="literal">min_doc_count</code>.
This might cause many (globally) high frequent terms to be missing in the final result if low frequent but high scoring terms populated
the candidate lists. To avoid this, the <code class="literal">shard_size</code> parameter can be increased to allow more candidate terms on the shards.
However, this increases memory consumption and network traffic.</p>
<div class="section">
<div class="titlepage"><div><div>
<h5 class="title"><a id="search-aggregations-bucket-significanttext-shard-min-doc-count"></a><code class="literal">shard_min_doc_count</code><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/significanttext-aggregation.asciidoc">edit</a></h5>
</div></div></div>
<p>The parameter <code class="literal">shard_min_doc_count</code> regulates the <em>certainty</em> a shard has if the term should actually be added to the candidate list or not with respect to the <code class="literal">min_doc_count</code>. Terms will only be considered if their local shard frequency within the set is higher than the <code class="literal">shard_min_doc_count</code>. If your dictionary contains many low frequent terms and you are not interested in those (for example misspellings), then you can set the <code class="literal">shard_min_doc_count</code> parameter to filter out candidate terms on a shard level that will with a reasonable certainty not reach the required <code class="literal">min_doc_count</code> even after merging the local counts. <code class="literal">shard_min_doc_count</code> is set to <code class="literal">0</code> per default and has no effect unless you explicitly set it.</p>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>Setting <code class="literal">min_doc_count</code> to <code class="literal">1</code> is generally not advised as it tends to return terms that
         are typos or other bizarre curiosities. Finding more than one instance of a term helps
         reinforce that, while still rare, the term was not the result of a one-off accident. The
         default value of 3 is used to provide a minimum weight-of-evidence.
         Setting <code class="literal">shard_min_doc_count</code> too high will cause significant candidate terms to be filtered out on a shard level.
         This value should be set much lower than <code class="literal">min_doc_count/#shards</code>.</p>
</div>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_custom_background_context_2"></a>Custom background context<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/significanttext-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>The default source of statistical information for background term frequencies is the entire index and this
scope can be narrowed through the use of a <code class="literal">background_filter</code> to focus in on significant terms within a narrower
context:</p>
<a id="significanttext-aggregation-custom-background-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET news/_search
{
  "query": {
    "match": {
      "content": "madrid"
    }
  },
  "aggs": {
    "tags": {
      "significant_text": {
        "field": "content",
        "background_filter": {
          "term": { "content": "spain" }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1327.console"></div>
<p>The above filter would help focus in on terms that were peculiar to the city of Madrid rather than revealing
terms like "Spanish" that are unusual in the full index&#8217;s worldwide context but commonplace in the subset of documents containing the
word "Spain".</p>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>Use of background filters will slow the query as each term&#8217;s postings must be filtered to determine a frequency</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_dealing_with_source_and_index_mappings"></a>Dealing with source and index mappings<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/significanttext-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>Ordinarily the indexed field name and the original JSON field being retrieved share the same name.
However with more complex field mappings using features like <code class="literal">copy_to</code> the source
JSON field(s) and the indexed field being aggregated can differ.
In these cases it is possible to list the JSON _source fields from which text
will be analyzed using the <code class="literal">source_fields</code> parameter:</p>
<a id="significanttext-aggregation-mappings-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET news/_search
{
  "query": {
    "match": {
      "custom_all": "elasticsearch"
    }
  },
  "aggs": {
    "tags": {
      "significant_text": {
        "field": "custom_all",
        "source_fields": [ "content", "title" ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1328.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_filtering_values_3"></a>Filtering Values<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/significanttext-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>It is possible (although rarely required) to filter the values for which buckets will be created. This can be done using the <code class="literal">include</code> and
<code class="literal">exclude</code> parameters which are based on a regular expression string or arrays of exact terms. This functionality mirrors the features
described in the <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation" title="Terms aggregation">terms aggregation</a> documentation.</p>
</div>

</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-terms-aggregation"></a>Terms aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A multi-bucket value source based aggregation where buckets are dynamically built - one per unique value.</p>
<p>Example:</p>
<a id="terms-aggregation-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "genres": {
      "terms": { "field": "genre" }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1329.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "genres": {
      "doc_count_error_upper_bound": 0,   <a id="CO292-1"></a><i class="conum" data-value="1"></i>
      "sum_other_doc_count": 0,           <a id="CO292-2"></a><i class="conum" data-value="2"></i>
      "buckets": [                        <a id="CO292-3"></a><i class="conum" data-value="3"></i>
        {
          "key": "electronic",
          "doc_count": 6
        },
        {
          "key": "rock",
          "doc_count": 3
        },
        {
          "key": "jazz",
          "doc_count": 2
        }
      ]
    }
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO292-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>an upper bound of the error on the document counts for each term, see <a class="xref" href="search-aggregations-bucket.html#terms-agg-doc-count-error" title="Document count error">below</a></p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO292-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>when there are lots of unique terms, Elasticsearch only returns the top terms; this number is the sum of the document counts for all buckets that are not part of the response</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO292-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>the list of the top buckets, the meaning of <code class="literal">top</code> being defined by the <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation-order" title="Order">order</a></p>
</td>
</tr>
</table>
</div>
<p><a id="search-aggregations-bucket-terms-aggregation-types"></a>The <code class="literal">field</code> can be <a class="xref" href="mapping-types.html#keyword" title="Keyword type family">Keyword</a>, <a class="xref" href="mapping-types.html#number" title="Numeric field types">Numeric</a>, <a class="xref" href="mapping-types.html#ip" title="IP field type"><code class="literal">ip</code></a>, <a class="xref" href="mapping-types.html#boolean" title="Boolean field type"><code class="literal">boolean</code></a>,
or <a class="xref" href="mapping-types.html#binary" title="Binary field type"><code class="literal">binary</code></a>.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>By default, you cannot run a <code class="literal">terms</code> aggregation on a <code class="literal">text</code> field. Use a
<code class="literal">keyword</code> <a class="xref" href="mapping-params.html#multi-fields" title="fields">sub-field</a> instead. Alternatively, you can enable
<a class="xref" href="mapping-types.html#fielddata-mapping-param" title="fielddata mapping parameter"><code class="literal">fielddata</code></a> on the <code class="literal">text</code> field to create buckets for the field&#8217;s
<a class="xref" href="analysis.html" title="Text analysis">analyzed</a> terms. Enabling <code class="literal">fielddata</code> can significantly increase
memory usage.</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-bucket-terms-aggregation-size"></a>Size<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>By default, the <code class="literal">terms</code> aggregation returns the top ten terms with the most
documents. Use the <code class="literal">size</code> parameter to return more terms, up to the
<a class="xref" href="settings.html#search-settings-max-buckets">search.max_buckets</a> limit.</p>
<p>If your data contains 100 or 1000 unique terms, you can increase the <code class="literal">size</code> of
the <code class="literal">terms</code> aggregation to return them all. If you have more unique terms and
you need them all, use the
<a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-composite-aggregation" title="Composite aggregation">composite aggregation</a>
instead.</p>
<p>Larger values of <code class="literal">size</code> use more memory to compute and, push the whole
aggregation close to the <code class="literal">max_buckets</code> limit. You&#8217;ll know you&#8217;ve gone too large
if the request fails with a message about <code class="literal">max_buckets</code>.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-bucket-terms-aggregation-shard-size"></a>Shard size<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>To get more accurate results, the <code class="literal">terms</code> agg fetches more than
the top <code class="literal">size</code> terms from each shard. It fetches the top <code class="literal">shard_size</code> terms,
which defaults to <code class="literal">size * 1.5 + 10</code>.</p>
<p>This is to handle the case when one term has many documents on one shard but is
just below the <code class="literal">size</code> threshold on all other shards. If each shard only
returned <code class="literal">size</code> terms, the aggregation would return an partial doc count for
the term. So <code class="literal">terms</code> returns more terms in an attempt to catch the missing
terms. This helps, but it&#8217;s still quite possible to return a partial doc
count for a term. It just takes a term with more disparate per-shard doc counts.</p>
<p>You can increase <code class="literal">shard_size</code> to better account for these disparate doc counts
and improve the accuracy of the selection of top terms. It is much cheaper to increase
the <code class="literal">shard_size</code> than to increase the <code class="literal">size</code>. However, it still takes more
bytes over the wire and waiting in memory on the coordinating node.</p>
<div class="important admon">
<div class="icon"></div>
<div class="admon_content">
<p>This guidance only applies if you&#8217;re using the <code class="literal">terms</code> aggregation&#8217;s
default sort <code class="literal">order</code>. If you&#8217;re sorting by anything other than document count in
descending order, see <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation-order" title="Order">Order</a>.</p>
</div>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p><code class="literal">shard_size</code> cannot be smaller than <code class="literal">size</code> (as it doesn&#8217;t make much sense). When it is, Elasticsearch will
        override it and reset it to be equal to <code class="literal">size</code>.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="terms-agg-doc-count-error"></a>Document count error<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Even with a larger <code class="literal">shard_size</code> value, <code class="literal">doc_count</code> values for a <code class="literal">terms</code>
aggregation may be approximate. As a result, any sub-aggregations on the <code class="literal">terms</code>
aggregation may also be approximate.</p>
<p><code class="literal">sum_other_doc_count</code> is the number of documents that didn&#8217;t make it into the
the top <code class="literal">size</code> terms. If this is greater than <code class="literal">0</code>, you can be sure that the
<code class="literal">terms</code> agg had to throw away some buckets, either because they didn&#8217;t fit into
<code class="literal">size</code> on the coordinating node or they didn&#8217;t fit into <code class="literal">shard_size</code> on the
data node.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_per_bucket_document_count_error"></a>Per bucket document count error<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>If you set the <code class="literal">show_term_doc_count_error</code> parameter to <code class="literal">true</code>, the <code class="literal">terms</code>
aggregation will include <code class="literal">doc_count_error_upper_bound</code>, which is an upper bound
to the error on the <code class="literal">doc_count</code> returned by each shard. It&#8217;s the
sum of the size of the largest bucket on each shard that didn&#8217;t fit into
<code class="literal">shard_size</code>.</p>
<p>In more concrete terms, imagine there is one bucket that is very large on one
shard and just outside the <code class="literal">shard_size</code> on all the other shards. In that case,
the <code class="literal">terms</code> agg will return the bucket because it is large, but it&#8217;ll be missing
data from many documents on the shards where the term fell below the <code class="literal">shard_size</code> threshold.
<code class="literal">doc_count_error_upper_bound</code> is the maximum number of those missing documents.</p>
<a id="terms-aggregation-doc-count-error-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "products": {
      "terms": {
        "field": "product",
        "size": 5,
        "show_term_doc_count_error": true
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1330.console"></div>
<p>These errors can only be calculated in this way when the terms are ordered by descending document count. When the aggregation is
ordered by the terms values themselves (either ascending or descending) there is no error in the document count since if a shard
does not return a particular term which appears in the results from another shard, it must not have that term in its index. When the
aggregation is either sorted by a sub aggregation or in order of ascending document count, the error in the document counts cannot be
determined and is given a value of -1 to indicate this.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-bucket-terms-aggregation-order"></a>Order<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>By default, the <code class="literal">terms</code> aggregation orders terms by descending document
<code class="literal">_count</code>.  This produces a bounded <a class="xref" href="search-aggregations-bucket.html#terms-agg-doc-count-error" title="Document count error">document count</a>
error that Elasticsearch can report.</p>
<p>You can use the <code class="literal">order</code> parameter to specify a different sort order, but we
don&#8217;t recommend it.  It is extremely easy to create a terms ordering that will
just return wrong results, and not obvious to see when you have done so.
Change this only with caution.</p>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>Especially avoid using <code class="literal">"order": { "_count": "asc" }</code>. If you need to find rare
terms, use the
<a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-rare-terms-aggregation" title="Rare terms aggregation"><code class="literal">rare_terms</code></a> aggregation
instead. Due to the way the <code class="literal">terms</code> aggregation
<a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation-shard-size" title="Shard size">gets terms from
shards</a>, sorting by ascending doc count often produces inaccurate results.</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_ordering_by_the_term_value"></a>Ordering by the term value<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>In this case, the buckets are ordered by the actual term values, such as
lexicographic order for keywords or numerically for numbers. This sorting is
safe in both ascending and descending directions, and produces accurate
results.</p>
<p>Example of ordering the buckets alphabetically by their terms in an ascending manner:</p>
<a id="terms-aggregation-asc-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "genres": {
      "terms": {
        "field": "genre",
        "order": { "_key": "asc" }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1331.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_ordering_by_a_sub_aggregation"></a>Ordering by a sub aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>Sorting by a sub aggregation generally produces incorrect ordering, due to the way the <code class="literal">terms</code> aggregation
<a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation-shard-size" title="Shard size">gets results from
shards</a>.</p>
</div>
</div>
<p>There are two cases when sub-aggregation ordering is safe and returns correct
results: sorting by a maximum in descending order, or sorting by a minimum in
ascending order. These approaches work because they align with the behavior of
sub aggregations. That is, if you&#8217;re looking for the largest maximum or the
smallest minimum, the global answer (from combined shards) must be included in
one of the local shard answers. Conversely, the smallest maximum and largest
minimum wouldn&#8217;t be accurately computed.</p>
<p>Note also that in these cases, the ordering is correct but the doc counts and
non-ordering sub aggregations may still have errors (and Elasticsearch does not calculate a
bound for those errors).</p>
<p>Ordering the buckets by single value metrics sub-aggregation (identified by the aggregation name):</p>
<a id="terms-aggregation-subaggregation-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "genres": {
      "terms": {
        "field": "genre",
        "order": { "max_play_count": "desc" }
      },
      "aggs": {
        "max_play_count": { "max": { "field": "play_count" } }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1332.console"></div>
<p>Ordering the buckets by multi value metrics sub-aggregation (identified by the aggregation name):</p>
<a id="terms-aggregation-multivalue-subaggregation-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "genres": {
      "terms": {
        "field": "genre",
        "order": { "playback_stats.max": "desc" }
      },
      "aggs": {
        "playback_stats": { "stats": { "field": "play_count" } }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1333.console"></div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<h3>Pipeline aggs cannot be used for sorting</h3>
<p><a class="xref" href="search-aggregations-pipeline.html" title="Pipeline aggregations">Pipeline aggregations</a> are run during the
reduce phase after all other aggregations have already completed. For this
reason, they cannot be used for ordering.</p>
</div>
</div>
<p>It is also possible to order the buckets based on a "deeper" aggregation in the hierarchy. This is supported as long
as the aggregations path are of a single-bucket type, where the last aggregation in the path may either be a single-bucket
one or a metrics one. If it&#8217;s a single-bucket type, the order will be defined by the number of docs in the bucket (i.e. <code class="literal">doc_count</code>),
in case it&#8217;s a metrics one, the same rules as above apply (where the path must indicate the metric name to sort by in case of
a multi-value metrics aggregation, and in case of a single-value metrics aggregation the sort will be applied on that value).</p>
<p>The path must be defined in the following form:</p>
<div class="pre_wrapper lang-ebnf">
<pre class="programlisting prettyprint lang-ebnf">AGG_SEPARATOR       =  '&gt;' ;
METRIC_SEPARATOR    =  '.' ;
AGG_NAME            =  &lt;the name of the aggregation&gt; ;
METRIC              =  &lt;the name of the metric (in case of multi-value metrics aggregation)&gt; ;
PATH                =  &lt;AGG_NAME&gt; [ &lt;AGG_SEPARATOR&gt;, &lt;AGG_NAME&gt; ]* [ &lt;METRIC_SEPARATOR&gt;, &lt;METRIC&gt; ] ;</pre>
</div>
<a id="terms-aggregation-hierarchy-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "countries": {
      "terms": {
        "field": "artist.country",
        "order": { "rock&gt;playback_stats.avg": "desc" }
      },
      "aggs": {
        "rock": {
          "filter": { "term": { "genre": "rock" } },
          "aggs": {
            "playback_stats": { "stats": { "field": "play_count" } }
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1334.console"></div>
<p>The above will sort the artist&#8217;s countries buckets based on the average play count among the rock songs.</p>
<p>Multiple criteria can be used to order the buckets by providing an array of order criteria such as the following:</p>
<a id="terms-aggregation-multicriteria-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "countries": {
      "terms": {
        "field": "artist.country",
        "order": [ { "rock&gt;playback_stats.avg": "desc" }, { "_count": "desc" } ]
      },
      "aggs": {
        "rock": {
          "filter": { "term": { "genre": "rock" } },
          "aggs": {
            "playback_stats": { "stats": { "field": "play_count" } }
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1335.console"></div>
<p>The above will sort the artist&#8217;s countries buckets based on the average play count among the rock songs and then by
their <code class="literal">doc_count</code> in descending order.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>In the event that two buckets share the same values for all order criteria the bucket&#8217;s term value is used as a
tie-breaker in ascending alphabetical order to prevent non-deterministic ordering of buckets.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_ordering_by_count_ascending"></a>Ordering by count ascending<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>Ordering terms by ascending document <code class="literal">_count</code> produces an unbounded error that
Elasticsearch can&#8217;t accurately report. We therefore strongly recommend against using
<code class="literal">"order": { "_count": "asc" }</code> as shown in the following example:</p>
<a id="terms-aggregation-count-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "genres": {
      "terms": {
        "field": "genre",
        "order": { "_count": "asc" }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1336.console"></div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_minimum_document_count_4"></a>Minimum document count<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>It is possible to only return terms that match more than a configured number of hits using the <code class="literal">min_doc_count</code> option:</p>
<a id="terms-aggregation-min-doc-count-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "tags": {
      "terms": {
        "field": "tags",
        "min_doc_count": 10
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1337.console"></div>
<p>The above aggregation would only return tags which have been found in 10 hits or more. Default value is <code class="literal">1</code>.</p>
<p>Terms are collected and ordered on a shard level and merged with the terms collected from other shards in a second step. However, the shard does not have the information about the global document count available. The decision if a term is added to a candidate list depends only on the order computed on the shard using local shard frequencies. The <code class="literal">min_doc_count</code> criterion is only applied after merging local terms statistics of all shards. In a way the decision to add the term as a candidate is made without being very <em>certain</em> about if the term will actually reach the required <code class="literal">min_doc_count</code>. This might cause many (globally) high frequent terms to be missing in the final result if low frequent terms populated the candidate lists. To avoid this, the <code class="literal">shard_size</code> parameter can be increased to allow more candidate terms on the shards. However, this increases memory consumption and network traffic.</p>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="search-aggregations-bucket-terms-shard-min-doc-count"></a><code class="literal">shard_min_doc_count</code><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>The parameter <code class="literal">shard_min_doc_count</code> regulates the <em>certainty</em> a shard has if the term should actually be added to the candidate list or not with respect to the <code class="literal">min_doc_count</code>. Terms will only be considered if their local shard frequency within the set is higher than the <code class="literal">shard_min_doc_count</code>. If your dictionary contains many low frequent terms and you are not interested in those (for example misspellings), then you can set the <code class="literal">shard_min_doc_count</code> parameter to filter out candidate terms on a shard level that will with a reasonable certainty not reach the required <code class="literal">min_doc_count</code> even after merging the local counts. <code class="literal">shard_min_doc_count</code> is set to <code class="literal">0</code> per default and has no effect unless you explicitly set it.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>Setting <code class="literal">min_doc_count</code>=<code class="literal">0</code> will also return buckets for terms that didn&#8217;t match any hit. However, some of
         the returned terms which have a document count of zero might only belong to deleted documents or documents
         from other types, so there is no warranty that a <code class="literal">match_all</code> query would find a positive document count for
         those terms.</p>
</div>
</div>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>When NOT sorting on <code class="literal">doc_count</code> descending, high values of <code class="literal">min_doc_count</code> may return a number of buckets
         which is less than <code class="literal">size</code> because not enough data was gathered from the shards. Missing buckets can be
         back by increasing <code class="literal">shard_size</code>.
         Setting <code class="literal">shard_min_doc_count</code> too high will cause terms to be filtered out on a shard level. This value should be set much lower than <code class="literal">min_doc_count/#shards</code>.</p>
</div>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-bucket-terms-aggregation-script"></a>Script<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Use a <a class="xref" href="runtime.html" title="Runtime fields">runtime field</a> if the data in your documents doesn&#8217;t
exactly match what you&#8217;d like to aggregate. If, for example, "anthologies"
need to be in a special category then you could run this:</p>
<a id="terms-aggregation-script-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "size": 0,
  "runtime_mappings": {
    "normalized_genre": {
      "type": "keyword",
      "script": """
        String genre = doc['genre'].value;
        if (doc['product'].value.startsWith('Anthology')) {
          emit(genre + ' anthology');
        } else {
          emit(genre);
        }
      """
    }
  },
  "aggs": {
    "genres": {
      "terms": {
        "field": "normalized_genre"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1338.console"></div>
<p>Which will look like:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "aggregations": {
    "genres": {
      "doc_count_error_upper_bound": 0,
      "sum_other_doc_count": 0,
      "buckets": [
        {
          "key": "electronic",
          "doc_count": 4
        },
        {
          "key": "rock",
          "doc_count": 3
        },
        {
          "key": "electronic anthology",
          "doc_count": 2
        },
        {
          "key": "jazz",
          "doc_count": 2
        }
      ]
    }
  },
  ...
}</pre>
</div>
<p>This is a little slower because the runtime field has to access two fields
instead of one and because there are some optimizations that work on
non-runtime <code class="literal">keyword</code> fields that we have to give up for for runtime
<code class="literal">keyword</code> fields. If you need the speed, you can index the
<code class="literal">normalized_genre</code> field.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_filtering_values_4"></a>Filtering Values<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>It is possible to filter the values for which buckets will be created. This can be done using the <code class="literal">include</code> and
<code class="literal">exclude</code> parameters which are based on regular expression strings or arrays of exact values. Additionally,
<code class="literal">include</code> clauses can filter using <code class="literal">partition</code> expressions.</p>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_filtering_values_with_regular_expressions_2"></a>Filtering Values with regular expressions<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<a id="terms-aggregation-regex-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "tags": {
      "terms": {
        "field": "tags",
        "include": ".*sport.*",
        "exclude": "water_.*"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1339.console"></div>
<p>In the above example, buckets will be created for all the tags that has the word <code class="literal">sport</code> in them, except those starting
with <code class="literal">water_</code> (so the tag <code class="literal">water_sports</code> will not be aggregated). The <code class="literal">include</code> regular expression will determine what
values are "allowed" to be aggregated, while the <code class="literal">exclude</code> determines the values that should not be aggregated. When
both are defined, the <code class="literal">exclude</code> has precedence, meaning, the <code class="literal">include</code> is evaluated first and only then the <code class="literal">exclude</code>.</p>
<p>The syntax is the same as <a class="xref" href="regexp-syntax.html" title="Regular expression syntax">regexp queries</a>.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_filtering_values_with_exact_values_2"></a>Filtering Values with exact values<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>For matching based on exact values the <code class="literal">include</code> and <code class="literal">exclude</code> parameters can simply take an array of
strings that represent the terms as they are found in the index:</p>
<a id="terms-aggregation-exact-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "JapaneseCars": {
      "terms": {
        "field": "make",
        "include": [ "mazda", "honda" ]
      }
    },
    "ActiveCarManufacturers": {
      "terms": {
        "field": "make",
        "exclude": [ "rover", "jensen" ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1340.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_filtering_values_with_partitions"></a>Filtering Values with partitions<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>Sometimes there are too many unique terms to process in a single request/response pair so
it can be useful to break the analysis up into multiple requests.
This can be achieved by grouping the field&#8217;s values into a number of partitions at query-time and processing
only one partition in each request.
Consider this request which is looking for accounts that have not logged any access recently:</p>
<a id="terms-aggregation-partitions-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
   "size": 0,
   "aggs": {
      "expired_sessions": {
         "terms": {
            "field": "account_id",
            "include": {
               "partition": 0,
               "num_partitions": 20
            },
            "size": 10000,
            "order": {
               "last_access": "asc"
            }
         },
         "aggs": {
            "last_access": {
               "max": {
                  "field": "access_date"
               }
            }
         }
      }
   }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1341.console"></div>
<p>This request is finding the last logged access date for a subset of customer accounts because we
might want to expire some customer accounts who haven&#8217;t been seen for a long while.
The <code class="literal">num_partitions</code> setting has requested that the unique account_ids are organized evenly into twenty
partitions (0 to 19). and the <code class="literal">partition</code> setting in this request filters to only consider account_ids falling
into partition 0. Subsequent requests should ask for partitions 1 then 2 etc to complete the expired-account analysis.</p>
<p>Note that the <code class="literal">size</code> setting for the number of results returned needs to be tuned with the <code class="literal">num_partitions</code>.
For this particular account-expiration example the process for balancing values for <code class="literal">size</code> and <code class="literal">num_partitions</code> would be as follows:</p>
<div class="olist orderedlist">
<ol class="orderedlist">
<li class="listitem">
Use the <code class="literal">cardinality</code> aggregation to estimate the total number of unique account_id values
</li>
<li class="listitem">
Pick a value for <code class="literal">num_partitions</code> to break the number from 1) up into more manageable chunks
</li>
<li class="listitem">
Pick a <code class="literal">size</code> value for the number of responses we want from each partition
</li>
<li class="listitem">
Run a test request
</li>
</ol>
</div>
<p>If we have a circuit-breaker error we are trying to do too much in one request and must increase <code class="literal">num_partitions</code>.
If the request was successful but the last account ID in the date-sorted test response was still an account we might want to
expire then we may be missing accounts of interest and have set our numbers too low. We must either</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
increase the <code class="literal">size</code> parameter to return more results per partition (could be heavy on memory) or
</li>
<li class="listitem">
increase the <code class="literal">num_partitions</code> to consider less accounts per request (could increase overall processing time as we need to make more requests)
</li>
</ul>
</div>
<p>Ultimately this is a balancing act between managing the Elasticsearch resources required to process a single request and the volume
of requests that the client application must issue to complete a task.</p>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>Partitions cannot be used together with an <code class="literal">exclude</code> parameter.</p>
</div>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_multi_field_terms_aggregation"></a>Multi-field terms aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">terms</code> aggregation does not support collecting terms from multiple fields
in the same document. The reason is that the <code class="literal">terms</code> agg doesn&#8217;t collect the
string term values themselves, but rather uses
<a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation-execution-hint" title="Execution hint">global ordinals</a>
to produce a list of all of the unique values in the field. Global ordinals
results in an important performance boost which would not be possible across
multiple fields.</p>
<p>There are three approaches that you can use to perform a <code class="literal">terms</code> agg across
multiple fields:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation-script" title="Script">Script</a>
</span>
</dt>
<dd>
Use a script to retrieve terms from multiple fields. This disables the global
ordinals optimization and will be slower than collecting terms from a single
field, but it gives you the flexibility to implement this option at search
time.
</dd>
<dt>
<span class="term">
<a class="xref" href="mapping-params.html#copy-to" title="copy_to"><code class="literal">copy_to</code> field</a>
</span>
</dt>
<dd>
If you know ahead of time that you want to collect the terms from two or more
fields, then use <code class="literal">copy_to</code> in your mapping to create a new dedicated field at
index time which contains the values from both fields. You can aggregate on
this single field, which will benefit from the global ordinals optimization.
</dd>
<dt>
<span class="term">
<a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-multi-terms-aggregation" title="Multi Terms aggregation"><code class="literal">multi_terms</code> aggregation</a>
</span>
</dt>
<dd>
Use multi_terms aggregation to combine terms from multiple fields into a compound key. This
also disables the global ordinals and will be slower than collecting terms from a single field.
It is faster but less flexible than using a script.
</dd>
</dl>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-bucket-terms-aggregation-collect"></a>Collect mode<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Deferring calculation of child aggregations</p>
<p>For fields with many unique terms and a small number of required results it can be more efficient to delay the calculation
of child aggregations until the top parent-level aggs have been pruned. Ordinarily, all branches of the aggregation tree
are expanded in one depth-first pass and only then any pruning occurs.
In some scenarios this can be very wasteful and can hit memory constraints.
An example problem scenario is querying a movie database for the 10 most popular actors and their 5 most common co-stars:</p>
<a id="terms-aggregation-collect-mode-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "actors": {
      "terms": {
        "field": "actors",
        "size": 10
      },
      "aggs": {
        "costars": {
          "terms": {
            "field": "actors",
            "size": 5
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1342.console"></div>
<p>Even though the number of actors may be comparatively small and we want only 50 result buckets there is a combinatorial explosion of buckets
during calculation - a single actor can produce n² buckets where n is the number of actors. The sane option would be to first determine
the 10 most popular actors and only then examine the top co-stars for these 10 actors. This alternative strategy is what we call the <code class="literal">breadth_first</code> collection
mode as opposed to the <code class="literal">depth_first</code> mode.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>The <code class="literal">breadth_first</code> is the default mode for fields with a cardinality bigger than the requested size or when the cardinality is unknown (numeric fields or scripts for instance).
It is possible to override the default heuristic and to provide a collect mode directly in the request:</p>
</div>
</div>
<a id="terms-aggregation-breadth-first-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "actors": {
      "terms": {
        "field": "actors",
        "size": 10,
        "collect_mode": "breadth_first" <a id="CO293-1"></a><i class="conum" data-value="1"></i>
      },
      "aggs": {
        "costars": {
          "terms": {
            "field": "actors",
            "size": 5
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1343.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO293-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>the possible values are <code class="literal">breadth_first</code> and <code class="literal">depth_first</code></p>
</td>
</tr>
</table>
</div>
<p>When using <code class="literal">breadth_first</code> mode the set of documents that fall into the uppermost buckets are
cached for subsequent replay so there is a memory overhead in doing this which is linear with the number of matching documents.
Note that the <code class="literal">order</code> parameter can still be used to refer to data from a child aggregation when using the <code class="literal">breadth_first</code> setting - the parent
aggregation understands that this child aggregation will need to be called first before any of the other child aggregations.</p>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>Nested aggregations such as <code class="literal">top_hits</code> which require access to score information under an aggregation that uses the <code class="literal">breadth_first</code>
collection mode need to replay the query on the second pass but only for the documents belonging to the top buckets.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-bucket-terms-aggregation-execution-hint"></a>Execution hint<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>There are different mechanisms by which terms aggregations can be executed:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
by using field values directly in order to aggregate data per-bucket (<code class="literal">map</code>)
</li>
<li class="listitem">
by using global ordinals of the field and allocating one bucket per global ordinal (<code class="literal">global_ordinals</code>)
</li>
</ul>
</div>
<p>Elasticsearch tries to have sensible defaults so this is something that generally doesn&#8217;t need to be configured.</p>
<p><code class="literal">global_ordinals</code> is the default option for <code class="literal">keyword</code> field, it uses global ordinals to allocates buckets dynamically
so memory usage is linear to the number of values of the documents that are part of the aggregation scope.</p>
<p><code class="literal">map</code> should only be considered when very few documents match a query. Otherwise the ordinals-based execution mode
is significantly faster. By default, <code class="literal">map</code> is only used when running an aggregation on scripts, since they don&#8217;t have
ordinals.</p>
<a id="terms-aggregation-execution-hint-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "tags": {
      "terms": {
        "field": "tags",
        "execution_hint": "map" <a id="CO294-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1344.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO294-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The possible values are <code class="literal">map</code>, <code class="literal">global_ordinals</code></p>
</td>
</tr>
</table>
</div>
<p>Please note that Elasticsearch will ignore this execution hint if it is not applicable and that there is no backward compatibility guarantee on these hints.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_missing_value_5"></a>Missing value<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">missing</code> parameter defines how documents that are missing a value should be treated.
By default they will be ignored but it is also possible to treat them as if they
had a value.</p>
<a id="terms-aggregation-missing-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "tags": {
      "terms": {
        "field": "tags",
        "missing": "N/A" <a id="CO295-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1345.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO295-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Documents without a value in the <code class="literal">tags</code> field will fall into the same bucket as documents that have the value <code class="literal">N/A</code>.</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_mixing_field_types_2"></a>Mixing field types<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>When aggregating on multiple indices the type of the aggregated field may not be the same in all indices.
Some types are compatible with each other (<code class="literal">integer</code> and <code class="literal">long</code> or <code class="literal">float</code> and <code class="literal">double</code>) but when the types are a mix
of decimal and non-decimal number the terms aggregation will promote the non-decimal numbers to decimal numbers.
This can result in a loss of precision in the bucket values.</p>
</div>
</div>
<h4><a id="search-aggregations-bucket-terms-aggregation-troubleshooting"></a>Troubleshooting<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h4>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_failed_trying_to_format_bytes"></a>Failed Trying to Format Bytes<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>When running a terms aggregation (or other aggregation, but in practice usually
terms) over multiple indices, you may get an error that starts with "Failed
trying to format bytes&#8230;&#8203;".  This is usually caused by two of the indices not
having the same mapping type for the field being aggregated.</p>
<p><span class="strong strong"><strong>Use an explicit <code class="literal">value_type</code></strong></span>
Although it&#8217;s best to correct the mappings, you can work around this issue if
the field is unmapped in one of the indices.  Setting the <code class="literal">value_type</code> parameter
can resolve the issue by coercing the unmapped field into the correct type.</p>
<a id="terms-aggregation-value_type-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "ip_addresses": {
      "terms": {
        "field": "destination_ip",
        "missing": "0.0.0.0",
        "value_type": "ip"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1346.console"></div>
</div>

</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-time-series-aggregation"></a>Time series aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/time-series-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>This functionality is in technical preview and may be changed or removed in a future release. Elastic will apply best effort to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.</p>
</div>
</div>
<p>The time series aggregation queries data created using a time series index. This is typically data such as metrics
or other data streams with a time component, and requires creating an index using the time series mode.</p>
<p>Data can be added to the time series index like other indices:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">PUT /my-time-series-index-0/_bulk
{ "index": {} }
{ "key": "a", "val": 1, "@timestamp": "2022-01-01T00:00:10Z" }
{ "index": {}}
{ "key": "a", "val": 2, "@timestamp": "2022-01-02T00:00:00Z" }
{ "index": {} }
{ "key": "b", "val": 2, "@timestamp": "2022-01-01T00:00:10Z" }
{ "index": {}}
{ "key": "b", "val": 3, "@timestamp": "2022-01-02T00:00:00Z" }</pre>
</div>
<p>This will return all results in the time series, however a more typical query will use sub aggregations to reduce the
date returned to something more relevant.</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-bucket-time-series-aggregation-size"></a>Size<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/time-series-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>By default, <code class="literal">time series</code> aggregations return 10000 results. The "size" parameter can be used to limit the results
further. Alternatively, using sub aggregations can limit the amount of values returned as a time series aggregation.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-bucket-time-series-aggregation-keyed"></a>Keyed<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/time-series-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">keyed</code> parameter determines if buckets are returned as a map with unique keys per bucket. By default with <code class="literal">keyed</code>
set to false, buckets are returned as an array.</p>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-variablewidthhistogram-aggregation"></a>Variable width histogram aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/variablewidthhistogram-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>This is a multi-bucket aggregation similar to <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-histogram-aggregation" title="Histogram aggregation">Histogram</a>.
However, the width of each bucket is not specified. Rather, a target number of buckets is provided and bucket intervals
are dynamically determined based on the document distribution. This is done using a simple one-pass document clustering algorithm
that aims to obtain low distances between bucket centroids. Unlike other multi-bucket aggregations, the intervals will not
necessarily have a uniform width.</p>
<div class="tip admon">
<div class="icon"></div>
<div class="admon_content">
<p>The number of buckets returned will always be less than or equal to the target number.</p>
</div>
</div>
<p>Requesting a target of 2 buckets.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "prices": {
      "variable_width_histogram": {
        "field": "price",
        "buckets": 2
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1347.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "prices": {
      "buckets": [
        {
          "min": 10.0,
          "key": 30.0,
          "max": 50.0,
          "doc_count": 2
        },
        {
          "min": 150.0,
          "key": 185.0,
          "max": 200.0,
          "doc_count": 5
        }
      ]
    }
  }
}</pre>
</div>
<div class="important admon">
<div class="icon"></div>
<div class="admon_content">
<p>This aggregation cannot currently be nested under any aggregation that collects from more than a single bucket.</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_clustering_algorithm"></a>Clustering Algorithm<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/variablewidthhistogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Each shard fetches the first <code class="literal">initial_buffer</code> documents and stores them in memory. Once the buffer is full, these documents
are sorted and linearly separated into <code class="literal">3/4 * shard_size buckets</code>.
Next each remaining documents is either collected into the nearest bucket, or placed into a new bucket if it is distant
from all the existing ones. At most <code class="literal">shard_size</code> total buckets are created.</p>
<p>In the reduce step, the coordinating node sorts the buckets from all shards by their centroids. Then, the two buckets
with the nearest centroids are repeatedly merged until the target number of buckets is achieved.
This merging procedure is a form of <a href="https://en.wikipedia.org/wiki/Hierarchical_clustering" class="ulink" target="_top">agglomerative hierarchical clustering</a>.</p>
<div class="tip admon">
<div class="icon"></div>
<div class="admon_content">
<p>A shard can return fewer than <code class="literal">shard_size</code> buckets, but it cannot return more.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_shard_size_3"></a>Shard size<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/variablewidthhistogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">shard_size</code> parameter specifies the number of buckets that the coordinating node will request from each shard.
A higher <code class="literal">shard_size</code> leads each shard to produce smaller buckets. This reduces the likelihood of buckets overlapping
after the reduction step. Increasing the <code class="literal">shard_size</code> will improve the accuracy of the histogram, but it will
also make it more expensive to compute the final result because bigger priority queues will have to be managed on a
shard level, and the data transfers between the nodes and the client will be larger.</p>
<div class="tip admon">
<div class="icon"></div>
<div class="admon_content">
<p>Parameters <code class="literal">buckets</code>, <code class="literal">shard_size</code>, and <code class="literal">initial_buffer</code> are optional. By default, <code class="literal">buckets = 10</code>, <code class="literal">shard_size = buckets * 50</code>, and <code class="literal">initial_buffer = min(10 * shard_size, 50000)</code>.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_initial_buffer"></a>Initial Buffer<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/variablewidthhistogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">initial_buffer</code> parameter can be used to specify the number of individual documents that will be stored in memory
on a shard before the initial bucketing algorithm is run. Bucket distribution is determined using this sample
of <code class="literal">initial_buffer</code> documents. So, although a higher <code class="literal">initial_buffer</code> will use more memory, it will lead to more representative
clusters.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_bucket_bounds_are_approximate"></a>Bucket bounds are approximate<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/variablewidthhistogram-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>During the reduce step, the master node continuously merges the two buckets with the nearest centroids. If two buckets have
overlapping bounds but distant centroids, then it is possible that they will not be merged. Because of this, after
reduction the maximum value in some interval (<code class="literal">max</code>) might be greater than the minimum value in the subsequent
bucket (<code class="literal">min</code>). To reduce the impact of this error, when such an overlap occurs the bound between these intervals is adjusted to be <code class="literal">(max + min) / 2</code>.</p>
<div class="tip admon">
<div class="icon"></div>
<div class="admon_content">
<p>Bucket bounds are very sensitive to outliers</p>
</div>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-range-field-note"></a>Subtleties of bucketing range fields<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/range-field-note.asciidoc">edit</a></h2>
</div></div></div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_documents_are_counted_for_each_bucket_they_land_in"></a>Documents are counted for each bucket they land in<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/range-field-note.asciidoc">edit</a></h3>
</div></div></div>
<p>Since a range represents multiple values, running a bucket aggregation over a
range field can result in the same document landing in multiple buckets. This
can lead to surprising behavior, such as the sum of bucket counts being higher
than the number of matched documents. For example, consider the following
index:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT range_index
{
  "settings": {
    "number_of_shards": 2
  },
  "mappings": {
    "properties": {
      "expected_attendees": {
        "type": "integer_range"
      },
      "time_frame": {
        "type": "date_range",
        "format": "yyyy-MM-dd||epoch_millis"
      }
    }
  }
}

PUT range_index/_doc/1?refresh
{
  "expected_attendees" : {
    "gte" : 10,
    "lte" : 20
  },
  "time_frame" : {
    "gte" : "2019-10-28",
    "lte" : "2019-11-04"
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1348.console"></div>
<p>The range is wider than the interval in the following aggregation, and thus the
document will land in multiple buckets.</p>
<a id="range-field-aggregation-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /range_index/_search?size=0
{
  "aggs": {
    "range_histo": {
      "histogram": {
        "field": "expected_attendees",
        "interval": 5
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1349.console"></div>
<p>Since the interval is <code class="literal">5</code> (and the offset is <code class="literal">0</code> by default), we expect buckets <code class="literal">10</code>,
<code class="literal">15</code>, and <code class="literal">20</code>. Our range document will fall in all three of these buckets.</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations" : {
    "range_histo" : {
      "buckets" : [
        {
          "key" : 10.0,
          "doc_count" : 1
        },
        {
          "key" : 15.0,
          "doc_count" : 1
        },
        {
          "key" : 20.0,
          "doc_count" : 1
        }
      ]
    }
  }
}</pre>
</div>
<p>A document cannot exist partially in a bucket; For example, the above document
cannot count as one-third in each of the above three buckets. In this example,
since the document&#8217;s range landed in multiple buckets, the full value of that
document would also be counted in any sub-aggregations for each bucket as well.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_query_bounds_are_not_aggregation_filters"></a>Query bounds are not aggregation filters<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/bucket/range-field-note.asciidoc">edit</a></h3>
</div></div></div>
<p>Another unexpected behavior can arise when a query is used to filter on the
field being aggregated. In this case, a document could match the query but
still have one or both of the endpoints of the range outside the query.
Consider the following aggregation on the above document:</p>
<a id="range-field-aggregation-query-bounds-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /range_index/_search?size=0
{
  "query": {
    "range": {
      "time_frame": {
        "gte": "2019-11-01",
        "format": "yyyy-MM-dd"
      }
    }
  },
  "aggs": {
    "november_data": {
      "date_histogram": {
        "field": "time_frame",
        "calendar_interval": "day",
        "format": "yyyy-MM-dd"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1350.console"></div>
<p>Even though the query only considers days in November, the aggregation
generates 8 buckets (4 in October, 4 in November) because the aggregation is
calculated over the ranges of all matching documents.</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations" : {
    "november_data" : {
      "buckets" : [
              {
          "key_as_string" : "2019-10-28",
          "key" : 1572220800000,
          "doc_count" : 1
        },
        {
          "key_as_string" : "2019-10-29",
          "key" : 1572307200000,
          "doc_count" : 1
        },
        {
          "key_as_string" : "2019-10-30",
          "key" : 1572393600000,
          "doc_count" : 1
        },
        {
          "key_as_string" : "2019-10-31",
          "key" : 1572480000000,
          "doc_count" : 1
        },
        {
          "key_as_string" : "2019-11-01",
          "key" : 1572566400000,
          "doc_count" : 1
        },
        {
          "key_as_string" : "2019-11-02",
          "key" : 1572652800000,
          "doc_count" : 1
        },
        {
          "key_as_string" : "2019-11-03",
          "key" : 1572739200000,
          "doc_count" : 1
        },
        {
          "key_as_string" : "2019-11-04",
          "key" : 1572825600000,
          "doc_count" : 1
        }
      ]
    }
  }
}</pre>
</div>
<p>Depending on the use case, a <code class="literal">CONTAINS</code> query could limit the documents to only
those that fall entirely in the queried range. In this example, the one
document would not be included and the aggregation would be empty. Filtering
the buckets after the aggregation is also an option, for use cases where the
document should be counted but the out of bounds data can be safely ignored.</p>
</div>

</div>

</div>
<div class="navfooter">
<span class="prev">
<a href="search-aggregations.html">« Aggregations</a>
</span>
<span class="next">
<a href="search-aggregations-metrics.html">Metrics aggregations »</a>
</span>
</div>
</div>

                  <!-- end body -->
                </div>

                <div class="col-12 order-3 col-lg-2 order-lg-3 h-almost-full-lg sticky-top-lg" id="right_col">
                  <div id="sticky_content">
                    <!-- The OTP is appended here -->
                    <div class="row">
                      <div class="col-0 col-md-4 col-lg-0" id="bottom_left_col"></div>
                      <div class="col-12 col-md-8 col-lg-12">
                        <div id="rtpcontainer">
                          <div class="mktg-promo" id="most-popular">
                            <p class="aside-heading">Most Popular</p>
                            <div class="pb-2">
                              <p class="media-type">Video</p>
                              <a href="https://www.elastic.co/webinars/getting-started-elasticsearch?page=docs&placement=top-video">
                                <p class="mb-0">Get Started with Elasticsearch</p>
                              </a>
                            </div>
                            <div class="pb-2">
                              <p class="media-type">Video</p>
                              <a href="https://www.elastic.co/webinars/getting-started-kibana?page=docs&placement=top-video">
                                <p class="mb-0">Intro to Kibana</p>
                              </a>
                            </div>
                            <div class="pb-2">
                              <p class="media-type">Video</p>
                              <a href="https://www.elastic.co/webinars/introduction-elk-stack?page=docs&placement=top-video">
                                <p class="mb-0">ELK for Logs & Metrics</p>
                              </a>
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </section>

        </div>


<div id='elastic-footer'></div>
<script src='https://www.elastic.co/elastic-footer.js'></script>
<!-- Footer Section end-->

      </section>
    </div>

<script src="/guide/static/jquery.js"></script>
<script type="text/javascript" src="/guide/static/docs.js"></script>
<script type="text/javascript">
  window.initial_state = {}</script>
  </body>
</html>
