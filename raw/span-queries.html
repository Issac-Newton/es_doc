<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Span queries | Elasticsearch Guide | Elastic</title>
<meta class="elastic" name="content" content="Span queries | Elasticsearch Guide">

<link rel="home" href="index.html" title="Elasticsearch Guide"/>
<link rel="up" href="query-dsl.html" title="Query DSL"/>
<link rel="prev" href="query-dsl-match-all-query.html" title="Match all query"/>
<link rel="next" href="specialized-queries.html" title="Specialized queries"/>
<meta class="elastic" name="product_version" content=""/>
<meta class="elastic" name="product_name" content=""/>
<meta class="elastic" name="website_area" content="documentation"/>
<meta name="DC.type" content="Learn/Docs/"/>
<meta name="DC.subject" content=""/>
<meta name="DC.identifier" content=""/>
</head>
<body>
<div id="content">
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="/guide/">Elastic Docs</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="index.html">Elasticsearch Guide</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="query-dsl.html">Query DSL</a></span>
</div>
<div class="navheader">
<span class="prev">
<a href="query-dsl-match-all-query.html">« Match all query</a>
</span>
<span class="next">
<a href="specialized-queries.html">Specialized queries »</a>
</span>
</div>
<div class="chapter">
<div class="titlepage"><div><div>
<h2 class="title"><a id="span-queries"></a>Span queries<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/query-dsl/span-queries.asciidoc">edit</a></h2>
</div></div></div>
<p>Span queries are low-level positional queries which provide expert control
over the order and proximity of the specified terms. These are typically used
to implement very specific queries on legal documents or patents.</p>
<p>It is only allowed to set boost on an outer span query. Compound span queries,
like span_near, only use the list of matching spans of inner span queries in
order to find their own spans, which they then use to produce a score. Scores
are never computed on inner span queries, which is the reason why boosts are not
allowed: they only influence the way scores are computed, not spans.</p>
<p>Span queries cannot be mixed with non-span queries (with the exception of the <code class="literal">span_multi</code> query).</p>
<p>The queries in this group are:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<a class="xref" href="span-queries.html#query-dsl-span-containing-query" title="Span containing query"><code class="literal">span_containing</code> query</a>
</span>
</dt>
<dd>
Accepts a list of span queries, but only returns those spans which also match a second span query.
</dd>
<dt>
<span class="term">
<a class="xref" href="span-queries.html#query-dsl-span-field-masking-query" title="Span field masking query"><code class="literal">field_masking_span</code> query</a>
</span>
</dt>
<dd>
Allows queries like <code class="literal">span-near</code> or <code class="literal">span-or</code> across different fields.
</dd>
<dt>
<span class="term">
<a class="xref" href="span-queries.html#query-dsl-span-first-query" title="Span first query"><code class="literal">span_first</code> query</a>
</span>
</dt>
<dd>
Accepts another span query whose matches must appear within the first N
positions of the field.
</dd>
<dt>
<span class="term">
<a class="xref" href="span-queries.html#query-dsl-span-multi-term-query" title="Span multi-term query"><code class="literal">span_multi</code> query</a>
</span>
</dt>
<dd>
Wraps a <a class="xref" href="term-level-queries.html#query-dsl-term-query" title="Term query"><code class="literal">term</code></a>, <a class="xref" href="term-level-queries.html#query-dsl-range-query" title="Range query"><code class="literal">range</code></a>,
<a class="xref" href="term-level-queries.html#query-dsl-prefix-query" title="Prefix query"><code class="literal">prefix</code></a>, <a class="xref" href="term-level-queries.html#query-dsl-wildcard-query" title="Wildcard query"><code class="literal">wildcard</code></a>,
<a class="xref" href="term-level-queries.html#query-dsl-regexp-query" title="Regexp query"><code class="literal">regexp</code></a>, or <a class="xref" href="term-level-queries.html#query-dsl-fuzzy-query" title="Fuzzy query"><code class="literal">fuzzy</code></a> query.
</dd>
<dt>
<span class="term">
<a class="xref" href="span-queries.html#query-dsl-span-near-query" title="Span near query"><code class="literal">span_near</code> query</a>
</span>
</dt>
<dd>
Accepts multiple span queries whose matches must be within the specified distance of each other, and possibly in the same order.
</dd>
<dt>
<span class="term">
<a class="xref" href="span-queries.html#query-dsl-span-not-query" title="Span not query"><code class="literal">span_not</code> query</a>
</span>
</dt>
<dd>
Wraps another span query, and excludes any documents which match that query.
</dd>
<dt>
<span class="term">
<a class="xref" href="span-queries.html#query-dsl-span-or-query" title="Span or query"><code class="literal">span_or</code> query</a>
</span>
</dt>
<dd>
Combines multiple span queries&#8201;&#8212;&#8201;returns documents which match any of the
specified queries.
</dd>
<dt>
<span class="term">
<a class="xref" href="span-queries.html#query-dsl-span-term-query" title="Span term query"><code class="literal">span_term</code> query</a>
</span>
</dt>
<dd>
The equivalent of the <a class="xref" href="term-level-queries.html#query-dsl-term-query" title="Term query"><code class="literal">term</code> query</a> but for use with
other span queries.
</dd>
<dt>
<span class="term">
<a class="xref" href="span-queries.html#query-dsl-span-within-query" title="Span within query"><code class="literal">span_within</code> query</a>
</span>
</dt>
<dd>
The result from a single span query is returned as long is its span falls
within the spans returned by a list of other span queries.
</dd>
</dl>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="query-dsl-span-containing-query"></a>Span containing query<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/query-dsl/span-containing-query.asciidoc">edit</a></h2>
</div></div></div>

<p>Returns matches which enclose another span query. The span containing
query maps to Lucene <code class="literal">SpanContainingQuery</code>. Here is an example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "query": {
    "span_containing": {
      "little": {
        "span_term": { "field1": "foo" }
      },
      "big": {
        "span_near": {
          "clauses": [
            { "span_term": { "field1": "bar" } },
            { "span_term": { "field1": "baz" } }
          ],
          "slop": 5,
          "in_order": true
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/862.console"></div>
<p>The <code class="literal">big</code> and <code class="literal">little</code> clauses can be any span type query. Matching
spans from <code class="literal">big</code> that contain matches from <code class="literal">little</code> are returned.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="query-dsl-span-field-masking-query"></a>Span field masking query<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/query-dsl/span-field-masking-query.asciidoc">edit</a></h2>
</div></div></div>

<p>Wrapper to allow span queries to participate in composite single-field span queries by <em>lying</em> about their search field. The span field masking query maps to Lucene&#8217;s <code class="literal">SpanFieldMaskingQuery</code></p>
<p>This can be used to support queries like <code class="literal">span-near</code> or <code class="literal">span-or</code> across different fields, which is not ordinarily permitted.</p>
<p>Span field masking query is invaluable in conjunction with <span class="strong strong"><strong>multi-fields</strong></span> when same content is indexed with multiple analyzers. For instance we could index a field with the standard analyzer which breaks text up into words, and again with the english analyzer which stems words into their root form.</p>
<p>Example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "query": {
    "span_near": {
      "clauses": [
        {
          "span_term": {
            "text": "quick brown"
          }
        },
        {
          "field_masking_span": {
            "query": {
              "span_term": {
                "text.stems": "fox"
              }
            },
            "field": "text"
          }
        }
      ],
      "slop": 5,
      "in_order": false
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/863.console"></div>
<p>Note: as span field masking query returns the masked field, scoring will be done using the norms of the field name supplied. This may lead to unexpected scoring behaviour.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="query-dsl-span-first-query"></a>Span first query<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/query-dsl/span-first-query.asciidoc">edit</a></h2>
</div></div></div>

<p>Matches spans near the beginning of a field. The span first query maps
to Lucene <code class="literal">SpanFirstQuery</code>. Here is an example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "query": {
    "span_first": {
      "match": {
        "span_term": { "user.id": "kimchy" }
      },
      "end": 3
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/864.console"></div>
<p>The <code class="literal">match</code> clause can be any other span type query. The <code class="literal">end</code> controls
the maximum end position permitted in a match.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="query-dsl-span-multi-term-query"></a>Span multi-term query<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/query-dsl/span-multi-term-query.asciidoc">edit</a></h2>
</div></div></div>

<p>The <code class="literal">span_multi</code> query allows you to wrap a <code class="literal">multi term query</code> (one of wildcard,
fuzzy, prefix, range or regexp query) as a <code class="literal">span query</code>, so
it can be nested. Example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "query": {
    "span_multi": {
      "match": {
        "prefix": { "user.id": { "value": "ki" } }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/865.console"></div>
<p>A boost can also be associated with the query:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "query": {
    "span_multi": {
      "match": {
        "prefix": { "user.id": { "value": "ki", "boost": 1.08 } }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/866.console"></div>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p><code class="literal">span_multi</code> queries will hit too many clauses failure if the number of terms that match the query exceeds the
boolean query limit (defaults to 1024).To avoid an unbounded expansion you can set the <a class="xref" href="query-dsl-multi-term-rewrite.html" title="rewrite parameter">rewrite method</a> of the multi term query to <code class="literal">top_terms_*</code> rewrite. Or, if you use <code class="literal">span_multi</code> on <code class="literal">prefix</code> query only,
you can activate the <a class="xref" href="mapping-params.html#index-prefixes" title="index_prefixes"><code class="literal">index_prefixes</code></a> field option of the <code class="literal">text</code> field instead. This will
rewrite any prefix query on the field to a single term query that matches the indexed prefix.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="query-dsl-span-near-query"></a>Span near query<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/query-dsl/span-near-query.asciidoc">edit</a></h2>
</div></div></div>

<p>Matches spans which are near one another. One can specify <em>slop</em>, the
maximum number of intervening unmatched positions, as well as whether
matches are required to be in-order. The span near query maps to Lucene
<code class="literal">SpanNearQuery</code>. Here is an example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "query": {
    "span_near": {
      "clauses": [
        { "span_term": { "field": "value1" } },
        { "span_term": { "field": "value2" } },
        { "span_term": { "field": "value3" } }
      ],
      "slop": 12,
      "in_order": false
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/867.console"></div>
<p>The <code class="literal">clauses</code> element is a list of one or more other span type queries
and the <code class="literal">slop</code> controls the maximum number of intervening unmatched
positions permitted.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="query-dsl-span-not-query"></a>Span not query<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/query-dsl/span-not-query.asciidoc">edit</a></h2>
</div></div></div>

<p>Removes matches which overlap with another span query or which are
within x tokens before (controlled by the parameter <code class="literal">pre</code>) or y tokens
after (controlled by the parameter <code class="literal">post</code>) another SpanQuery. The span not
query maps to Lucene <code class="literal">SpanNotQuery</code>. Here is an example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "query": {
    "span_not": {
      "include": {
        "span_term": { "field1": "hoya" }
      },
      "exclude": {
        "span_near": {
          "clauses": [
            { "span_term": { "field1": "la" } },
            { "span_term": { "field1": "hoya" } }
          ],
          "slop": 0,
          "in_order": true
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/868.console"></div>
<p>The <code class="literal">include</code> and <code class="literal">exclude</code> clauses can be any span type query. The
<code class="literal">include</code> clause is the span query whose matches are filtered, and the
<code class="literal">exclude</code> clause is the span query whose matches must not overlap those
returned.</p>
<p>In the above example all documents with the term hoya are filtered except the ones that have <em>la</em> preceding them.</p>
<p>Other top level options:</p>
<div class="informaltable">
<table border="0" cellpadding="4px">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody valign="top">
<tr>
<td valign="top">
<p>
<code class="literal">pre</code>
</p>
</td>
<td valign="top">
<p>
If set the amount of tokens before the include span can&#8217;t have overlap with the exclude span. Defaults to 0.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">post</code>
</p>
</td>
<td valign="top">
<p>
If set the amount of tokens after the include span can&#8217;t have overlap with the exclude span. Defaults to 0.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">dist</code>
</p>
</td>
<td valign="top">
<p>
If set the amount of tokens from within the include span can&#8217;t have overlap with the exclude span. Equivalent
of setting both <code class="literal">pre</code> and <code class="literal">post</code>.
</p>
</td>
</tr>
</tbody>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="query-dsl-span-or-query"></a>Span or query<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/query-dsl/span-or-query.asciidoc">edit</a></h2>
</div></div></div>

<p>Matches the union of its span clauses. The span or query maps to Lucene
<code class="literal">SpanOrQuery</code>. Here is an example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "query": {
    "span_or" : {
      "clauses" : [
        { "span_term" : { "field" : "value1" } },
        { "span_term" : { "field" : "value2" } },
        { "span_term" : { "field" : "value3" } }
      ]
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/869.console"></div>
<p>The <code class="literal">clauses</code> element is a list of one or more other span type queries.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="query-dsl-span-term-query"></a>Span term query<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/query-dsl/span-term-query.asciidoc">edit</a></h2>
</div></div></div>

<p>Matches spans containing a term. The span term query maps to Lucene
<code class="literal">SpanTermQuery</code>. Here is an example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "query": {
    "span_term" : { "user.id" : "kimchy" }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/870.console"></div>
<p>A boost can also be associated with the query:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "query": {
    "span_term" : { "user.id" : { "value" : "kimchy", "boost" : 2.0 } }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/871.console"></div>
<p>Or :</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "query": {
    "span_term" : { "user.id" : { "term" : "kimchy", "boost" : 2.0 } }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/872.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="query-dsl-span-within-query"></a>Span within query<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/query-dsl/span-within-query.asciidoc">edit</a></h2>
</div></div></div>

<p>Returns matches which are enclosed inside another span query. The span within
query maps to Lucene <code class="literal">SpanWithinQuery</code>. Here is an example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "query": {
    "span_within": {
      "little": {
        "span_term": { "field1": "foo" }
      },
      "big": {
        "span_near": {
          "clauses": [
            { "span_term": { "field1": "bar" } },
            { "span_term": { "field1": "baz" } }
          ],
          "slop": 5,
          "in_order": true
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/873.console"></div>
<p>The <code class="literal">big</code> and <code class="literal">little</code> clauses can be any span type query. Matching
spans from <code class="literal">little</code> that are enclosed within <code class="literal">big</code> are returned.</p>
</div>

</div>
<div class="navfooter">
<span class="prev">
<a href="query-dsl-match-all-query.html">« Match all query</a>
</span>
<span class="next">
<a href="specialized-queries.html">Specialized queries »</a>
</span>
</div>
</div>
</body>
</html>
