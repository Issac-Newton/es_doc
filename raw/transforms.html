<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Transforming data | Elasticsearch Guide | Elastic</title>
<meta class="elastic" name="content" content="Transforming data | Elasticsearch Guide">

<link rel="home" href="index.html" title="Elasticsearch Guide"/>
<link rel="up" href="data-rollup-transform.html" title="Roll up or transform your data"/>
<link rel="prev" href="xpack-rollup.html" title="Rolling up historical data"/>
<link rel="next" href="high-availability.html" title="Set up a cluster for high availability"/>
<meta class="elastic" name="product_version" content=""/>
<meta class="elastic" name="product_name" content=""/>
<meta class="elastic" name="website_area" content="documentation"/>
<meta name="DC.type" content="Learn/Docs/"/>
<meta name="DC.subject" content=""/>
<meta name="DC.identifier" content=""/>
</head>
<body>
<div id="content">
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="/guide/">Elastic Docs</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="index.html">Elasticsearch Guide</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="data-rollup-transform.html">Roll up or transform your data</a></span>
</div>
<div class="navheader">
<span class="prev">
<a href="xpack-rollup.html">« Rolling up historical data</a>
</span>
<span class="next">
<a href="high-availability.html">Set up a cluster for high availability »</a>
</span>
</div>
<div class="chapter xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="transforms"></a>Transforming data<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/transforms.asciidoc">edit</a></h2>
</div></div></div>
<p>Transforms enable you to convert existing Elasticsearch indices into summarized
indices, which provide opportunities for new insights and analytics.
For example, you can use transforms to pivot your data into entity-centric
indices that summarize the behavior of users or sessions or other entities in
your data. Or you can use transforms to find the latest document among all the
documents that have a certain unique key.</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<a class="xref" href="transforms.html#transform-overview" title="Transform overview">Overview</a>
</li>
<li class="listitem">
<a class="xref" href="transforms.html#transform-setup" title="Set up transforms">Setup</a>
</li>
<li class="listitem">
<a class="xref" href="transforms.html#transform-usage" title="When to use transforms">When to use transforms</a>
</li>
<li class="listitem">
<a class="xref" href="transforms.html#transform-alerts" title="Generating alerts for transforms">Generating alerts for transforms</a>
</li>
<li class="listitem">
<a class="xref" href="transforms.html#transform-scale" title="Working with transforms at scale">Transforms at scale</a>
</li>
<li class="listitem">
<a class="xref" href="transforms.html#transform-checkpoints" title="How transform checkpoints work">How checkpoints work</a>
</li>
<li class="listitem">
<a class="xref" href="transforms.html#transform-api-quickref" title="API quick reference">API quick reference</a>
</li>
<li class="listitem">
<a class="xref" href="transforms.html#ecommerce-transforms" title="Tutorial: Transforming the eCommerce sample data">Tutorial: Transforming the eCommerce sample data</a>
</li>
<li class="listitem">
<a class="xref" href="transforms.html#transform-examples" title="Transform examples">Examples</a>
</li>
<li class="listitem">
<a class="xref" href="transforms.html#transform-painless-examples" title="Painless examples for transforms">Painless examples</a>
</li>
<li class="listitem">
<a class="xref" href="transform-troubleshooting.html" title="Troubleshooting transforms"><em>Troubleshooting transforms</em></a>
</li>
<li class="listitem">
<a class="xref" href="transforms.html#transform-limitations" title="Transform limitations">Limitations</a>
</li>
</ul>
</div>
<div class="section xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="transform-overview"></a>Transform overview<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/overview.asciidoc">edit</a></h2>
</div></div></div>

<p>You can choose either of the following methods to transform your data:
<a class="xref" href="transforms.html#pivot-transform-overview" title="Pivot transforms">pivot</a> or <a class="xref" href="transforms.html#latest-transform-overview" title="Latest transforms">latest</a>.</p>
<div class="important admon">
<div class="icon"></div>
<div class="admon_content">
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
All transforms leave your source index intact. They create a new
index that is dedicated to the transformed data.
</li>
<li class="listitem">
Transforms might have more configuration options provided by the APIs
than the options available in Kibana. For all the transform configuration
options, refer to the <a class="xref" href="transform-apis.html" title="Transform APIs">API documentation</a>.
</li>
</ul>
</div>
</div>
</div>
<p>Transforms are persistent tasks; they are stored in cluster state which
makes them resilient for node failures. Refer to <a class="xref" href="transforms.html#transform-checkpoints" title="How transform checkpoints work">How checkpoints work</a> and
<a class="xref" href="transforms.html#ml-transform-checkpoint-errors" title="Error handling">Error handling</a> to learn more about the machinery behind
transforms.</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="pivot-transform-overview"></a>Pivot transforms<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/overview.asciidoc">edit</a></h3>
</div></div></div>
<p>You can use transforms to <em>pivot</em> your data into a new entity-centric index.
By transforming and summarizing your data, it becomes possible to visualize and
analyze it in alternative and interesting ways.</p>
<p>A lot of Elasticsearch indices are organized as a stream of events: each event is an
individual document, for example a single item purchase. Transforms enable
you to summarize this data, bringing it into an organized, more
analysis-friendly format. For example, you can summarize all the purchases of a
single customer.</p>
<p>Transforms enable you to define a pivot, which is a set of
features that transform the index into a different, more digestible format.
Pivoting results in a summary of your data in a new index.</p>
<p>To define a pivot, first you select one or more fields that you will use to
group your data. You can select categorical fields (terms) and numerical fields
for grouping. If you use numerical fields, the field values are bucketed using
an interval that you specify.</p>
<p>The second step is deciding how you want to aggregate the grouped data. When
using aggregations, you practically ask questions about the index. There are
different types of aggregations, each with its own purpose and output. To learn
more about the supported aggregations and group-by fields, see
<a class="xref" href="transform-apis.html#put-transform" title="Create transform API">Create transform</a>.</p>
<p>As an optional step, you can also add a query to further limit the scope of the
aggregation.</p>
<p>The transform performs a composite aggregation that paginates through all the
data defined by the source index query. The output of the aggregation is stored
in a <em>destination index</em>. Each time the transform queries the source index, it
creates a <em>checkpoint</em>. You can decide whether you want the transform to run
once or continuously. A <em>batch transform</em> is a single operation that has a
single checkpoint. <em>Continuous transforms</em> continually increment and process
checkpoints as new source data is ingested.</p>
<p>Imagine that you run a webshop that sells clothes. Every order creates a
document that contains a unique order ID, the name and the category of the
ordered product, its price, the ordered quantity, the exact date of the order,
and some customer information (name, gender, location, etc). Your data set
contains all the transactions from last year.</p>
<p>If you want to check the sales in the different categories in your last fiscal
year, define a transform that groups the data by the product categories
(women&#8217;s shoes, men&#8217;s clothing, etc.) and the order date. Use the last year as
the interval for the order date. Then add a sum aggregation on the ordered
quantity. The result is an entity-centric index that shows the number of sold
items in every product category in the last year.</p>
<div class="imageblock screenshot">
<div class="content">
<img src="images/pivot-preview.png" alt="Example of a pivot transform preview in Kibana">
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="latest-transform-overview"></a>Latest transforms<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/overview.asciidoc">edit</a></h3>
</div></div></div>
<p>You can use the <code class="literal">latest</code> type of transform to copy the most recent documents
into a new index. You must identify one or more fields as the unique key for
grouping your data, as well as a date field that sorts the data chronologically.
For example, you can use this type of transform to keep track of the latest
purchase for each customer or the latest event for each host.</p>
<div class="imageblock screenshot">
<div class="content">
<img src="images/latest-preview.png" alt="Example of a latest transform preview in Kibana">
</div>
</div>
<p>As in the case of a pivot, a latest transform can run once or continuously. It
performs a composite aggregation on the data in the source index and stores the
output in the destination index. If the transform runs continuously, new unique
key values are automatically added to the destination index and the most recent
documents for existing key values are automatically updated at each checkpoint.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="transform-performance"></a>Performance considerations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/overview.asciidoc">edit</a></h3>
</div></div></div>
<p>Transforms perform search aggregations on the source indices then index
the results into the destination index. Therefore, a transform never takes
less time or uses less resources than the aggregation and indexing processes.</p>
<p>If your transform must process a lot of historic data, it has high resource
usage initially&#8212;&#8203;particularly during the first checkpoint.</p>
<p>For better performance, make sure that your search aggregations and queries are
optimized and that your transform is processing only necessary data. Consider
whether you can apply a source query to the transform to reduce the scope of
data it processes. Also consider whether the cluster has sufficient resources in
place to support both the composite aggregation search and the indexing of its
results.</p>
<p>If you prefer to spread out the impact on your cluster (at the cost of a slower
transform), you can throttle the rate at which it performs search and index
requests. Set the <code class="literal">docs_per_second</code> limit when you <a class="xref" href="transform-apis.html#put-transform" title="Create transform API">create</a> or
<a class="xref" href="transform-apis.html#update-transform" title="Update transform API">update</a> your transform. If you want to calculate the
current rate, use the following information from the
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.9/get-transform-stats.html" class="ulink" target="_top">get transform stats API</a>:</p>
<pre class="screen">documents_processed / search_time_in_ms * 1000</pre>
</div>

</div>

<div class="section xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="transform-setup"></a>Set up transforms<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/setup.asciidoc">edit</a></h2>
</div></div></div>

<h4><a id="requirements-overview"></a>Requirements overview<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/setup.asciidoc">edit</a></h4>
<p>To use transforms, you must have:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
at least one <a class="xref" href="settings.html#transform-node" title="Transform node">transform node</a>,
</li>
<li class="listitem">
management features visible in the Kibana space, and
</li>
<li class="listitem">
<p>security privileges that:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
grant use of transforms, and
</li>
<li class="listitem">
grant access to source and destination indices
</li>
</ul>
</div>
</li>
</ul>
</div>
<h4><a id="transform-privileges"></a>Security privileges<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/setup.asciidoc">edit</a></h4>
<p>Assigning security privileges affects how users access transforms. Consider
the two main categories:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<span class="strong strong"><strong><a class="xref" href="transforms.html#transform-es-security-privileges" title="Elasticsearch API user">Elasticsearch API user</a></strong></span>: uses an Elasticsearch client, cURL, or Kibana
<span class="strong strong"><strong>Dev Tools</strong></span> to access transforms via Elasticsearch APIs. This scenario requires
Elasticsearch security privileges.
</li>
<li class="listitem">
<span class="strong strong"><strong><a class="xref" href="transforms.html#transform-kib-security-privileges" title="Kibana user">Kibana user</a></strong></span>: uses transforms in Kibana. This
scenario requires Kibana feature privileges <em>and</em> Elasticsearch security privileges.
</li>
</ul>
</div>
<h5><a id="transform-es-security-privileges"></a>Elasticsearch API user<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/setup.asciidoc">edit</a></h5>
<p>To <em>manage</em> transforms, you must meet all of the following requirements:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<code class="literal">transform_admin</code> built-in role or <code class="literal">manage_transform</code> cluster privileges,
</li>
<li class="listitem">
<code class="literal">read</code> and <code class="literal">view_index_metadata</code> index privileges on source indices, and
</li>
<li class="listitem">
<code class="literal">create_index</code>, <code class="literal">index</code>, <code class="literal">manage</code>, and <code class="literal">read</code> index privileges on destination
indices. If a <code class="literal">retention_policy</code> is configured, <code class="literal">delete</code> index privilege is
also required on the destination index.
</li>
</ul>
</div>
<p>To view only the configuration and status of transforms, you must have:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<code class="literal">transform_user</code> built-in role or <code class="literal">monitor_transform</code> cluster privileges
</li>
</ul>
</div>
<p>For more information about Elasticsearch roles and privileges, refer to
<a class="xref" href="authorization.html#built-in-roles" title="Built-in roles">Built-in roles</a> and <a class="xref" href="authorization.html#security-privileges" title="Security privileges">Security privileges</a>.</p>
<h5><a id="transform-kib-security-privileges"></a>Kibana user<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/setup.asciidoc">edit</a></h5>
<p>Within a Kibana space, for full access to transforms, you must meet all of the
following requirements:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Management features visible in the Kibana space, including
<code class="literal">Data View Management</code> and <code class="literal">Stack Monitoring</code>,
</li>
<li class="listitem">
<code class="literal">monitoring_user</code> built-in role,
</li>
<li class="listitem">
<code class="literal">transform_admin</code> built-in role or <code class="literal">manage_transform</code> cluster privileges,
</li>
<li class="listitem">
<code class="literal">kibana_admin</code> built-in role or a custom role with <code class="literal">read</code> or <code class="literal">all</code> Kibana
privileges for the <code class="literal">Data View Management</code> feature (dependent on whether data
views already exist for your destination indices),
</li>
<li class="listitem">
data views for your source indices,
</li>
<li class="listitem">
<code class="literal">read</code> and <code class="literal">view_index_metadata</code> index privileges on source indices, and
</li>
<li class="listitem">
<code class="literal">create_index</code>, <code class="literal">index</code>, <code class="literal">manage</code>, and <code class="literal">read</code> index privileges on destination
indices. Additionally, when using a <code class="literal">retention_policy</code>, <code class="literal">delete</code> index privilege is required
on destination indices.
</li>
<li class="listitem">
<code class="literal">read_pipeline</code> cluster privileges, if the transform uses an ingest pipeline
</li>
</ul>
</div>
<p>Within a Kibana space, for read-only access to transforms, you must meet all of
the following requirements:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Management features visible in the Kibana space, including <code class="literal">Stack Monitoring</code>,
</li>
<li class="listitem">
<code class="literal">monitoring_user</code> built-in role,
</li>
<li class="listitem">
<code class="literal">transform_user</code> built-in role or <code class="literal">monitor_transform</code> cluster privileges,
</li>
<li class="listitem">
<code class="literal">kibana_admin</code> built-in role or a custom role with <code class="literal">read</code> Kibana privileges
for at least one feature in the space,
</li>
<li class="listitem">
data views for your source and destination indices, and
</li>
<li class="listitem">
<code class="literal">read</code>, and <code class="literal">view_index_metadata</code> index privileges on source indices and
destination indices
</li>
</ul>
</div>
<p>For more information and Kibana security features, see
<a href="https://www.elastic.co/guide/en/kibana/8.9/kibana-role-management.html" class="ulink" target="_top">Kibana role management</a> and
<a href="https://www.elastic.co/guide/en/kibana/8.9/kibana-privileges.html" class="ulink" target="_top">Kibana privileges</a>.</p>
<h4><a id="transform-kib-spaces"></a>Kibana spaces<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/setup.asciidoc">edit</a></h4>
<p><a href="https://www.elastic.co/guide/en/kibana/8.9/xpack-spaces.html" class="ulink" target="_top">Spaces</a> enable you to organize your source and
destination indices and other saved objects in Kibana and to see only the objects
that belong to your space. However, a transform is a long running task which
is managed on cluster level and therefore not limited in scope to certain
spaces. Space awareness can be implemented for a data view under
<span class="strong strong"><strong>Stack Management &gt; Kibana</strong></span> which allows privileges to the transform
destination index.</p>
<p>To successfully create transforms in Kibana, you must be logged into a space
where the source indices are visible and the <code class="literal">Data View Management</code> and
<code class="literal">Stack Monitoring</code> features are visible.</p>
</div>

<div class="section xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="transform-usage"></a>When to use transforms<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/usage.asciidoc">edit</a></h2>
</div></div></div>
<p>Elasticsearch aggregations are a powerful and flexible feature that enable you to
summarize and retrieve complex insights about your data. You can summarize
complex things like the number of web requests per day on a busy website, broken
down by geography and browser type. If you use the same data set to try to
calculate something as simple as a single number for the average duration of
visitor web sessions, however, you can quickly run out of memory.</p>
<p>Why does this occur? A web session duration is an example of a behavioral
attribute not held on any one log record; it has to be derived by finding the
first and last records for each session in our weblogs. This derivation requires
some complex query expressions and a lot of memory to connect all the data
points. If you have an ongoing background process that fuses related events from
one index into entity-centric summaries in another index, you get a more useful,
joined-up picture. This new index is sometimes referred to as a <em>data frame</em>.</p>
<p>You might want to consider using transforms instead of aggregations when:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<p>You need a complete <em>feature index</em> rather than a top-N set of items.</p>
<p>In machine learning, you often need a complete set of behavioral features rather just the
top-N. For example, if you are predicting customer churn, you might look at
features such as the number of website visits in the last week, the total number
of sales, or the number of emails sent. The Elastic Stack machine learning features create models
based on this multi-dimensional feature space, so they benefit from the full
feature indices that are created by transforms.</p>
<p>This scenario also applies when you are trying to search across the results of
an aggregation or multiple aggregations. Aggregation results can be ordered or
filtered, but there are
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.9/search-aggregations-bucket-terms-aggregation.html#search-aggregations-bucket-terms-aggregation-order" class="ulink" target="_top">limitations to ordering</a>
and
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.9/search-aggregations-pipeline-bucket-selector-aggregation.html" class="ulink" target="_top">filtering by bucket selector</a>
is constrained by the maximum number of buckets returned. If you want to search
all aggregation results, you need to create the complete data frame. If you
need to sort or filter the aggregation results by multiple fields, transforms
are particularly useful.</p>
</li>
<li class="listitem">
<p>You need to sort aggregation results by a pipeline aggregation.</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.9/search-aggregations-pipeline.html" class="ulink" target="_top">Pipeline aggregations</a> cannot be used
for sorting. Technically, this is because pipeline aggregations are run during
the reduce phase after all other aggregations have already completed. If you
create a transform, you can effectively perform multiple passes over the data.</p>
</li>
<li class="listitem">
<p>You want to create summary tables to optimize queries.</p>
<p>For example, if you
have a high level dashboard that is accessed by a large number of users and it
uses a complex aggregation over a large dataset, it may be more efficient to
create a transform to cache results. Thus, each user doesn&#8217;t need to run the
aggregation query.</p>
</li>
</ul>
</div>
</div>

<div class="section xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="transform-alerts"></a>Generating alerts for transforms<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/transform-alerts.asciidoc">edit</a></h2>
</div></div></div>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>This functionality is in beta and is subject to change. The design and code is less mature than official GA features and is being provided as-is with no warranties. Beta features are not subject to the support SLA of official GA features.</p>
</div>
</div>
<p>Kibana alerting features include support for transform rules, which check the
health of continuous transforms with certain conditions. If the conditions of the rule
are met, an alert is created and the associated action is triggered. For
example, you can create a rule to check if a continuous transform is started and to
notify you in an email if it is not. To learn more about Kibana alerting features,
refer to
<a href="https://www.elastic.co/guide/en/kibana/8.9/alerting-getting-started.html#alerting-getting-started" class="ulink" target="_top">Alerting</a>.</p>
<p>The following transform rules are available:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
Transform health
</span>
</dt>
<dd>
Monitors transforms health and alerts if an operational issue occurred.
</dd>
</dl>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="creating-transform-rules"></a>Creating a rule<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/transform-alerts.asciidoc">edit</a></h3>
</div></div></div>
<p>You can create transform rules under <span class="strong strong"><strong>Stack Management &gt; Rules</strong></span>.</p>
<p>On the <span class="strong strong"><strong>Create rule</strong></span> window, give a name to the rule and optionally provide
tags. Select the transform health rule type:</p>
<div class="imageblock screenshot">
<div class="content">
<img src="images/transform-rule.png" alt="Creating a transform health rule" width="500">
</div>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="creating-transform-health-rules"></a>Transform health<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/transform-alerts.asciidoc">edit</a></h4>
</div></div></div>
<p>Select the transform or transforms to include. You can also use a special
character (<code class="literal">*</code>) to apply the rule to all your transforms. Transforms
created after the rule are automatically included.</p>
<p>The following health check is available and enabled by default:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<em>Transform is not started</em>
</span>
</dt>
<dd>
Notifies if the corresponding transforms is not started or it does not index
any data. The notification message recommends the necessary actions to solve
the error.
</dd>
<dt>
<span class="term">
<em>Errors in transform messages</em>
</span>
</dt>
<dd>
Notifies if transform messages contain errors.
</dd>
</dl>
</div>
<div class="imageblock screenshot">
<div class="content">
<img src="images/transform-check-config.png" alt="Selecting health check" width="500">
</div>
</div>
<p>As the last step in the rule creation process, define its actions.</p>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="defining-actions"></a>Defining actions<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/transform-alerts.asciidoc">edit</a></h3>
</div></div></div>
<p>You can add one or more actions to your rule to generate notifications when its
conditions are met and when they are no longer met.</p>
<p>Each action uses a connector, which stores connection information for a Kibana
service or supported third-party integration, depending on where you want to
send the notifications. For example, you can use a Slack connector to send a
message to a channel. Or you can use an index connector that writes an JSON
object to a specific index. For details about creating connectors, refer to
<a href="https://www.elastic.co/guide/en/kibana/8.9/action-types.html" class="ulink" target="_top">Connectors</a>.</p>
<p>You must set the action frequency, which involves choosing how often to run
the action (for example, at each check interval, only when the alert status
changes, or at a custom action interval). Each rule type also has a list of
valid action groups and you must choose one of these groups (for example, the
action runs when the issue is detected or when it is recovered).</p>
<div class="tip admon">
<div class="icon"></div>
<div class="admon_content">
<p>If you choose a custom action interval, it cannot be shorter than the
rule&#8217;s check interval.</p>
</div>
</div>
<p>It&#8217;s also possible to customize the notification messages for each action. A
list of variables is available to include in the message, like transform ID,
description, transform state, and so on.</p>
<div class="imageblock screenshot">
<div class="content">
<img src="images/transform-alert-actions.png" alt="Selecting connector type" width="500">
</div>
</div>
<p>After you save the configurations, the rule appears in the <span class="strong strong"><strong>Rules</strong></span> list
where you can check its status and see the overview of its configuration
information.</p>
<p>The name of an alert is always the same as the transform ID of the associated
transform that triggered it. You can mute the notifications for a particular
transform on the page of the rule that lists the individual alerts. You can
open it via <span class="strong strong"><strong>Rules</strong></span> by selecting the rule name.</p>
</div>

</div>

<div class="section xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="transform-scale"></a>Working with transforms at scale<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/transforms-at-scale.asciidoc">edit</a></h2>
</div></div></div>

<p>Transforms convert existing Elasticsearch indices into summarized indices, which
provide opportunities for new insights and analytics. The search and index
operations performed by transforms use standard Elasticsearch features so similar
considerations for working with Elasticsearch at scale are often applicable to
transforms. If you experience performance issues, start by identifying the
bottleneck areas (search, indexing, processing, or storage) then review the
relevant considerations in this guide to improve performance. It also helps to
understand how transforms work as different considerations apply depending on
whether or not your transform is running in continuous mode or in batch.</p>
<p>In this guide, you’ll learn how to:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Understand the impact of configuration options on the performance of
transforms.
</li>
</ul>
</div>
<p><span class="strong strong"><strong>Prerequisites:</strong></span></p>
<p>These guildelines assume you have a transform you want to tune, and you’re
already familiar with:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<a class="xref" href="transforms.html#transform-overview" title="Transform overview">How transforms work</a>.
</li>
<li class="listitem">
<a class="xref" href="transforms.html#transform-setup" title="Set up transforms">How to set up transforms</a>.
</li>
<li class="listitem">
<a class="xref" href="transforms.html#transform-checkpoints" title="How transform checkpoints work">How transform checkpoints work in continuous mode</a>.
</li>
</ul>
</div>
<p>The following considerations are not sequential – the numbers help to navigate
between the list items; you can take action on one or more of them in any order.
Most of the recommendations apply to both continuous and batch transforms. If
a list item only applies to one transform type, this exception is highlighted
in the description.</p>
<p>The keywords in parenthesis at the end of each recommendation title indicates
the bottleneck area that may be improved by following the given recommendation.</p>
<h4><a id="measure-performance"></a>Measure transforms performance<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/transforms-at-scale.asciidoc">edit</a></h4>
<p>In order to optimize transform performance, start by identifying the areas
where most work is being done. The <span class="strong strong"><strong>Stats</strong></span> interface of the
<span class="strong strong"><strong>Transforms</strong></span> page in Kibana contains information that covers three main
areas: indexing, searching, and processing time (alternatively, you can use the
<a class="xref" href="transform-apis.html#get-transform-stats" title="Get transform statistics API">transforms stats API</a>). If, for example, the results
show that the highest proportion of time is spent on search, then prioritize
efforts on optimizing the search query of the transform. Transforms also
has <a href="https://esrally.readthedocs.io" class="ulink" target="_top">Rally support</a> that makes it possible to run
performance checks on transforms configurations if it is required. If you
optimized the crucial factors and you still experience performance issues, you
may also want to consider improving your hardware.</p>
<h4><a id="frequency"></a>1. Optimize <code class="literal">frequency</code> (index)<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/transforms-at-scale.asciidoc">edit</a></h4>
<p>In a continuous transform, the <code class="literal">frequency</code> configuration option sets the interval
between checks for changes in the source indices. If changes are detected, then
the source data is searched and the changes are applied to the destination
index. Depending on your use case, you may wish to reduce the frequency at which
changes are applied. By setting <code class="literal">frequency</code> to a higher value (maximum is one
hour), the workload can be spread over time at the cost of less up-to-date data.</p>
<h4><a id="increase-shards-dest-index"></a>2. Increase the number of shards of the destination index (index)<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/transforms-at-scale.asciidoc">edit</a></h4>
<p>Depending on the size of the destination index, you may consider increasing its
shard count. Transforms use one shard by default when creating the
destination index. To override the index settings, create the destination index
before starting the transform. For more information about how the number of
shards affects scalability and resilience, refer to <a class="xref" href="elasticsearch-intro.html#scalability" title="Scalability and resilience: clusters, nodes, and shards">Scalability and resilience</a></p>
<div class="tip admon">
<div class="icon"></div>
<div class="admon_content">
<p>Use the <a class="xref" href="transform-apis.html#preview-transform" title="Preview transform API">Preview transform</a> to check the settings that the transform
would use to create the destination index. You can copy and adjust these in
order to create the destination index prior to starting the transform.</p>
</div>
</div>
<h4><a id="search-queries"></a>3. Profile and optimize your search queries (search)<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/transforms-at-scale.asciidoc">edit</a></h4>
<p>If you have defined a transform source index <code class="literal">query</code>, ensure it is as
efficient as possible. Use the <span class="strong strong"><strong>Search Profiler</strong></span> under <span class="strong strong"><strong>Dev Tools</strong></span> in Kibana
to get detailed timing information about the execution of individual components
in the search request. Alternatively, you can use the <a class="xref" href="search.html#search-profile" title="Profile API">Profile</a>. The
results give you insight into how search requests are executed at a low level so
that you can understand why certain requests are slow, and take steps to improve
them.</p>
<p>Transforms execute standard Elasticsearch search requests. There are different ways
to write Elasticsearch queries, and some of them are more efficient than others. Consult
<a class="xref" href="tune-for-search-speed.html" title="Tune for search speed"><em>Tune for search speed</em></a> to learn more about Elasticsearch performance tuning.</p>
<h4><a id="limit-source-query"></a>4. Limit the scope of the source query (search)<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/transforms-at-scale.asciidoc">edit</a></h4>
<p>Imagine your continuous transform is configured to group by <code class="literal">IP</code> and calculate the sum
of <code class="literal">bytes_sent</code>. For each checkpoint, a continuous transform detects changes in the
source data since the previous checkpoint, identifying the IPs for which new
data has been ingested. Then it performs a second search, filtered for this
group of IPs, in order to calculate the total <code class="literal">bytes_sent</code>. If this second
search matches many shards, then this could be resource intensive. Consider
limiting the scope that the source index pattern and query will match.</p>
<p>Use an absolute time value as a date range filter in your source query (for
example, greater than <code class="literal">2020-01-01T00:00:00</code>) to limit which historical indices
are accessed. If you use a relative time value (for example, <code class="literal">now-30d</code>) then
this date range is re-evaluated at the point of each checkpoint execution.</p>
<p>Consider using <a class="xref" href="api-conventions.html#api-date-math-index-names" title="Date math support in index and index alias names">date math</a> in your index names to
reduce the number of indices to resolve in your queries. Add a date pattern
- for example, <code class="literal">yyyy-MM-dd</code> - to your index names and use it to limit your query
to a specific date. The example below queries indices only from yesterday and
today:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">  "source": {
    "index": [
        "&lt;mydata-{now/d-1d{yyyy-MM-dd}}*&gt;",
        "&lt;mydata-{now/d{yyyy-MM-dd}}*&gt;"
    ]
  },</pre>
</div>
<h4><a id="optimize-shading-strategy"></a>5. Optimize the sharding strategy for the source index (search)<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/transforms-at-scale.asciidoc">edit</a></h4>
<p>There is no one-size-fits-all sharding strategy. A strategy that works in one
environment may not scale in another. A good sharding strategy must account for
your infrastructure, use case, and performance expectations.</p>
<p>Too few shards may mean that the benefits of distributing the workload cannot be
realised; however too many shards may impact your cluster health. To learn more
about sizing your shards, read this <a class="xref" href="size-your-shards.html" title="Size your shards">guide</a>.</p>
<h4><a id="tune-max-page-search-size"></a>6. Tune <code class="literal">max_page_search_size</code> (search)<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/transforms-at-scale.asciidoc">edit</a></h4>
<p>The <code class="literal">max_page_search_size</code> transform configuration option defines the number
of buckets that are returned for each search request. The default value is 500.
If you increase this value, you get better throughput at the cost of higher
latency and memory usage.</p>
<p>The ideal value of this parameter is highly dependent on your use case. If your
transform executes memory-intensive aggregations – for example, cardinality or
percentiles – then increasing <code class="literal">max_page_search_size</code> requires more available
memory. If memory limits are exceeded, a circuit breaker exception occurs.</p>
<h4><a id="indexed-fields-in-source"></a>7. Use indexed fields in your source indices (search)<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/transforms-at-scale.asciidoc">edit</a></h4>
<p>Runtime fields and scripted fields are not indexed fields; their values are only
extracted or computed at search time. While these fields provide flexibility in
how you access your data, they increase performance costs at search time. If
transform performance using runtime fields or scripted fields is a concern,
you may wish to consider using indexed fields instead. For performance reasons,
we do not recommend using a runtime field as the time field that synchronizes a
continuous transform.</p>
<h4><a id="index-sorting-group-by-ordering"></a>8. Use index sorting (search, process)<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/transforms-at-scale.asciidoc">edit</a></h4>
<p>Index sorting enables you to store documents on disk in a specific order which
can improve query efficiency. The ideal sorting logic depends on your use case,
but the rule of thumb may be to sort the fields in descending order (high to low
cardinality) starting with the time-based fields. Index sorting
can be defined only once at index creation. If you don&#8217;t already have index
sorting on the index that you want to use as a source, consider reindexing it to
a new, sorted index.</p>
<h4><a id="disable-source-dest"></a>9. Disable the <code class="literal">_source</code> field on the destination index (storage)<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/transforms-at-scale.asciidoc">edit</a></h4>
<p>The <a class="xref" href="mapping-fields.html#mapping-source-field" title="_source field"><code class="literal">_source</code> field</a> contains the original JSON document body that was
passed at index time. The <code class="literal">_source</code> field itself is not indexed (and thus is not
searchable), but it is still stored in the index and incurs a storage overhead.
Consider disabling <code class="literal">_source</code> to save storage space if you have a large
destination index. Disabling <code class="literal">_source</code> is only possible during index creation.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>When the <code class="literal">_source</code> field is disabled, a number of features are not
supported. Consult <a class="xref" href="mapping-fields.html#disable-source-field" title="Disabling the _source field">Disabling the <code class="literal">_source</code> field</a> to understand the consequences
before disabling it.</p>
</div>
</div>
<h4><a id="_further_reading"></a>Further reading<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/transforms-at-scale.asciidoc">edit</a></h4>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<a class="xref" href="tune-for-search-speed.html" title="Tune for search speed"><em>Tune for search speed</em></a>
</li>
<li class="listitem">
<a class="xref" href="tune-for-indexing-speed.html" title="Tune for indexing speed"><em>Tune for indexing speed</em></a>
</li>
<li class="listitem">
<a class="xref" href="size-your-shards.html" title="Size your shards"><em>Size your shards</em></a>
</li>
<li class="listitem">
<a class="xref" href="ilm-concepts.html#ilm-index-lifecycle" title="Index lifecycle">Index lifecycle</a>
</li>
</ul>
</div>
</div>

<div class="section xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="transform-checkpoints"></a>How transform checkpoints work<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/checkpoints.asciidoc">edit</a></h2>
</div></div></div>

<p>Each time a transform examines the source indices and creates or updates the
destination index, it generates a <em>checkpoint</em>.</p>
<p>If your transform runs only once, there is logically only one checkpoint. If
your transform runs continuously, however, it creates checkpoints as it
ingests and transforms new source data. The <code class="literal">sync</code> property of the transform
configures checkpointing by specifying a time field.</p>
<p>To create a checkpoint, the continuous transform:</p>
<div class="olist orderedlist">
<ol class="orderedlist">
<li class="listitem">
<p>Checks for changes to source indices.</p>
<p>Using a simple periodic timer, the transform checks for changes to the source
indices. This check is done based on the interval defined in the transform&#8217;s
<code class="literal">frequency</code> property.</p>
<p>If the source indices remain unchanged or if a checkpoint is already in progress
then it waits for the next timer.</p>
<p>If changes are found a checkpoint is created.</p>
</li>
<li class="listitem">
<p>Identifies which entities and/or time buckets have changed.</p>
<p>The transform searches to see which entities or time buckets have changed
between the last and the new checkpoint. The transform uses the values to
synchronize the source and destination indices with fewer operations than a
full re-run.</p>
</li>
<li class="listitem">
<p>Updates the destination index (the data frame) with the changes.</p>
<p>The transform applies changes related to either new or changed entities or
time buckets to the destination index. The set of changes can be paginated. The
transform performs a composite aggregation similarly to the batch transform
operation, however it also injects query filters based on the previous step to
reduce the amount of work. After all changes have been applied, the checkpoint
is complete.</p>
</li>
</ol>
</div>
<p>This checkpoint process involves both search and indexing activity on the
cluster. We have attempted to favor control over performance while developing
transforms. We decided it was preferable for the transform to take longer to
complete, rather than to finish quickly and take precedence in resource
consumption. That being said, the cluster still requires enough resources to
support both the composite aggregation search and the indexing of its results.</p>
<div class="tip admon">
<div class="icon"></div>
<div class="admon_content">
<p>If the cluster experiences unsuitable performance degradation due to the
transform, stop the transform and refer to <a class="xref" href="transforms.html#transform-performance" title="Performance considerations">Performance considerations</a>.</p>
</div>
</div>
<h4><a id="sync-field-ingest-timestamp"></a>Using the ingest timestamp for syncing the transform<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/checkpoints.asciidoc">edit</a></h4>
<p>In most cases, it is strongly recommended to use the ingest timestamp of the
source indices for syncing the transform. This is the most optimal way for
transforms to be able to identify new changes. If your data source follows the
<a href="https://www.elastic.co/guide/en/ecs/8.9/ecs-reference.html" class="ulink" target="_top">ECS standard</a>, you might already have an
<a href="https://www.elastic.co/guide/en/ecs/8.9/ecs-event.html#field-event-ingested" class="ulink" target="_top"><code class="literal">event.ingested</code></a> field. In this
case, use <code class="literal">event.ingested</code> as the <code class="literal">sync</code>.<code class="literal">time</code>.<code class="literal">field</code> property of your
transform.</p>
<p>If you don&#8217;t have a <code class="literal">event.ingested</code> field or it isn&#8217;t populated, you can set it
by using an ingest pipeline. Create an ingest pipeline either using the
<a class="xref" href="ingest-apis.html#put-pipeline-api" title="Create or update pipeline API">ingest pipeline API</a> (like the example below) or via Kibana
under <span class="strong strong"><strong>Stack Management &gt; Ingest Pipelines</strong></span>. Use a
<a class="xref" href="processors.html#set-processor" title="Set processor"><code class="literal">set</code> processor</a> to set the field and associate it with the
value of the ingest timestamp.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT _ingest/pipeline/set_ingest_time
{
  "description": "Set ingest timestamp.",
  "processors": [
    {
      "set": {
        "field": "event.ingested",
        "value": "{{{_ingest.timestamp}}}"
      }
    }
  ]
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1672.console"></div>
<p>After you created the ingest pipeline, apply it to the source indices of your
transform. The pipeline adds the field <code class="literal">event.ingested</code> to every document with
the value of the ingest timestamp. Configure the <code class="literal">sync</code>.<code class="literal">time</code>.<code class="literal">field</code> property
of your transform to use the field by using the
<a class="xref" href="transform-apis.html#put-transform" title="Create transform API">create transform API</a> for new transforms or the
<a class="xref" href="transform-apis.html#update-transform" title="Update transform API">update transform API</a> for existing transforms. The
<code class="literal">event.ingested</code> field is used for syncing the transform.</p>
<p>Refer to <a class="xref" href="ingest.html#add-pipeline-to-indexing-request" title="Add a pipeline to an indexing request">Add a pipeline to an indexing request</a> and <a class="xref" href="ingest.html" title="Ingest pipelines">Ingest pipelines</a> to learn more about
how to use an ingest pipeline.</p>
<h4><a id="ml-transform-checkpoint-heuristics"></a>Change detection heuristics<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/checkpoints.asciidoc">edit</a></h4>
<p>When the transform runs in continuous mode, it updates the documents in the
destination index as new data comes in. The transform uses a set of heuristics
called change detection to update the destination index with fewer operations.</p>
<p>In this example, the data is grouped by host names. Change detection detects
which host names have changed,  for example, host <code class="literal">A</code>, <code class="literal">C</code> and <code class="literal">G</code> and only
updates documents with those hosts but does not update documents that store
information about host <code class="literal">B</code>, <code class="literal">D</code>, or any other host that are not changed.</p>
<p>Another heuristic can be applied for time buckets when a <code class="literal">date_histogram</code> is
used to group by time buckets. Change detection detects which time buckets have
changed and only update those.</p>
<h4><a id="ml-transform-checkpoint-errors"></a>Error handling<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/checkpoints.asciidoc">edit</a></h4>
<p>Failures in transforms tend to be related to searching or indexing.
To increase the resiliency of transforms, the cursor positions of
the aggregated search and the changed entities search are tracked in memory and
persisted periodically.</p>
<p>Checkpoint failures can be categorized as follows:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Temporary failures: The checkpoint is retried. If 10 consecutive failures
occur, the transform has a failed status. For example, this situation might
occur when there are shard failures and queries return only partial results.
</li>
<li class="listitem">
Irrecoverable failures: The transform immediately fails. For example, this
situation occurs when the source index is not found.
</li>
<li class="listitem">
Adjustment failures: The transform retries with adjusted settings. For
example, if a parent circuit breaker memory errors occur during the composite
aggregation, the transform receives partial results. The aggregated search is
retried with a smaller number of buckets. This retry is performed at the
interval defined in the <code class="literal">frequency</code> property for the transform. If the search
is retried to the point where it reaches a minimal number of buckets, an
irrecoverable failure occurs.
</li>
</ul>
</div>
<p>If the node running the transforms fails, the transform restarts from the
most recent persisted cursor position. This recovery process might repeat some
of the work the transform had already done, but it ensures data consistency.</p>
</div>

<div class="section xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="transform-api-quickref"></a>API quick reference<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/api-quickref.asciidoc">edit</a></h2>
</div></div></div>
<p>All transform endpoints have the following base:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">_transform/</pre>
</div>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<a class="xref" href="transform-apis.html#put-transform" title="Create transform API">Create transforms</a>
</li>
<li class="listitem">
<a class="xref" href="transform-apis.html#delete-transform" title="Delete transform API">Delete transforms</a>
</li>
<li class="listitem">
<a class="xref" href="transform-apis.html#get-transform" title="Get transforms API">Get transforms</a>
</li>
<li class="listitem">
<a class="xref" href="transform-apis.html#get-transform-stats" title="Get transform statistics API">Get transforms statistics</a>
</li>
<li class="listitem">
<a class="xref" href="transform-apis.html#preview-transform" title="Preview transform API">Preview transforms</a>
</li>
<li class="listitem">
<a class="xref" href="transform-apis.html#reset-transform" title="Reset transform API">Reset transforms</a>
</li>
<li class="listitem">
<a class="xref" href="transform-apis.html#schedule-now-transform" title="Schedule now transform API">Schedule now transforms</a>
</li>
<li class="listitem">
<a class="xref" href="transform-apis.html#start-transform" title="Start transform API">Start transforms</a>
</li>
<li class="listitem">
<a class="xref" href="transform-apis.html#stop-transform" title="Stop transforms API">Stop transforms</a>
</li>
<li class="listitem">
<a class="xref" href="transform-apis.html#update-transform" title="Update transform API">Update transforms</a>
</li>
</ul>
</div>
<p>For the full list, see <a class="xref" href="transform-apis.html" title="Transform APIs"><em>Transform APIs</em></a>.</p>
</div>

<div class="section xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="ecommerce-transforms"></a>Tutorial: Transforming the eCommerce sample data<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/ecommerce-tutorial.asciidoc">edit</a></h2>
</div></div></div>
<p><a class="xref" href="transforms.html" title="Transforming data">Transforms</a> enable you to retrieve information
from an Elasticsearch index, transform it, and store it in another index. Let&#8217;s use the
<a href="https://www.elastic.co/guide/en/kibana/8.9/add-sample-data.html" class="ulink" target="_top">Kibana sample data</a> to demonstrate how you can
pivot and summarize your data with transforms.</p>
<div class="olist orderedlist">
<ol class="orderedlist">
<li class="listitem">
Verify that your environment is set up properly to use transforms. If the
Elasticsearch security features are enabled, to complete this tutorial you need a user
that has authority to preview and create transforms. You must also have
specific index privileges for the source and destination indices. See
<a class="xref" href="transforms.html#transform-setup" title="Set up transforms">Setup</a>.
</li>
<li class="listitem">
<p>Choose your <em>source index</em>.</p>
<p>In this example, we&#8217;ll use the eCommerce orders sample data. If you&#8217;re not
already familiar with the <code class="literal">kibana_sample_data_ecommerce</code> index, use the
<span class="strong strong"><strong>Revenue</strong></span> dashboard in Kibana to explore the data. Consider what insights you
might want to derive from this eCommerce data.</p>
</li>
<li class="listitem">
<p>Choose the pivot type of transform and play with various options for
grouping and aggregating the data.</p>
<p>There are two types of transforms, but first we&#8217;ll try out <em>pivoting</em> your
data, which involves using at least one field to group it and applying at least
one aggregation. You can preview what the transformed data will look
like, so go ahead and play with it! You can also enable histogram charts to get
a better understanding of the distribution of values in your data.</p>
<p>For example, you might want to group the data by product ID and calculate the
total number of sales for each product and its average price. Alternatively, you
might want to look at the behavior of individual customers and calculate how
much each customer spent in total and how many different categories of products
they purchased. Or you might want to take the currencies or geographies into
consideration. What are the most interesting ways you can transform and
interpret this data?</p>
<p>Go to <span class="strong strong"><strong>Management</strong></span> &gt; <span class="strong strong"><strong>Stack Management</strong></span> &gt; <span class="strong strong"><strong>Data</strong></span> &gt; <span class="strong strong"><strong>Transforms</strong></span> in Kibana and use
the wizard to create a transform:</p>
<div class="imageblock screenshot">
<div class="content">
<img src="images/ecommerce-pivot1.png" alt="Creating a simple transform in Kibana">
</div>
</div>
<p>Group the data by customer ID and add one or more aggregations to learn more
about each customer&#8217;s orders. For example, let&#8217;s calculate the sum of products
they purchased, the total price of their purchases, the maximum number of
products that they purchased in a single order, and their total number of orders. We&#8217;ll accomplish this by using the
<a class="xref" href="search-aggregations-metrics.html#search-aggregations-metrics-sum-aggregation" title="Sum aggregation"><code class="literal">sum</code> aggregation</a> on the
<code class="literal">total_quantity</code> and <code class="literal">taxless_total_price</code> fields, the
<a class="xref" href="search-aggregations-metrics.html#search-aggregations-metrics-max-aggregation" title="Max aggregation"><code class="literal">max</code> aggregation</a> on the
<code class="literal">total_quantity</code> field, and the
<a class="xref" href="search-aggregations-metrics.html#search-aggregations-metrics-cardinality-aggregation" title="Cardinality aggregation"><code class="literal">cardinality</code> aggregation</a>
on the <code class="literal">order_id</code> field:</p>
<div class="imageblock screenshot">
<div class="content">
<img src="images/ecommerce-pivot2.png" alt="Adding multiple aggregations to a transform in Kibana">
</div>
</div>
<div class="tip admon">
<div class="icon"></div>
<div class="admon_content">
<p>If you&#8217;re interested in a subset of the data, you can optionally include a
<a class="xref" href="search.html#request-body-search-query">query</a> element. In this
example, we&#8217;ve filtered the data so that we&#8217;re only looking at orders with a
<code class="literal">currency</code> of <code class="literal">EUR</code>. Alternatively, we could group the data by that field too.
If you want to use more complex queries, you can create your data frame from a
<a href="https://www.elastic.co/guide/en/kibana/8.9/save-open-search.html" class="ulink" target="_top">saved search</a>.</p>
</div>
</div>
<p>If you prefer, you can use the
<a class="xref" href="transform-apis.html#preview-transform" title="Preview transform API">preview transforms API</a>.</p>
<details>
<summary class="title">API example</summary>
<div class="content">
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST _transform/_preview
{
  "source": {
    "index": "kibana_sample_data_ecommerce",
    "query": {
      "bool": {
        "filter": {
          "term": {"currency": "EUR"}
        }
      }
    }
  },
  "pivot": {
    "group_by": {
      "customer_id": {
        "terms": {
          "field": "customer_id"
        }
      }
    },
    "aggregations": {
      "total_quantity.sum": {
        "sum": {
          "field": "total_quantity"
        }
      },
      "taxless_total_price.sum": {
        "sum": {
          "field": "taxless_total_price"
        }
      },
      "total_quantity.max": {
        "max": {
          "field": "total_quantity"
        }
      },
      "order_id.cardinality": {
        "cardinality": {
          "field": "order_id"
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1673.console"></div>
</div>
</details>
</li>
<li class="listitem">
<p>When you are satisfied with what you see in the preview, create the
transform.</p>
<div class="olist orderedlist">
<ol class="orderedlist">
<li class="listitem">
Supply a transform ID, the name of the destination index and optionally a
description. If the destination index does not exist, it will be created
automatically when you start the transform.
</li>
<li class="listitem">
Decide whether you want the transform to run once or continuously. Since
this sample data index is unchanging, let&#8217;s use the default behavior and just
run the transform once. If you want to try it out, however, go ahead and click
on <span class="strong strong"><strong>Continuous mode</strong></span>. You must choose a field that the transform can use to
check which entities have changed. In general, it&#8217;s a good idea to use the
ingest timestamp field. In this example, however, you can use the <code class="literal">order_date</code>
field.
</li>
<li class="listitem">
Optionally, you can configure a retention policy that applies to your
transform. Select a date field that is used to identify old documents
in the destination index and provide a maximum age. Documents that are older
than the configured value are removed from the destination index.
</li>
</ol>
</div>
<div class="imageblock screenshot">
<div class="content">
<img src="images/ecommerce-pivot3.png" alt="Adding transfrom ID and retention policy to a transform in Kibana">
</div>
</div>
<p>In Kibana, before you finish creating the transform, you can copy the preview
transform API request to your clipboard. This information is useful later when
you&#8217;re deciding whether you want to manually create the destination index.</p>
<div class="imageblock screenshot">
<div class="content">
<img src="images/ecommerce-pivot4.png" alt="Copy the Dev Console statement of the transform preview to the clipboard">
</div>
</div>
<p>If you prefer, you can use the
<a class="xref" href="transform-apis.html#put-transform" title="Create transform API">create transforms API</a>.</p>
<details>
<summary class="title">API example</summary>
<div class="content">
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT _transform/ecommerce-customer-transform
{
  "source": {
    "index": [
      "kibana_sample_data_ecommerce"
    ],
    "query": {
      "bool": {
        "filter": {
          "term": {
            "currency": "EUR"
          }
        }
      }
    }
  },
  "pivot": {
    "group_by": {
      "customer_id": {
        "terms": {
          "field": "customer_id"
        }
      }
    },
    "aggregations": {
      "total_quantity.sum": {
        "sum": {
          "field": "total_quantity"
        }
      },
      "taxless_total_price.sum": {
        "sum": {
          "field": "taxless_total_price"
        }
      },
      "total_quantity.max": {
        "max": {
          "field": "total_quantity"
        }
      },
      "order_id.cardinality": {
        "cardinality": {
          "field": "order_id"
        }
      }
    }
  },
  "dest": {
    "index": "ecommerce-customers"
  },
  "retention_policy": {
    "time": {
      "field": "order_date",
      "max_age": "60d"
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1674.console"></div>
</div>
</details>
</li>
<li class="listitem">
<p>Optional: Create the destination index.</p>
<p>If the destination index does not exist, it is created the first time you start
your transform. A pivot transform deduces the mappings for the destination
index from the source indices and the transform aggregations. If there are
fields in the destination index that are derived from scripts (for example,
if you use
<a class="xref" href="search-aggregations-metrics.html#search-aggregations-metrics-scripted-metric-aggregation" title="Scripted metric aggregation"><code class="literal">scripted_metrics</code></a>
or <a class="xref" href="search-aggregations-pipeline.html#search-aggregations-pipeline-bucket-script-aggregation" title="Bucket script aggregation"><code class="literal">bucket_scripts</code></a>
aggregations), they&#8217;re created with <a class="xref" href="dynamic-mapping.html" title="Dynamic mapping">dynamic mappings</a>. You
can use the preview transform API to preview the mappings it will use for the
destination index. In Kibana, if you copied the API request to your
clipboard, paste it into the console, then refer to the <code class="literal">generated_dest_index</code>
object in the API response.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>Transforms might have more configuration options provided by the
APIs than the options available in Kibana. For example, you can set an ingest
pipeline for <code class="literal">dest</code> by calling the <a class="xref" href="transform-apis.html#put-transform" title="Create transform API">Create transform</a>. For all the transform
configuration options, refer to the <a class="xref" href="transform-apis.html" title="Transform APIs">documentation</a>.</p>
</div>
</div>
<details>
<summary class="title">API example</summary>
<div class="content">
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "preview" : [
    {
      "total_quantity" : {
        "max" : 2,
        "sum" : 118.0
      },
      "taxless_total_price" : {
        "sum" : 3946.9765625
      },
      "customer_id" : "10",
      "order_id" : {
        "cardinality" : 59
      }
    },
    ...
  ],
  "generated_dest_index" : {
    "mappings" : {
      "_meta" : {
        "_transform" : {
          "transform" : "transform-preview",
          "version" : {
            "created" : "8.0.0"
          },
          "creation_date_in_millis" : 1621991264061
        },
        "created_by" : "transform"
      },
      "properties" : {
        "total_quantity.sum" : {
          "type" : "double"
        },
        "total_quantity" : {
          "type" : "object"
        },
        "taxless_total_price" : {
          "type" : "object"
        },
        "taxless_total_price.sum" : {
          "type" : "double"
        },
        "order_id.cardinality" : {
          "type" : "long"
        },
        "customer_id" : {
          "type" : "keyword"
        },
        "total_quantity.max" : {
          "type" : "integer"
        },
        "order_id" : {
          "type" : "object"
        }
      }
    },
    "settings" : {
      "index" : {
        "number_of_shards" : "1",
        "auto_expand_replicas" : "0-1"
      }
    },
    "aliases" : { }
  }
}</pre>
</div>
</div>
</details>
<p>In some instances the deduced mappings might be incompatible with the actual
data. For example, numeric overflows might occur or dynamically mapped fields
might contain both numbers and strings. To avoid this problem, create your
destination index before you start the transform. For more information, see
the <a class="xref" href="indices.html#indices-create-index" title="Create index API">create index API</a>.</p>
<details>
<summary class="title">API example</summary>
<div class="content">
<p>You can use the information from the transform preview to create the
destination index. For example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /ecommerce-customers
{
  "mappings": {
    "properties": {
      "total_quantity.sum" : {
        "type" : "double"
      },
      "total_quantity" : {
        "type" : "object"
      },
      "taxless_total_price" : {
        "type" : "object"
      },
      "taxless_total_price.sum" : {
        "type" : "double"
      },
      "order_id.cardinality" : {
        "type" : "long"
      },
      "customer_id" : {
        "type" : "keyword"
      },
      "total_quantity.max" : {
        "type" : "integer"
      },
      "order_id" : {
        "type" : "object"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1675.console"></div>
</div>
</details>
</li>
<li class="listitem">
<p>Start the transform.</p>
<div class="tip admon">
<div class="icon"></div>
<div class="admon_content">
<p>Even though resource utilization is automatically adjusted based on the
cluster load, a transform increases search and indexing load on your
cluster while it runs. If you&#8217;re experiencing an excessive load, however, you
can stop it.</p>
</div>
</div>
<p>You can start, stop, reset, and manage transforms in Kibana:</p>
<div class="imageblock screenshot">
<div class="content">
<img src="images/manage-transforms.png" alt="Managing transforms in Kibana">
</div>
</div>
<p>Alternatively, you can use the
<a class="xref" href="transform-apis.html#start-transform" title="Start transform API">start transforms</a>, <a class="xref" href="transform-apis.html#stop-transform" title="Stop transforms API">stop transforms</a> and
<a class="xref" href="transform-apis.html#reset-transform" title="Reset transform API">reset transforms</a> APIs.</p>
<p>If you reset a transform, all checkpoints, states, and the destination index
(if it was created by the transform) are deleted. The transform is ready to
start again as if it had just been created.</p>
<details>
<summary class="title">API example</summary>
<div class="content">
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST _transform/ecommerce-customer-transform/_start</pre>
</div>
<div class="console_widget" data-snippet="snippets/1676.console"></div>
</div>
</details>
<div class="tip admon">
<div class="icon"></div>
<div class="admon_content">
<p>If you chose a batch transform, it is a single operation that has a
single checkpoint. You cannot restart it when it&#8217;s complete. Continuous transforms
differ in that they continually increment and process checkpoints as new source
data is ingested.</p>
</div>
</div>
</li>
<li class="listitem">
<p>Explore the data in your new index.</p>
<p>For example, use the <span class="strong strong"><strong>Discover</strong></span> application in Kibana:</p>
<div class="imageblock screenshot">
<div class="content">
<img src="images/ecommerce-results.png" alt="Exploring the new index in Kibana">
</div>
</div>
</li>
<li class="listitem">
<p>Optional: Create another transform, this time using the <code class="literal">latest</code> method.</p>
<p>This method populates the destination index with the latest documents for each
unique key value. For example, you might want to find the latest orders (sorted
by the <code class="literal">order_date</code> field) for each customer or for each country and region.</p>
<div class="imageblock screenshot">
<div class="content">
<img src="images/ecommerce-latest1.png" alt="Creating a latest transform in Kibana">
</div>
</div>
<details>
<summary class="title">API example</summary>
<div class="content">
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST _transform/_preview
{
  "source": {
    "index": "kibana_sample_data_ecommerce",
    "query": {
      "bool": {
        "filter": {
          "term": {"currency": "EUR"}
        }
      }
    }
  },
  "latest": {
    "unique_key": ["geoip.country_iso_code", "geoip.region_name"],
    "sort": "order_date"
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1677.console"></div>
</div>
</details>
<div class="tip admon">
<div class="icon"></div>
<div class="admon_content">
<p>If the destination index does not exist, it is created the first time you
start your transform. Unlike pivot transforms, however, latest transforms
do not deduce mapping definitions when they create the index. Instead, they use
dynamic mappings. To use explicit mappings, create the destination index
before you start the transform.</p>
</div>
</div>
</li>
<li class="listitem">
If you do not want to keep a transform, you can delete it in
Kibana or use the <a class="xref" href="transform-apis.html#delete-transform" title="Delete transform API">delete transform API</a>. By default, when
you delete a transform, its destination index and Kibana index patterns remain.
</li>
</ol>
</div>
<p>Now that you&#8217;ve created simple transforms for Kibana sample data, consider
possible use cases for your own data. For more ideas, see
<a class="xref" href="transforms.html#transform-usage" title="When to use transforms">When to use transforms</a> and <a class="xref" href="transforms.html#transform-examples" title="Transform examples">Examples</a>.</p>
</div>

<div class="section xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="transform-examples"></a>Transform examples<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/examples.asciidoc">edit</a></h2>
</div></div></div>

<p>These examples demonstrate how to use transforms to derive useful insights
from your data. All the examples use one of the
<a href="https://www.elastic.co/guide/en/kibana/8.9/add-sample-data.html" class="ulink" target="_top">Kibana sample datasets</a>. For a more detailed,
step-by-step example, see <a class="xref" href="transforms.html#ecommerce-transforms" title="Tutorial: Transforming the eCommerce sample data">Tutorial: Transforming the eCommerce sample data</a>.</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<a class="xref" href="transforms.html#example-best-customers" title="Finding your best customers">Finding your best customers</a>
</li>
<li class="listitem">
<a class="xref" href="transforms.html#example-airline" title="Finding air carriers with the most delays">Finding air carriers with the most delays</a>
</li>
<li class="listitem">
<a class="xref" href="transforms.html#example-clientips" title="Finding suspicious client IPs">Finding suspicious client IPs</a>
</li>
<li class="listitem">
<a class="xref" href="transforms.html#example-last-log" title="Finding the last log event for each IP address">Finding the last log event for each IP address</a>
</li>
<li class="listitem">
<a class="xref" href="transforms.html#example-bytes" title="Finding client IPs that sent the most bytes to the server">Finding client IPs that sent the most bytes to the server</a>
</li>
<li class="listitem">
<a class="xref" href="transforms.html#example-customer-names" title="Getting customer name and email address by customer ID">Getting customer name and email address by customer ID</a>
</li>
</ul>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="example-best-customers"></a>Finding your best customers<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/examples.asciidoc">edit</a></h3>
</div></div></div>
<p>This example uses the eCommerce orders sample data set to find the customers who
spent the most in a hypothetical webshop. Let&#8217;s use the <code class="literal">pivot</code> type of
transform such that the destination index contains the number of orders, the
total price of the orders, the amount of unique products and the average price
per order, and the total amount of ordered products for each customer.</p>
<div class="imageblock screenshot">
<div class="content">
<img src="images/transform-ex1-1.jpg" alt="Finding your best customers with transforms in Kibana">
</div>
</div>
<p>Alternatively, you can use the <a class="xref" href="transform-apis.html#preview-transform" title="Preview transform API">preview transform</a> and
the <a class="xref" href="transform-apis.html#put-transform" title="Create transform API">create transform API</a>.</p>
<details>
<summary class="title">API example</summary>
<div class="content">
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST _transform/_preview
{
  "source": {
    "index": "kibana_sample_data_ecommerce"
  },
  "dest" : { <a id="CO534-1"></a><i class="conum" data-value="1"></i>
    "index" : "sample_ecommerce_orders_by_customer"
  },
  "pivot": {
    "group_by": { <a id="CO534-2"></a><i class="conum" data-value="2"></i>
      "user": { "terms": { "field": "user" }},
      "customer_id": { "terms": { "field": "customer_id" }}
    },
    "aggregations": {
      "order_count": { "value_count": { "field": "order_id" }},
      "total_order_amt": { "sum": { "field": "taxful_total_price" }},
      "avg_amt_per_order": { "avg": { "field": "taxful_total_price" }},
      "avg_unique_products_per_order": { "avg": { "field": "total_unique_products" }},
      "total_unique_products": { "cardinality": { "field": "products.product_id" }}
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1678.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO534-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The destination index for the transform. It is ignored by <code class="literal">_preview</code>.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO534-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>Two <code class="literal">group_by</code> fields is selected. This means the transform contains a
unique row per <code class="literal">user</code> and <code class="literal">customer_id</code> combination. Within this data set, both
these fields are unique. By including both in the transform, it gives more
context to the final results.</p>
</td>
</tr>
</table>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>In the example above, condensed JSON formatting is used for easier
readability of the pivot object.</p>
</div>
</div>
<p>The preview transforms API enables you to see the layout of the transform in
advance, populated with some sample values. For example:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "preview" : [
    {
      "total_order_amt" : 3946.9765625,
      "order_count" : 59.0,
      "total_unique_products" : 116.0,
      "avg_unique_products_per_order" : 2.0,
      "customer_id" : "10",
      "user" : "recip",
      "avg_amt_per_order" : 66.89790783898304
    },
    ...
    ]
  }</pre>
</div>
</div>
</details>
<p>This transform makes it easier to answer questions such as:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Which customers spend the most?
</li>
<li class="listitem">
Which customers spend the most per order?
</li>
<li class="listitem">
Which customers order most often?
</li>
<li class="listitem">
Which customers ordered the least number of different products?
</li>
</ul>
</div>
<p>It&#8217;s possible to answer these questions using aggregations alone, however
transforms allow us to persist this data as a customer centric index. This
enables us to analyze data at scale and gives more flexibility to explore and
navigate data from a customer centric perspective. In some cases, it can even
make creating visualizations much simpler.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="example-airline"></a>Finding air carriers with the most delays<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/examples.asciidoc">edit</a></h3>
</div></div></div>
<p>This example uses the Flights sample data set to find out which air carrier
had the most delays. First, filter the source data such that it excludes all
the cancelled flights by using a query filter. Then transform the data to
contain the distinct number of flights, the sum of delayed minutes, and the sum
of the flight minutes by air carrier. Finally, use a
<a class="xref" href="search-aggregations-pipeline.html#search-aggregations-pipeline-bucket-script-aggregation" title="Bucket script aggregation"><code class="literal">bucket_script</code></a>
to determine what percentage of the flight time was actually delay.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST _transform/_preview
{
  "source": {
    "index": "kibana_sample_data_flights",
    "query": { <a id="CO535-1"></a><i class="conum" data-value="1"></i>
      "bool": {
        "filter": [
          { "term":  { "Cancelled": false } }
        ]
      }
    }
  },
  "dest" : { <a id="CO535-2"></a><i class="conum" data-value="2"></i>
    "index" : "sample_flight_delays_by_carrier"
  },
  "pivot": {
    "group_by": { <a id="CO535-3"></a><i class="conum" data-value="3"></i>
      "carrier": { "terms": { "field": "Carrier" }}
    },
    "aggregations": {
      "flights_count": { "value_count": { "field": "FlightNum" }},
      "delay_mins_total": { "sum": { "field": "FlightDelayMin" }},
      "flight_mins_total": { "sum": { "field": "FlightTimeMin" }},
      "delay_time_percentage": { <a id="CO535-4"></a><i class="conum" data-value="4"></i>
        "bucket_script": {
          "buckets_path": {
            "delay_time": "delay_mins_total.value",
            "flight_time": "flight_mins_total.value"
          },
          "script": "(params.delay_time / params.flight_time) * 100"
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1679.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO535-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Filter the source data to select only flights that are not cancelled.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO535-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>The destination index for the transform. It is ignored by <code class="literal">_preview</code>.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO535-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>The data is grouped by the <code class="literal">Carrier</code> field which contains the airline name.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO535-4"><i class="conum" data-value="4"></i></a></p>
</td>
<td align="left" valign="top">
<p>This <code class="literal">bucket_script</code> performs calculations on the results that are returned
by the aggregation. In this particular example, it calculates what percentage of
travel time was taken up by delays.</p>
</td>
</tr>
</table>
</div>
<p>The preview shows you that the new index would contain data like this for each
carrier:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "preview" : [
    {
      "carrier" : "ES-Air",
      "flights_count" : 2802.0,
      "flight_mins_total" : 1436927.5130677223,
      "delay_time_percentage" : 9.335543983955839,
      "delay_mins_total" : 134145.0
    },
    ...
  ]
}</pre>
</div>
<p>This transform makes it easier to answer questions such as:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Which air carrier has the most delays as a percentage of flight time?
</li>
</ul>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>This data is fictional and does not reflect actual delays or flight stats
for any of the featured destination or origin airports.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="example-clientips"></a>Finding suspicious client IPs<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/examples.asciidoc">edit</a></h3>
</div></div></div>
<p>This example uses the web log sample data set to identify suspicious client IPs.
It transforms the data such that the new index contains the sum of bytes and the
number of distinct URLs, agents, incoming requests by location, and geographic
destinations for each client IP. It also uses filter aggregations to count the
specific types of HTTP responses that each client IP receives. Ultimately, the
example below transforms web log data into an entity centric index where the
entity is <code class="literal">clientip</code>.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT _transform/suspicious_client_ips
{
  "source": {
    "index": "kibana_sample_data_logs"
  },
  "dest" : { <a id="CO536-1"></a><i class="conum" data-value="1"></i>
    "index" : "sample_weblogs_by_clientip"
  },
  "sync" : { <a id="CO536-2"></a><i class="conum" data-value="2"></i>
    "time": {
      "field": "timestamp",
      "delay": "60s"
    }
  },
  "pivot": {
    "group_by": {  <a id="CO536-3"></a><i class="conum" data-value="3"></i>
      "clientip": { "terms": { "field": "clientip" } }
      },
    "aggregations": {
      "url_dc": { "cardinality": { "field": "url.keyword" }},
      "bytes_sum": { "sum": { "field": "bytes" }},
      "geo.src_dc": { "cardinality": { "field": "geo.src" }},
      "agent_dc": { "cardinality": { "field": "agent.keyword" }},
      "geo.dest_dc": { "cardinality": { "field": "geo.dest" }},
      "responses.total": { "value_count": { "field": "timestamp" }},
      "success" : { <a id="CO536-4"></a><i class="conum" data-value="4"></i>
         "filter": {
            "term": { "response" : "200"}}
        },
      "error404" : {
         "filter": {
            "term": { "response" : "404"}}
        },
      "error5xx" : {
         "filter": {
            "range": { "response" : { "gte": 500, "lt": 600}}}
        },
      "timestamp.min": { "min": { "field": "timestamp" }},
      "timestamp.max": { "max": { "field": "timestamp" }},
      "timestamp.duration_ms": { <a id="CO536-5"></a><i class="conum" data-value="5"></i>
        "bucket_script": {
          "buckets_path": {
            "min_time": "timestamp.min.value",
            "max_time": "timestamp.max.value"
          },
          "script": "(params.max_time - params.min_time)"
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1680.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO536-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The destination index for the transform.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO536-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>Configures the transform to run continuously. It uses the <code class="literal">timestamp</code>
field to synchronize the source and destination indices. The worst case
ingestion delay is 60 seconds.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO536-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>The data is grouped by the <code class="literal">clientip</code> field.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO536-4"><i class="conum" data-value="4"></i></a></p>
</td>
<td align="left" valign="top">
<p>Filter aggregation that counts the occurrences of successful (<code class="literal">200</code>)
responses in the <code class="literal">response</code> field. The following two aggregations (<code class="literal">error404</code>
and <code class="literal">error5xx</code>) count the error responses by error codes, matching an exact
value or a range of response codes.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO536-5"><i class="conum" data-value="5"></i></a></p>
</td>
<td align="left" valign="top">
<p>This <code class="literal">bucket_script</code> calculates the duration of the <code class="literal">clientip</code> access based
on the results of the aggregation.</p>
</td>
</tr>
</table>
</div>
<p>After you create the transform, you must start it:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST _transform/suspicious_client_ips/_start</pre>
</div>
<div class="console_widget" data-snippet="snippets/1681.console"></div>
<p>Shortly thereafter, the first results should be available in the destination
index:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET sample_weblogs_by_clientip/_search</pre>
</div>
<div class="console_widget" data-snippet="snippets/1682.console"></div>
<p>The search result shows you data like this for each client IP:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">    "hits" : [
      {
        "_index" : "sample_weblogs_by_clientip",
        "_id" : "MOeHH_cUL5urmartKj-b5UQAAAAAAAAA",
        "_score" : 1.0,
        "_source" : {
          "geo" : {
            "src_dc" : 2.0,
            "dest_dc" : 2.0
          },
          "success" : 2,
          "error404" : 0,
          "error503" : 0,
          "clientip" : "0.72.176.46",
          "agent_dc" : 2.0,
          "bytes_sum" : 4422.0,
          "responses" : {
            "total" : 2.0
          },
          "url_dc" : 2.0,
          "timestamp" : {
            "duration_ms" : 5.2191698E8,
            "min" : "2020-03-16T07:51:57.333Z",
            "max" : "2020-03-22T08:50:34.313Z"
          }
        }
      }
    ]</pre>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>Like other Kibana sample data sets, the web log sample dataset contains
timestamps relative to when you installed it, including timestamps in the
future. The continuous transform will pick up the data points once they are in the past.
If you installed the web log sample dataset some time ago, you can uninstall and
reinstall it and the timestamps will change.</p>
</div>
</div>
<p>This transform makes it easier to answer questions such as:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Which client IPs are transferring the most amounts of data?
</li>
<li class="listitem">
Which client IPs are interacting with a high number of different URLs?
</li>
<li class="listitem">
Which client IPs have high error rates?
</li>
<li class="listitem">
Which client IPs are interacting with a high number of destination countries?
</li>
</ul>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="example-last-log"></a>Finding the last log event for each IP address<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/examples.asciidoc">edit</a></h3>
</div></div></div>
<p>This example uses the web log sample data set to find the last log from an IP
address. Let&#8217;s use the <code class="literal">latest</code> type of transform in continuous mode. It
copies the most recent document for each unique key from the source index to the
destination index and updates the destination index as new data comes into the
source index.</p>
<p>Pick the <code class="literal">clientip</code> field as the unique key; the data is grouped by this field.
Select <code class="literal">timestamp</code> as the date field that sorts the data chronologically. For
continuous mode, specify a date field that is used to identify new documents,
and an interval between checks for changes in the source index.</p>
<div class="imageblock screenshot">
<div class="content">
<img src="images/transform-ex4-1.jpg" alt="Finding the last log event for each IP address with transforms in Kibana">
</div>
</div>
<p>Let&#8217;s assume that we&#8217;re interested in retaining documents only for IP addresses
that appeared recently in the log. You can define a retention policy and specify
a date field that is used to calculate the age of a document. This example uses
the same date field that is used to sort the data. Then set the maximum age of a
document; documents that are older than the value you set will be removed from
the destination index.</p>
<div class="imageblock screenshot">
<div class="content">
<img src="images/transform-ex4-2.jpg" alt="Defining retention policy for transforms in Kibana">
</div>
</div>
<p>This transform creates the destination index that contains the latest login
date for each client IP. As the transform runs in continuous mode, the
destination index will be updated as new data that comes into the source index.
Finally, every document that is older than 30 days will be removed from the
destination index due to the applied retention policy.</p>
<details>
<summary class="title">API example</summary>
<div class="content">
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT _transform/last-log-from-clientip
{
  "source": {
    "index": [
      "kibana_sample_data_logs"
    ]
  },
  "latest": {
    "unique_key": [ <a id="CO537-1"></a><i class="conum" data-value="1"></i>
      "clientip"
    ],
    "sort": "timestamp" <a id="CO537-2"></a><i class="conum" data-value="2"></i>
  },
  "frequency": "1m", <a id="CO537-3"></a><i class="conum" data-value="3"></i>
  "dest": {
    "index": "last-log-from-clientip"
  },
  "sync": { <a id="CO537-4"></a><i class="conum" data-value="4"></i>
    "time": {
      "field": "timestamp",
      "delay": "60s"
    }
  },
  "retention_policy": { <a id="CO537-5"></a><i class="conum" data-value="5"></i>
    "time": {
      "field": "timestamp",
      "max_age": "30d"
    }
  },
  "settings": {
    "max_page_search_size": 500
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1683.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO537-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Specifies the field for grouping the data.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO537-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>Specifies the date field that is used for sorting the data.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO537-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>Sets the interval for the transform to check for changes in the source
index.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO537-4"><i class="conum" data-value="4"></i></a></p>
</td>
<td align="left" valign="top">
<p>Contains the time field and delay settings used to synchronize the source
and destination indices.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO537-5"><i class="conum" data-value="5"></i></a></p>
</td>
<td align="left" valign="top">
<p>Specifies the retention policy for the transform. Documents that are older
than the configured value will be removed from the destination index.</p>
</td>
</tr>
</table>
</div>
<p>After you create the transform, start it:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST _transform/last-log-from-clientip/_start</pre>
</div>
<div class="console_widget" data-snippet="snippets/1684.console"></div>
</div>
</details>
<p>After the transform processes the data, search the destination index:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET last-log-from-clientip/_search</pre>
</div>
<div class="console_widget" data-snippet="snippets/1685.console"></div>
<p>The search result shows you data like this for each client IP:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "_index" : "last-log-from-clientip",
  "_id" : "MOeHH_cUL5urmartKj-b5UQAAAAAAAAA",
  "_score" : 1.0,
  "_source" : {
    "referer" : "http://twitter.com/error/don-lind",
    "request" : "/elasticsearch",
    "agent" : "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 1.1.4322)",
    "extension" : "",
    "memory" : null,
    "ip" : "0.72.176.46",
    "index" : "kibana_sample_data_logs",
    "message" : "0.72.176.46 - - [2018-09-18T06:31:00.572Z] \"GET /elasticsearch HTTP/1.1\" 200 7065 \"-\" \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 1.1.4322)\"",
    "url" : "https://www.elastic.co/downloads/elasticsearch",
    "tags" : [
      "success",
      "info"
    ],
    "geo" : {
      "srcdest" : "IN:PH",
      "src" : "IN",
      "coordinates" : {
        "lon" : -124.1127917,
        "lat" : 40.80338889
      },
      "dest" : "PH"
    },
    "utc_time" : "2021-05-04T06:31:00.572Z",
    "bytes" : 7065,
    "machine" : {
      "os" : "ios",
      "ram" : 12884901888
    },
    "response" : 200,
    "clientip" : "0.72.176.46",
    "host" : "www.elastic.co",
    "event" : {
      "dataset" : "sample_web_logs"
    },
    "phpmemory" : null,
    "timestamp" : "2021-05-04T06:31:00.572Z"
  }
}</pre>
</div>
<p>This transform makes it easier to answer questions such as:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
What was the most recent log event associated with a specific IP address?
</li>
</ul>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="example-bytes"></a>Finding client IPs that sent the most bytes to the server<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/examples.asciidoc">edit</a></h3>
</div></div></div>
<p>This example uses the web log sample data set to find the client IP that sent
the most bytes to the server in every hour. The example uses a <code class="literal">pivot</code>
transform with a <a class="xref" href="search-aggregations-metrics.html#search-aggregations-metrics-top-metrics" title="Top metrics aggregation"><code class="literal">top_metrics</code></a>
aggregation.</p>
<p>Group the data by a <a class="xref" href="search-aggregations-bucket.html#_date_histogram" title="Date histogram">date histogram</a> on the time field with an
interval of one hour. Use a
<a class="xref" href="search-aggregations-metrics.html#search-aggregations-metrics-max-aggregation" title="Max aggregation">max aggregation</a> on the <code class="literal">bytes</code>
field to get the maximum amount of data that is sent to the server. Without
the <code class="literal">max</code> aggregation, the API call still returns the client IP that sent the
most bytes, however, the amount of bytes that it sent is not returned. In the
<code class="literal">top_metrics</code> property, specify <code class="literal">clientip</code> and <code class="literal">geo.src</code>, then sort them by the
<code class="literal">bytes</code> field in descending order. The transform returns the client IP that
sent the biggest amount of data and the 2-letter ISO code of the corresponding
location.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST _transform/_preview
{
  "source": {
    "index": "kibana_sample_data_logs"
  },
  "pivot": {
    "group_by": { <a id="CO538-1"></a><i class="conum" data-value="1"></i>
      "timestamp": {
        "date_histogram": {
          "field": "timestamp",
          "fixed_interval": "1h"
        }
      }
    },
    "aggregations": {
      "bytes.max": { <a id="CO538-2"></a><i class="conum" data-value="2"></i>
        "max": {
          "field": "bytes"
        }
      },
      "top": {
        "top_metrics": { <a id="CO538-3"></a><i class="conum" data-value="3"></i>
          "metrics": [
            {
              "field": "clientip"
            },
            {
              "field": "geo.src"
            }
          ],
          "sort": {
            "bytes": "desc"
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1686.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO538-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The data is grouped by a date histogram of the time field with a one hour
interval.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO538-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>Calculates the maximum value of the <code class="literal">bytes</code> field.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO538-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>Specifies the fields (<code class="literal">clientip</code> and <code class="literal">geo.src</code>) of the top document to
return and the sorting method (document with the highest <code class="literal">bytes</code> value).</p>
</td>
</tr>
</table>
</div>
<p>The API call above returns a response similar to this:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "preview" : [
    {
      "top" : {
        "clientip" : "223.87.60.27",
        "geo.src" : "IN"
      },
      "bytes" : {
        "max" : 6219
      },
      "timestamp" : "2021-04-25T00:00:00.000Z"
    },
    {
      "top" : {
        "clientip" : "99.74.118.237",
        "geo.src" : "LK"
      },
      "bytes" : {
        "max" : 14113
      },
      "timestamp" : "2021-04-25T03:00:00.000Z"
    },
    {
      "top" : {
        "clientip" : "218.148.135.12",
        "geo.src" : "BR"
      },
      "bytes" : {
        "max" : 4531
      },
      "timestamp" : "2021-04-25T04:00:00.000Z"
    },
    ...
  ]
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="example-customer-names"></a>Getting customer name and email address by customer ID<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/examples.asciidoc">edit</a></h3>
</div></div></div>
<p>This example uses the ecommerce sample data set to create an entity-centric
index based on customer ID, and to get the customer name and email address by
using the <code class="literal">top_metrics</code> aggregation.</p>
<p>Group the data by <code class="literal">customer_id</code>, then add a <code class="literal">top_metrics</code> aggregation where the
<code class="literal">metrics</code> are the <code class="literal">email</code>, the <code class="literal">customer_first_name.keyword</code>, and the
<code class="literal">customer_last_name.keyword</code> fields. Sort the <code class="literal">top_metrics</code> by <code class="literal">order_date</code> in
descending order. The API call looks like this:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST _transform/_preview
{
  "source": {
    "index": "kibana_sample_data_ecommerce"
  },
  "pivot": {
    "group_by": { <a id="CO539-1"></a><i class="conum" data-value="1"></i>
      "customer_id": {
        "terms": {
          "field": "customer_id"
        }
      }
    },
    "aggregations": {
      "last": {
        "top_metrics": { <a id="CO539-2"></a><i class="conum" data-value="2"></i>
          "metrics": [
            {
              "field": "email"
            },
            {
              "field": "customer_first_name.keyword"
            },
            {
              "field": "customer_last_name.keyword"
            }
          ],
          "sort": {
            "order_date": "desc"
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1687.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO539-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The data is grouped by a <code class="literal">terms</code> aggregation on the <code class="literal">customer_id</code> field.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO539-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>Specifies the fields to return (email and name fields) in a descending order
by the order date.</p>
</td>
</tr>
</table>
</div>
<p>The API returns a response that is similar to this:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js"> {
  "preview" : [
    {
      "last" : {
        "customer_last_name.keyword" : "Long",
        "customer_first_name.keyword" : "Recip",
        "email" : "recip@long-family.zzz"
      },
      "customer_id" : "10"
    },
    {
      "last" : {
        "customer_last_name.keyword" : "Jackson",
        "customer_first_name.keyword" : "Fitzgerald",
        "email" : "fitzgerald@jackson-family.zzz"
      },
      "customer_id" : "11"
    },
    {
      "last" : {
        "customer_last_name.keyword" : "Cross",
        "customer_first_name.keyword" : "Brigitte",
        "email" : "brigitte@cross-family.zzz"
      },
      "customer_id" : "12"
    },
    ...
  ]
}</pre>
</div>
</div>

</div>

<div class="section xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="transform-painless-examples"></a>Painless examples for transforms<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/painless-examples.asciidoc">edit</a></h2>
</div></div></div>

<p>These examples demonstrate how to use Painless in transforms. You can learn
more about the Painless scripting language in the
<a href="https://www.elastic.co/guide/en/elasticsearch/painless/8.9/painless-guide.html" class="ulink" target="_top">Painless guide</a>.</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<a class="xref" href="transforms.html#painless-top-hits" title="Getting top hits by using scripted metric aggregation">Getting top hits by using scripted metric aggregation</a>
</li>
<li class="listitem">
<a class="xref" href="transforms.html#painless-time-features" title="Getting time features by using aggregations">Getting time features by using aggregations</a>
</li>
<li class="listitem">
<a class="xref" href="transforms.html#painless-bucket-script" title="Getting duration by using bucket script">Getting duration by using bucket script</a>
</li>
<li class="listitem">
<a class="xref" href="transforms.html#painless-count-http" title="Counting HTTP responses by using scripted metric aggregation">Counting HTTP responses by using scripted metric aggregation</a>
</li>
<li class="listitem">
<a class="xref" href="transforms.html#painless-compare" title="Comparing indices by using scripted metric aggregations">Comparing indices by using scripted metric aggregations</a>
</li>
<li class="listitem">
<a class="xref" href="transforms.html#painless-web-session" title="Getting web session details by using scripted metric aggregation">Getting web session details by using scripted metric aggregation</a>
</li>
</ul>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
While the context of the following examples is the transform use case,
the Painless scripts in the snippets below can be used in other Elasticsearch search
aggregations, too.
</li>
<li class="listitem">
All the following examples use scripts, transforms cannot deduce mappings of
output fields when the fields are created by a script. Transforms don&#8217;t
create any mappings in the destination index for these fields, which means they
get dynamically mapped. Create the destination index prior to starting the
transform in case you want explicit mappings.
</li>
</ul>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="painless-top-hits"></a>Getting top hits by using scripted metric aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/painless-examples.asciidoc">edit</a></h3>
</div></div></div>
<p>This snippet shows how to find the latest document, in other words the document
with the latest timestamp. From a technical perspective, it helps to achieve
the function of a <a class="xref" href="search-aggregations-metrics.html#search-aggregations-metrics-top-hits-aggregation" title="Top hits aggregation">Top hits</a> by using
scripted metric aggregation in a transform, which provides a metric output.</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">"aggregations": {
  "latest_doc": {
    "scripted_metric": {
      "init_script": "state.timestamp_latest = 0L; state.last_doc = ''", <a id="CO540-1"></a><i class="conum" data-value="1"></i>
      "map_script": """ <a id="CO540-2"></a><i class="conum" data-value="2"></i>
        def current_date = doc['@timestamp'].getValue().toInstant().toEpochMilli();
        if (current_date &gt; state.timestamp_latest)
        {state.timestamp_latest = current_date;
        state.last_doc = new HashMap(params['_source']);}
      """,
      "combine_script": "return state", <a id="CO540-3"></a><i class="conum" data-value="3"></i>
      "reduce_script": """ <a id="CO540-4"></a><i class="conum" data-value="4"></i>
        def last_doc = '';
        def timestamp_latest = 0L;
        for (s in states) {if (s.timestamp_latest &gt; (timestamp_latest))
        {timestamp_latest = s.timestamp_latest; last_doc = s.last_doc;}}
        return last_doc
      """
    }
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO540-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">init_script</code> creates a long type <code class="literal">timestamp_latest</code> and a string type
<code class="literal">last_doc</code> in the <code class="literal">state</code> object.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO540-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">map_script</code> defines <code class="literal">current_date</code> based on the timestamp of the
document, then compares <code class="literal">current_date</code> with <code class="literal">state.timestamp_latest</code>, finally
returns <code class="literal">state.last_doc</code> from the shard. By using <code class="literal">new HashMap(...)</code> you copy
the source document, this is important whenever you want to pass the full source
object from one phase to the next.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO540-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">combine_script</code> returns <code class="literal">state</code> from each shard.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO540-4"><i class="conum" data-value="4"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">reduce_script</code> iterates through the value of <code class="literal">s.timestamp_latest</code>
returned by each shard and returns the document with the latest timestamp
(<code class="literal">last_doc</code>). In the response, the top hit (in other words, the <code class="literal">latest_doc</code>) is
nested below the <code class="literal">latest_doc</code> field.</p>
</td>
</tr>
</table>
</div>
<p>Check the <a class="xref" href="search-aggregations-metrics.html#scripted-metric-aggregation-scope" title="Scope of scripts">scope of scripts</a> for detailed
explanation on the respective scripts.</p>
<p>You can retrieve the last value in a similar way:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">"aggregations": {
  "latest_value": {
    "scripted_metric": {
      "init_script": "state.timestamp_latest = 0L; state.last_value = ''",
      "map_script": """
        def current_date = doc['@timestamp'].getValue().toInstant().toEpochMilli();
        if (current_date &gt; state.timestamp_latest)
        {state.timestamp_latest = current_date;
        state.last_value = params['_source']['value'];}
      """,
      "combine_script": "return state",
      "reduce_script": """
        def last_value = '';
        def timestamp_latest = 0L;
        for (s in states) {if (s.timestamp_latest &gt; (timestamp_latest))
        {timestamp_latest = s.timestamp_latest; last_value = s.last_value;}}
        return last_value
      """
    }
  }
}</pre>
</div>
<h5><a id="top-hits-stored-scripts"></a>Getting top hits by using stored scripts<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/painless-examples.asciidoc">edit</a></h5>
<p>You can also use the power of
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.9/create-stored-script-api.html" class="ulink" target="_top">stored scripts</a> to get the latest value.
Stored scripts reduce compilation time,  make searches faster, and are
updatable.</p>
<div class="olist orderedlist">
<ol class="orderedlist">
<li class="listitem">
<p>Create the stored scripts:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">POST _scripts/last-value-map-init
{
  "script": {
    "lang": "painless",
    "source": """
        state.timestamp_latest = 0L; state.last_value = ''
    """
  }
}

POST _scripts/last-value-map
{
  "script": {
    "lang": "painless",
    "source": """
      def current_date = doc['@timestamp'].getValue().toInstant().toEpochMilli();
        if (current_date &gt; state.timestamp_latest)
        {state.timestamp_latest = current_date;
        state.last_value = doc[params['key']].value;}
    """
  }
}

POST _scripts/last-value-combine
{
  "script": {
    "lang": "painless",
    "source": """
        return state
    """
  }
}

POST _scripts/last-value-reduce
{
  "script": {
    "lang": "painless",
    "source": """
        def last_value = '';
        def timestamp_latest = 0L;
        for (s in states) {if (s.timestamp_latest &gt; (timestamp_latest))
        {timestamp_latest = s.timestamp_latest; last_value = s.last_value;}}
        return last_value
    """
  }
}</pre>
</div>
</li>
<li class="listitem">
<p>Use the stored scripts in a scripted metric aggregation.</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">"aggregations":{
   "latest_value":{
      "scripted_metric":{
         "init_script":{
            "id":"last-value-map-init"
         },
         "map_script":{
            "id":"last-value-map",
            "params":{
               "key":"field_with_last_value" <a id="CO541-1"></a><i class="conum" data-value="1"></i>
            }
         },
         "combine_script":{
            "id":"last-value-combine"
         },
         "reduce_script":{
            "id":"last-value-reduce"
         }</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO541-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The parameter <code class="literal">field_with_last_value</code> can be set any field that you want the
latest value for.</p>
</td>
</tr>
</table>
</div>
</li>
</ol>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="painless-time-features"></a>Getting time features by using aggregations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/painless-examples.asciidoc">edit</a></h3>
</div></div></div>
<p>This snippet shows how to extract time based features by using Painless in a
transform. The snippet uses an index where <code class="literal">@timestamp</code> is defined as a <code class="literal">date</code>
type field.</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">"aggregations": {
  "avg_hour_of_day": { <a id="CO542-1"></a><i class="conum" data-value="1"></i>
    "avg":{
      "script": { <a id="CO542-2"></a><i class="conum" data-value="2"></i>
        "source": """
          ZonedDateTime date =  doc['@timestamp'].value; <a id="CO542-3"></a><i class="conum" data-value="3"></i>
          return date.getHour(); <a id="CO542-4"></a><i class="conum" data-value="4"></i>
        """
      }
    }
  },
  "avg_month_of_year": { <a id="CO542-5"></a><i class="conum" data-value="5"></i>
    "avg":{
      "script": { <a id="CO542-6"></a><i class="conum" data-value="6"></i>
        "source": """
          ZonedDateTime date =  doc['@timestamp'].value; <a id="CO542-7"></a><i class="conum" data-value="7"></i>
          return date.getMonthValue(); <a id="CO542-8"></a><i class="conum" data-value="8"></i>
        """
      }
    }
  },
 ...
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO542-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Name of the aggregation.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO542-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>Contains the Painless script that returns the hour of the day.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO542-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>Sets <code class="literal">date</code> based on the timestamp of the document.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO542-4"><i class="conum" data-value="4"></i></a></p>
</td>
<td align="left" valign="top">
<p>Returns the hour value from <code class="literal">date</code>.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO542-5"><i class="conum" data-value="5"></i></a></p>
</td>
<td align="left" valign="top">
<p>Name of the aggregation.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO542-6"><i class="conum" data-value="6"></i></a></p>
</td>
<td align="left" valign="top">
<p>Contains the Painless script that returns the month of the year.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO542-7"><i class="conum" data-value="7"></i></a></p>
</td>
<td align="left" valign="top">
<p>Sets <code class="literal">date</code> based on the timestamp of the document.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO542-8"><i class="conum" data-value="8"></i></a></p>
</td>
<td align="left" valign="top">
<p>Returns the month value from <code class="literal">date</code>.</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="painless-bucket-script"></a>Getting duration by using bucket script<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/painless-examples.asciidoc">edit</a></h3>
</div></div></div>
<p>This example shows you how to get the duration of a session by client IP from a
data log by using
<a class="xref" href="search-aggregations-pipeline.html#search-aggregations-pipeline-bucket-script-aggregation" title="Bucket script aggregation">bucket script</a>.
The example uses the Kibana sample web logs dataset.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT _transform/data_log
{
  "source": {
    "index": "kibana_sample_data_logs"
  },
  "dest": {
    "index": "data-logs-by-client"
  },
  "pivot": {
    "group_by": {
      "machine.os": {"terms": {"field": "machine.os.keyword"}},
      "machine.ip": {"terms": {"field": "clientip"}}
    },
    "aggregations": {
      "time_frame.lte": {
        "max": {
          "field": "timestamp"
        }
      },
      "time_frame.gte": {
        "min": {
          "field": "timestamp"
        }
      },
      "time_length": { <a id="CO543-1"></a><i class="conum" data-value="1"></i>
        "bucket_script": {
          "buckets_path": { <a id="CO543-2"></a><i class="conum" data-value="2"></i>
            "min": "time_frame.gte.value",
            "max": "time_frame.lte.value"
          },
          "script": "params.max - params.min" <a id="CO543-3"></a><i class="conum" data-value="3"></i>
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1688.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO543-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>To define the length of the sessions, we use a bucket script.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO543-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>The bucket path is a map of script variables and their associated path to
the buckets you want to use for the variable. In this particular case, <code class="literal">min</code> and
<code class="literal">max</code> are variables mapped to <code class="literal">time_frame.gte.value</code> and <code class="literal">time_frame.lte.value</code>.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO543-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>Finally, the script substracts the start date of the session from the end
date which results in the duration of the session.</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="painless-count-http"></a>Counting HTTP responses by using scripted metric aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/painless-examples.asciidoc">edit</a></h3>
</div></div></div>
<p>You can count the different HTTP response types in a web log data set by using
scripted metric aggregation as part of the transform. You can achieve a
similar function with filter aggregations, check the
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.9/transform-examples.html#example-clientips" class="ulink" target="_top">Finding suspicious client IPs</a>
example for details.</p>
<p>The example below assumes that the HTTP response codes are stored as keywords in
the <code class="literal">response</code> field of the documents.</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">"aggregations": { <a id="CO544-1"></a><i class="conum" data-value="1"></i>
  "responses.counts": { <a id="CO544-2"></a><i class="conum" data-value="2"></i>
    "scripted_metric": { <a id="CO544-3"></a><i class="conum" data-value="3"></i>
      "init_script": "state.responses = ['error':0L,'success':0L,'other':0L]", <a id="CO544-4"></a><i class="conum" data-value="4"></i>
      "map_script": """ <a id="CO544-5"></a><i class="conum" data-value="5"></i>
        def code = doc['response.keyword'].value;
        if (code.startsWith('5') || code.startsWith('4')) {
          state.responses.error += 1 ;
        } else if(code.startsWith('2')) {
          state.responses.success += 1;
        } else {
          state.responses.other += 1;
        }
        """,
      "combine_script": "state.responses", <a id="CO544-6"></a><i class="conum" data-value="6"></i>
      "reduce_script": """ <a id="CO544-7"></a><i class="conum" data-value="7"></i>
        def counts = ['error': 0L, 'success': 0L, 'other': 0L];
        for (responses in states) {
          counts.error += responses['error'];
          counts.success += responses['success'];
          counts.other += responses['other'];
        }
        return counts;
        """
      }
    },
  ...
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO544-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">aggregations</code> object of the transform that contains all aggregations.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO544-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>Object of the <code class="literal">scripted_metric</code> aggregation.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO544-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>This <code class="literal">scripted_metric</code> performs a distributed operation on the web log data
to count specific types of HTTP responses (error, success, and other).</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO544-4"><i class="conum" data-value="4"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">init_script</code> creates a <code class="literal">responses</code> array in the <code class="literal">state</code> object with
three properties (<code class="literal">error</code>, <code class="literal">success</code>, <code class="literal">other</code>) with long data type.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO544-5"><i class="conum" data-value="5"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">map_script</code> defines <code class="literal">code</code> based on the <code class="literal">response.keyword</code> value of the
document, then it counts the errors, successes, and other responses based on the
first digit of the responses.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO544-6"><i class="conum" data-value="6"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">combine_script</code> returns <code class="literal">state.responses</code> from each shard.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO544-7"><i class="conum" data-value="7"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">reduce_script</code> creates a <code class="literal">counts</code> array with the <code class="literal">error</code>, <code class="literal">success</code>,
and <code class="literal">other</code> properties, then iterates through the value of <code class="literal">responses</code> returned
by each shard and assigns the different response types to the appropriate
properties of the <code class="literal">counts</code> object; error responses to the error counts, success
responses to the success counts, and other responses to the other counts.
Finally, returns the <code class="literal">counts</code> array with the response counts.</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="painless-compare"></a>Comparing indices by using scripted metric aggregations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/painless-examples.asciidoc">edit</a></h3>
</div></div></div>
<p>This example shows how to compare the content of two indices by a transform
that uses a scripted metric aggregation.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST _transform/_preview
{
  "id" : "index_compare",
  "source" : { <a id="CO545-1"></a><i class="conum" data-value="1"></i>
    "index" : [
      "index1",
      "index2"
    ],
    "query" : {
      "match_all" : { }
    }
  },
  "dest" : { <a id="CO545-2"></a><i class="conum" data-value="2"></i>
    "index" : "compare"
  },
  "pivot" : {
    "group_by" : {
      "unique-id" : {
        "terms" : {
          "field" : "&lt;unique-id-field&gt;" <a id="CO545-3"></a><i class="conum" data-value="3"></i>
        }
      }
    },
    "aggregations" : {
      "compare" : { <a id="CO545-4"></a><i class="conum" data-value="4"></i>
        "scripted_metric" : {
          "map_script" : "state.doc = new HashMap(params['_source'])", <a id="CO545-5"></a><i class="conum" data-value="5"></i>
          "combine_script" : "return state", <a id="CO545-6"></a><i class="conum" data-value="6"></i>
          "reduce_script" : """ <a id="CO545-7"></a><i class="conum" data-value="7"></i>
            if (states.size() != 2) {
              return "count_mismatch"
            }
            if (states.get(0).equals(states.get(1))) {
              return "match"
            } else {
              return "mismatch"
            }
            """
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1689.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO545-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The indices referenced in the <code class="literal">source</code> object are compared to each other.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO545-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">dest</code> index contains the results of the comparison.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO545-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">group_by</code> field needs to be a unique identifier for each document.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO545-4"><i class="conum" data-value="4"></i></a></p>
</td>
<td align="left" valign="top">
<p>Object of the <code class="literal">scripted_metric</code> aggregation.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO545-5"><i class="conum" data-value="5"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">map_script</code> defines <code class="literal">doc</code> in the state object. By using
<code class="literal">new HashMap(...)</code> you copy the source document, this is important whenever you
want to pass the full source object from one phase to the next.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO545-6"><i class="conum" data-value="6"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">combine_script</code> returns <code class="literal">state</code> from each shard.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO545-7"><i class="conum" data-value="7"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">reduce_script</code> checks if the size of the indices are equal. If they are
not equal, than it reports back a <code class="literal">count_mismatch</code>. Then it iterates through all
the values of the two indices and compare them. If the values are equal, then it
returns a <code class="literal">match</code>, otherwise returns a <code class="literal">mismatch</code>.</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="painless-web-session"></a>Getting web session details by using scripted metric aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/painless-examples.asciidoc">edit</a></h3>
</div></div></div>
<p>This example shows how to derive multiple features from a single transaction.
Let&#8217;s take a look on the example source document from the data:</p>
<details open>
<summary class="title">Source document</summary>
<div class="content">
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "_index":"apache-sessions",
  "_type":"_doc",
  "_id":"KvzSeGoB4bgw0KGbE3wP",
  "_score":1.0,
  "_source":{
    "@timestamp":1484053499256,
    "apache":{
      "access":{
        "sessionid":"571604f2b2b0c7b346dc685eeb0e2306774a63c2",
        "url":"http://www.leroymerlin.fr/v3/search/search.do?keyword=Carrelage%20salle%20de%20bain",
        "path":"/v3/search/search.do",
        "query":"keyword=Carrelage%20salle%20de%20bain",
        "referrer":"http://www.leroymerlin.fr/v3/p/produits/carrelage-parquet-sol-souple/carrelage-sol-et-mur/decor-listel-et-accessoires-carrelage-mural-l1308217717?resultOffset=0&amp;resultLimit=51&amp;resultListShape=MOSAIC&amp;priceStyle=SALEUNIT_PRICE",
        "user_agent":{
          "original":"Mobile Safari 10.0 Mac OS X (iPad) Apple Inc.",
          "os_name":"Mac OS X (iPad)"
        },
        "remote_ip":"0337b1fa-5ed4-af81-9ef4-0ec53be0f45d",
        "geoip":{
          "country_iso_code":"FR",
          "location":{
            "lat":48.86,
            "lon":2.35
          }
        },
        "response_code":200,
        "method":"GET"
      }
    }
  }
}
...</pre>
</div>
</div>
</details>
<p>By using the <code class="literal">sessionid</code> as a group-by field, you are able to enumerate events
through the session and get more details of the session by using scripted metric
aggregation.</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">POST _transform/_preview
{
  "source": {
    "index": "apache-sessions"
  },
  "pivot": {
    "group_by": {
      "sessionid": { <a id="CO546-1"></a><i class="conum" data-value="1"></i>
        "terms": {
          "field": "apache.access.sessionid"
        }
      }
    },
    "aggregations": { <a id="CO546-2"></a><i class="conum" data-value="2"></i>
      "distinct_paths": {
        "cardinality": {
          "field": "apache.access.path"
        }
      },
      "num_pages_viewed": {
        "value_count": {
          "field": "apache.access.url"
        }
      },
      "session_details": {
        "scripted_metric": {
          "init_script": "state.docs = []", <a id="CO546-3"></a><i class="conum" data-value="3"></i>
          "map_script": """ <a id="CO546-4"></a><i class="conum" data-value="4"></i>
            Map span = [
              '@timestamp':doc['@timestamp'].value,
              'url':doc['apache.access.url'].value,
              'referrer':doc['apache.access.referrer'].value
            ];
            state.docs.add(span)
          """,
          "combine_script": "return state.docs;", <a id="CO546-5"></a><i class="conum" data-value="5"></i>
          "reduce_script": """ <a id="CO546-6"></a><i class="conum" data-value="6"></i>
            def all_docs = [];
            for (s in states) {
              for (span in s) {
                all_docs.add(span);
              }
            }
            all_docs.sort((HashMap o1, HashMap o2)-&gt;o1['@timestamp'].toEpochMilli().compareTo(o2['@timestamp'].toEpochMilli()));
            def size = all_docs.size();
            def min_time = all_docs[0]['@timestamp'];
            def max_time = all_docs[size-1]['@timestamp'];
            def duration = max_time.toEpochMilli() - min_time.toEpochMilli();
            def entry_page = all_docs[0]['url'];
            def exit_path = all_docs[size-1]['url'];
            def first_referrer = all_docs[0]['referrer'];
            def ret = new HashMap();
            ret['first_time'] = min_time;
            ret['last_time'] = max_time;
            ret['duration'] = duration;
            ret['entry_page'] = entry_page;
            ret['exit_path'] = exit_path;
            ret['first_referrer'] = first_referrer;
            return ret;
          """
        }
      }
    }
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO546-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The data is grouped by <code class="literal">sessionid</code>.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO546-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>The aggregations counts the number of paths and enumerate the viewed pages
during the session.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO546-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">init_script</code> creates an array type <code class="literal">doc</code> in the <code class="literal">state</code> object.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO546-4"><i class="conum" data-value="4"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">map_script</code> defines a <code class="literal">span</code> array with a timestamp, a URL, and a
referrer value which are based on the corresponding values of the document, then
adds the value of the <code class="literal">span</code> array to the <code class="literal">doc</code> object.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO546-5"><i class="conum" data-value="5"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">combine_script</code> returns <code class="literal">state.docs</code> from each shard.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO546-6"><i class="conum" data-value="6"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">reduce_script</code> defines various objects like <code class="literal">min_time</code>, <code class="literal">max_time</code>, and
<code class="literal">duration</code> based on the document fields, then declares a <code class="literal">ret</code> object, and
copies the source document by using <code class="literal">new HashMap ()</code>. Next, the script defines
<code class="literal">first_time</code>, <code class="literal">last_time</code>, <code class="literal">duration</code> and other fields inside the <code class="literal">ret</code> object
based on the corresponding object defined earlier, finally returns <code class="literal">ret</code>.</p>
</td>
</tr>
</table>
</div>
<p>The API call results in a similar response:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "num_pages_viewed" : 2.0,
  "session_details" : {
    "duration" : 100300001,
    "first_referrer" : "https://www.bing.com/",
    "entry_page" : "http://www.leroymerlin.fr/v3/p/produits/materiaux-menuiserie/porte-coulissante-porte-interieure-escalier-et-rambarde/barriere-de-securite-l1308218463",
    "first_time" : "2017-01-10T21:22:52.982Z",
    "last_time" : "2017-01-10T21:25:04.356Z",
    "exit_path" : "http://www.leroymerlin.fr/v3/p/produits/materiaux-menuiserie/porte-coulissante-porte-interieure-escalier-et-rambarde/barriere-de-securite-l1308218463?__result-wrapper?pageTemplate=Famille%2FMat%C3%A9riaux+et+menuiserie&amp;resultOffset=0&amp;resultLimit=50&amp;resultListShape=PLAIN&amp;nomenclatureId=17942&amp;priceStyle=SALEUNIT_PRICE&amp;fcr=1&amp;*4294718806=4294718806&amp;*14072=14072&amp;*4294718593=4294718593&amp;*17942=17942"
  },
  "distinct_paths" : 1.0,
  "sessionid" : "000046f8154a80fd89849369c984b8cc9d795814"
},
{
  "num_pages_viewed" : 10.0,
  "session_details" : {
    "duration" : 343100405,
    "first_referrer" : "https://www.google.fr/",
    "entry_page" : "http://www.leroymerlin.fr/",
    "first_time" : "2017-01-10T16:57:39.937Z",
    "last_time" : "2017-01-10T17:03:23.049Z",
    "exit_path" : "http://www.leroymerlin.fr/v3/p/produits/porte-de-douche-coulissante-adena-e168578"
  },
  "distinct_paths" : 8.0,
  "sessionid" : "000087e825da1d87a332b8f15fa76116c7467da6"
}
...</pre>
</div>
</div>

</div>

<div class="section xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="transform-limitations"></a>Transform limitations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/limitations.asciidoc">edit</a></h2>
</div></div></div>

<p>The following limitations and known problems apply to the 8.9.2 release of
the Elastic transform feature. The limitations are grouped into the following
categories:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<a class="xref" href="transforms.html#transform-config-limitations" title="Configuration limitations">Configuration limitations</a> apply to the configuration process of the
transforms.
</li>
<li class="listitem">
<a class="xref" href="transforms.html#transform-operational-limitations" title="Operational limitations">Operational limitations</a> affect the behavior of the transforms
that are running.
</li>
<li class="listitem">
<a class="xref" href="transforms.html#transform-ui-limitations" title="Limitations in Kibana">Limitations in Kibana</a> only apply to transforms managed via the user
interface.
</li>
</ul>
</div>
<h4><a id="transform-config-limitations"></a>Configuration limitations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/limitations.asciidoc">edit</a></h4>
<h5><a id="transforms-underscore-limitation"></a>Field names prefixed with underscores are omitted from latest transforms<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/limitations.asciidoc">edit</a></h5>
<p>If you use the <code class="literal">latest</code> type of transform and the source index has field names
that start with an underscore (_) character, they are assumed to be internal
fields. Those fields are omitted from the documents in the destination index.</p>
<h5><a id="transforms-ccs-limitation"></a>Transforms support cross-cluster search if the remote cluster is configured properly<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/limitations.asciidoc">edit</a></h5>
<p>If you use <a class="xref" href="modules-cross-cluster-search.html" title="Search across clusters">cross-cluster search</a>, the remote cluster must
support the search and aggregations you use in your transforms.
Transforms validate their configuration; if you use cross-cluster search and the
validation fails, make sure that the remote cluster supports the query and
aggregations you use.</p>
<h5><a id="transform-painless-limitation"></a>Using scripts in transforms<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/limitations.asciidoc">edit</a></h5>
<p>Transforms support scripting in every case when aggregations support them.
However, there are certain factors you might want to consider when using scripts
in transforms:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Transforms cannot deduce index mappings for output fields when the
fields are created by a script. In this case, you might want to create the
mappings of the destination index yourself prior to creating the transform.
</li>
<li class="listitem">
Scripted fields may increase the runtime of the transform.
</li>
<li class="listitem">
Transforms cannot optimize queries when you use scripts for all the
groupings defined in <code class="literal">group_by</code>, you will receive a warning message when you
use scripts this way.
</li>
</ul>
</div>
<h5><a id="transform-painless-warning-limitation"></a>Deprecation warnings for Painless scripts in transforms<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/limitations.asciidoc">edit</a></h5>
<p>If a transform contains Painless scripts that use deprecated syntax,
deprecation warnings are displayed when the transform is previewed or started.
However, it is not possible to check for deprecation warnings across all
transforms as a bulk action because running the required queries might be a
resource intensive process. Therefore any deprecation warnings due to deprecated
Painless syntax are not available in the Upgrade Assistant.</p>
<h5><a id="transform-runtime-field-limitation"></a>Transforms perform better on indexed fields<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/limitations.asciidoc">edit</a></h5>
<p>Transforms sort data by a user-defined time field, which is frequently
accessed. If the time field is a <a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.9/runtime.html" class="ulink" target="_top">runtime field</a>, the
performance impact of calculating field values at query time can significantly
slow the transform. Use an indexed field as a time field when using
transforms.</p>
<h5><a id="transform-scheduling-limitations"></a>Continuous transform scheduling limitations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/limitations.asciidoc">edit</a></h5>
<p>A continuous transform periodically checks for changes to source data. The functionality
of the scheduler is currently limited to a basic periodic timer which can be
within the <code class="literal">frequency</code> range from 1s to 1h. The default is 1m. This is designed
to run little and often. When choosing a <code class="literal">frequency</code> for this timer consider
your ingest rate along with the impact that the transform
search/index operations has other users in your cluster. Also note that retries
occur at <code class="literal">frequency</code> interval.</p>
<h4><a id="transform-operational-limitations"></a>Operational limitations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/limitations.asciidoc">edit</a></h4>
<h5><a id="transform-aggresponse-limitations"></a>Aggregation responses may be incompatible with destination index mappings<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/limitations.asciidoc">edit</a></h5>
<p>When a pivot transform is first started, it will deduce the mappings
required for the destination index. This process is based on the field types of
the source index and the aggregations used. If the fields are derived from
<a class="xref" href="search-aggregations-metrics.html#search-aggregations-metrics-scripted-metric-aggregation" title="Scripted metric aggregation"><code class="literal">scripted_metrics</code></a>
or <a class="xref" href="search-aggregations-pipeline.html#search-aggregations-pipeline-bucket-script-aggregation" title="Bucket script aggregation"><code class="literal">bucket_scripts</code></a>,
<a class="xref" href="dynamic-mapping.html" title="Dynamic mapping">dynamic mappings</a> will be used. In some instances the
deduced mappings may be incompatible with the actual data. For example, numeric
overflows might occur or dynamically mapped fields might contain both numbers
and strings. Please check Elasticsearch logs if you think this may have occurred.</p>
<p>You can view the deduced mappings by using the
<a class="xref" href="transform-apis.html#preview-transform" title="Preview transform API">preview transform API</a>.
See the <code class="literal">generated_dest_index</code> object in the API response.</p>
<p>If it&#8217;s required, you may define custom mappings prior to starting the
transform by creating a custom destination index using the
<a class="xref" href="indices.html#indices-create-index" title="Create index API">create index API</a>.
As deduced mappings cannot be overwritten by an index template, use the create
index API to define custom mappings. The index templates only apply to fields
derived from scripts that use dynamic mappings.</p>
<h5><a id="transform-batch-limitations"></a>Batch transforms may not account for changed documents<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/limitations.asciidoc">edit</a></h5>
<p>A batch transform uses a
<a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-composite-aggregation" title="Composite aggregation">composite aggregation</a>
which allows efficient pagination through all buckets. Composite aggregations
do not yet support a search context, therefore if the source data is changed
(deleted, updated, added) while the batch data frame is in progress, then the
results may not include these changes.</p>
<h5><a id="transform-consistency-limitations"></a>Continuous transform consistency does not account for deleted or updated documents<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/limitations.asciidoc">edit</a></h5>
<p>While the process for transforms allows the continual recalculation of the
transform as new data is being ingested, it does also have some limitations.</p>
<p>Changed entities will only be identified if their time field has also been
updated and falls within the range of the action to check for changes. This has
been designed in principle for, and is suited to, the use case where new data is
given a timestamp for the time of ingest.</p>
<p>If the indices that fall within the scope of the source index pattern are
removed, for example when deleting historical time-based indices, then the
composite aggregation performed in consecutive checkpoint processing will search
over different source data, and entities that only existed in the deleted index
will not be removed from the data frame destination index.</p>
<p>Depending on your use case, you may wish to recreate the transform entirely
after deletions. Alternatively, if your use case is tolerant to historical
archiving, you may wish to include a max ingest timestamp in your aggregation.
This will allow you to exclude results that have not been recently updated when
viewing the destination index.</p>
<h5><a id="transform-deletion-limitations"></a>Deleting a transform does not delete the destination index or Kibana index pattern<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/limitations.asciidoc">edit</a></h5>
<p>When deleting a transform using <code class="literal">DELETE _transform/index</code>
neither the destination index nor the Kibana index pattern, should one have been
created, are deleted. These objects must be deleted separately.</p>
<h5><a id="transform-aggregation-page-limitations"></a>Handling dynamic adjustment of aggregation page size<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/limitations.asciidoc">edit</a></h5>
<p>During the development of transforms, control was favoured over performance.
In the design considerations, it is preferred for the transform to take longer
to complete quietly in the background rather than to finish quickly and take
precedence in resource consumption.</p>
<p>Composite aggregations are well suited for high cardinality data enabling
pagination through results. If a <a class="xref" href="settings.html#circuit-breaker" title="Circuit breaker settings">circuit breaker</a> memory
exception occurs when performing the composite aggregated search then we try
again reducing the number of buckets requested. This circuit breaker is
calculated based upon all activity within the cluster, not just activity from
transforms, so it therefore may only be a temporary resource
availability issue.</p>
<p>For a batch transform, the number of buckets requested is only ever adjusted
downwards. The lowering of value may result in a longer duration for the
transform checkpoint to complete. For continuous transforms, the number of buckets
requested is reset back to its default at the start of every checkpoint and it
is possible for circuit breaker exceptions to occur repeatedly in the Elasticsearch logs.</p>
<p>The transform retrieves data in batches which means it calculates several
buckets at once. Per default this is 500 buckets per search/index operation. The
default can be changed using <code class="literal">max_page_search_size</code> and the minimum value is 10.
If failures still occur once the number of buckets requested has been reduced to
its minimum, then the transform will be set to a failed state.</p>
<h5><a id="transform-dynamic-adjustments-limitations"></a>Handling dynamic adjustments for many terms<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/limitations.asciidoc">edit</a></h5>
<p>For each checkpoint, entities are identified that have changed since the last
time the check was performed. This list of changed entities is supplied as a
<a class="xref" href="term-level-queries.html#query-dsl-terms-query" title="Terms query">terms query</a> to the transform composite aggregation,
one page at a time. Then updates are applied to the destination index for each
page of entities.</p>
<p>The page <code class="literal">size</code> is defined by <code class="literal">max_page_search_size</code> which is also used to
define the number of buckets returned by the composite aggregation search. The
default value is 500, the minimum is 10.</p>
<p>The index setting <a class="xref" href="index-modules.html#dynamic-index-settings" title="Dynamic index settings"><code class="literal">index.max_terms_count</code></a> defines
the maximum number of terms that can be used in a terms query. The default value
is 65536. If <code class="literal">max_page_search_size</code> exceeds <code class="literal">index.max_terms_count</code> the
transform will fail.</p>
<p>Using smaller values for <code class="literal">max_page_search_size</code> may result in a longer duration
for the transform checkpoint to complete.</p>
<h5><a id="transform-failed-limitations"></a>Handling of failed transforms<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/limitations.asciidoc">edit</a></h5>
<p>Failed transforms remain as a persistent task and should be handled
appropriately, either by deleting it or by resolving the root cause of the
failure and re-starting.</p>
<p>When using the API to delete a failed transform, first stop it using
<code class="literal">_stop?force=true</code>, then delete it.</p>
<h5><a id="transform-availability-limitations"></a>Continuous transforms may give incorrect results if documents are not yet available to search<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/limitations.asciidoc">edit</a></h5>
<p>After a document is indexed, there is a very small delay until it is available
to search.</p>
<p>A continuous transform periodically checks for changed entities between the time since
it last checked and <code class="literal">now</code> minus <code class="literal">sync.time.delay</code>. This time window moves
without overlapping. If the timestamp of a recently indexed document falls
within this time window but this document is not yet available to search then
this entity will not be updated.</p>
<p>If using a <code class="literal">sync.time.field</code> that represents the data ingest time and using a
zero second or very small <code class="literal">sync.time.delay</code>, then it is more likely that this
issue will occur.</p>
<h5><a id="transform-date-nanos"></a>Support for date nanoseconds data type<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/limitations.asciidoc">edit</a></h5>
<p>If your data uses the <a class="xref" href="mapping-types.html#date_nanos" title="Date nanoseconds field type">date nanosecond data type</a>, aggregations
are nonetheless on millisecond resolution. This limitation also affects the
aggregations in your transforms.</p>
<h5><a id="transform-data-streams-destination"></a>Data streams as destination indices are not supported<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/limitations.asciidoc">edit</a></h5>
<p>Transforms update data in the destination index which requires writing
into the destination. <a class="xref" href="data-streams.html" title="Data streams"><em>Data streams</em></a> are designed to be append-only, which
means you cannot send update or delete requests directly to a data stream. For
this reason, data streams are not supported as destination indices for
transforms.</p>
<h5><a id="transform-ilm-destination"></a>ILM as destination index may cause duplicated documents<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/limitations.asciidoc">edit</a></h5>
<p><a class="xref" href="index-lifecycle-management.html" title="ILM: Manage the index lifecycle">ILM</a> is not recommended to use as a transform
destination index. Transforms update documents in the current destination,
and cannot delete documents in the indices previously used by ILM. This may lead
to duplicated documents when you use transforms combined with ILM in case of a
rollover.</p>
<p>If you use ILM to have time-based indices, please consider using the
<a class="xref" href="processors.html#date-index-name-processor" title="Date index name processor">Date index name</a> instead. The processor works without duplicated
documents if your transform contains a <code class="literal">group_by</code> based on <code class="literal">date_histogram</code>.</p>
<h4><a id="transform-ui-limitations"></a>Limitations in Kibana<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/limitations.asciidoc">edit</a></h4>
<h5><a id="transform-space-limitations"></a>Transforms are visible in all Kibana spaces<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/limitations.asciidoc">edit</a></h5>
<p><a href="https://www.elastic.co/guide/en/kibana/8.9/xpack-spaces.html" class="ulink" target="_top">Spaces</a> enable you to organize your source and
destination indices and other saved objects in Kibana and to see only the objects
that belong to your space. However, a transform is a long running task which
is managed on cluster level and therefore not limited in scope to certain
spaces. Space awareness can be implemented for a data view under
<span class="strong strong"><strong>Stack Management &gt; Kibana</strong></span> which allows privileges to the transform
destination index.</p>
<h5><a id="transform-kibana-limitations"></a>Up to 1,000 transforms are listed in Kibana<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/limitations.asciidoc">edit</a></h5>
<p>The transforms management page in Kibana lists up to 1000 transforms.</p>
<h5><a id="transform-ui-support"></a>Kibana might not support every transform configuration option<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/transform/limitations.asciidoc">edit</a></h5>
<p>There might be configuration options available via the transform APIs that are
not supported in Kibana. For an exhaustive list of configuration options, refer
to the <a class="xref" href="transform-apis.html" title="Transform APIs">documentation</a>.</p>
</div>

</div>
<div class="navfooter">
<span class="prev">
<a href="xpack-rollup.html">« Rolling up historical data</a>
</span>
<span class="next">
<a href="high-availability.html">Set up a cluster for high availability »</a>
</span>
</div>
</div>
</body>
</html>
