<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Transforming data | Elasticsearch Guide | Elastic</title>
<meta class="elastic" name="content" content="Transforming data | Elasticsearch Guide">

<link rel="home" href="index.html" title="Elasticsearch Guide"/>
<link rel="up" href="data-rollup-transform.html" title="Roll up or transform your data"/>
<link rel="prev" href="xpack-rollup.html" title="Rolling up historical data"/>
<link rel="next" href="high-availability.html" title="Set up a cluster for high availability"/>
<meta class="elastic" name="product_version" content=""/>
<meta class="elastic" name="product_name" content=""/>
<meta class="elastic" name="website_area" content="documentation"/>
<meta name="DC.type" content="Learn/Docs/"/>
<meta name="DC.subject" content=""/>
<meta name="DC.identifier" content=""/>
</head>
<body>
<div id="content">
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="/guide/">Elastic Docs</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="index.html">Elasticsearch Guide</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="data-rollup-transform.html">Roll up or transform your data</a></span>
</div>
<div class="navheader">
<span class="prev">
<a href="xpack-rollup.html">« Rolling up historical data</a>
</span>
<span class="next">
<a href="high-availability.html">Set up a cluster for high availability »</a>
</span>
</div>
<div class="chapter xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="transforms"></a>Transforming data<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/transforms.asciidoc">edit</a><a class="xpack_tag" href="/subscriptions"></a></h2>
</div></div></div>
<p>Transforms enable you to convert existing Elasticsearch indices into summarized
indices, which provide opportunities for new insights and analytics.
For example, you can use transforms to pivot your data into entity-centric
indices that summarize the behavior of users or sessions or other entities in
your data.</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<a class="xref" href="transforms.html#transform-overview" title="Transform overview">Overview</a>
</li>
<li class="listitem">
<a class="xref" href="transforms.html#transform-setup" title="Set up transforms">Setup</a>
</li>
<li class="listitem">
<a class="xref" href="transforms.html#transform-usage" title="When to use transforms">When to use transforms</a>
</li>
<li class="listitem">
<a class="xref" href="transforms.html#transform-scale" title="Working with transforms at scale">Transforms at scale</a>
</li>
<li class="listitem">
<a class="xref" href="transforms.html#transform-checkpoints" title="How transform checkpoints work">How checkpoints work</a>
</li>
<li class="listitem">
<a class="xref" href="transforms.html#transform-api-quickref" title="API quick reference">API quick reference</a>
</li>
<li class="listitem">
<a class="xref" href="transforms.html#ecommerce-transforms" title="Tutorial: Transforming the eCommerce sample data">Tutorial: Transforming the eCommerce sample data</a>
</li>
<li class="listitem">
<a class="xref" href="transforms.html#transform-examples" title="Transform examples">Examples</a>
</li>
<li class="listitem">
<a class="xref" href="transforms.html#transform-painless-examples" title="Painless examples for transforms">Painless examples</a>
</li>
<li class="listitem">
<a class="xref" href="transforms.html#transform-troubleshooting" title="Troubleshooting transforms">Troubleshooting</a>
</li>
<li class="listitem">
<a class="xref" href="transforms.html#transform-limitations" title="Transform limitations">Limitations</a>
</li>
</ul>
</div>
<div class="section xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="transform-overview"></a>Transform overview<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/overview.asciidoc">edit</a><a class="xpack_tag" href="/subscriptions"></a></h2>
</div></div></div>

<p>You can use transforms to <em>pivot</em> your data into a new entity-centric index.
By transforming and summarizing your data, it becomes possible to visualize and
analyze it in alternative and interesting ways.</p>
<p>A lot of Elasticsearch indices are organized as a stream of events: each event is an
individual document, for example a single item purchase. Transforms enable
you to summarize this data, bringing it into an organized, more
analysis-friendly format. For example, you can summarize all the purchases of a
single customer.</p>
<p>Transforms enable you to define a pivot, which is a set of
features that transform the index into a different, more digestible format.
Pivoting results in a summary of your data in a new index.</p>
<p>To define a pivot, first you select one or more fields that you will use to
group your data. You can select categorical fields (terms) and numerical fields
for grouping. If you use numerical fields, the field values are bucketed using
an interval that you specify.</p>
<p>The second step is deciding how you want to aggregate the grouped data. When
using aggregations, you practically ask questions about the index. There are
different types of aggregations, each with its own purpose and output. To learn
more about the supported aggregations and group-by fields, see
<a class="xref" href="transform-apis.html#put-transform" title="Create transform API">Create transform</a>.</p>
<p>As an optional step, you can also add a query to further limit the scope of the
aggregation.</p>
<p>The transform performs a composite aggregation that paginates through all the
data defined by the source index query. The output of the aggregation is stored
in a <em>destination index</em>. Each time the transform queries the source index, it
creates a <em>checkpoint</em>. You can decide whether you want the transform to run
once or continuously. A <em>batch transform</em> is a single operation that has a
single checkpoint. <em>Continuous transforms</em> continually increment and process
checkpoints as new source data is ingested.</p>
<p>Imagine that you run a webshop that sells clothes. Every order creates a
document that contains a unique order ID, the name and the category of the
ordered product, its price, the ordered quantity, the exact date of the order,
and some customer information (name, gender, location, etc). Your dataset
contains all the transactions from last year.</p>
<p>If you want to check the sales in the different categories in your last fiscal
year, define a transform that groups the data by the product categories
(women&#8217;s shoes, men&#8217;s clothing, etc.) and the order date. Use the last year as
the interval for the order date. Then add a sum aggregation on the ordered
quantity. The result is an entity-centric index that shows the number of sold
items in every product category in the last year.</p>
<div class="imageblock screenshot">
<div class="content">
<img src="images/pivot-preview.png" alt="Example of a transform pivot in Kibana">
</div>
</div>
<div class="important admon">
<div class="icon"></div>
<div class="admon_content">
<p>The transform leaves your source index intact. It
creates a new index that is dedicated to the transformed data.</p>
</div>
</div>
<h4><a id="transform-performance"></a>Performance considerations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/overview.asciidoc">edit</a></h4>
<p>Transforms perform search aggregations on the source indices then index
the results into the destination index. Therefore, a transform never takes
less time or uses less resources than the aggregation and indexing processes.</p>
<p>If your transform must process a lot of historic data, it has high resource
usage initially&#8212;&#8203;particularly during the first checkpoint.</p>
<p>For better performance, make sure that your search aggregations and queries are
optimized and that your transform is processing only necessary data. Consider
whether you can apply a source query to the transform to reduce the scope of
data it processes. Also consider whether the cluster has sufficient resources in
place to support both the composite aggregation search and the indexing of its
results.</p>
<p>If you prefer to spread out the impact on your cluster (at the cost of a slower
transform), you can throttle the rate at which it performs search and index
requests. Set the <code class="literal">docs_per_second</code> limit when you <a class="xref" href="transform-apis.html#put-transform" title="Create transform API">create</a> or
<a class="xref" href="transform-apis.html#update-transform" title="Update transform API">update</a> your transform. If you want to calculate the
current rate, use the following information from the
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.10/get-transform-stats.html" class="ulink" target="_top">get transform stats API</a>:</p>
<pre class="screen">documents_processed / search_time_in_ms * 1000</pre>
</div>

<div class="section xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="transform-setup"></a>Set up transforms<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/setup.asciidoc">edit</a><a class="xpack_tag" href="/subscriptions"></a></h2>
</div></div></div>

<p>To use the transforms, you must have the
<a href="https://www.elastic.co/subscriptions" class="ulink" target="_top">appropriate license</a> and at least one
<a class="xref" href="transforms.html#transform-setup-nodes" title="Transform nodes">transform node</a> in your Elasticsearch cluster. If Elastic Stack
security features are enabled, you must also ensure your users have the
<a class="xref" href="transforms.html#transform-privileges" title="Security privileges">necessary privileges</a>.</p>
<h4><a id="transform-setup-nodes"></a>Transform nodes<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/setup.asciidoc">edit</a></h4>
<p>To use transforms, there must be at least one transform node in your cluster.
If you want to control which nodes run transforms, add or remove <code class="literal">transform</code>
from the <code class="literal">node.roles</code> setting on some nodes. For more information, see
<a class="xref" href="settings.html#modules-node" title="Node">Node</a> and <a class="xref" href="settings.html#transform-settings" title="Transforms settings in Elasticsearch">Transforms settings</a>.</p>
<h4><a id="transform-privileges"></a>Security privileges<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/setup.asciidoc">edit</a></h4>
<p>The Elasticsearch security features provide <a class="xref" href="authorization.html#built-in-roles" title="Built-in roles">built-in roles</a>
and <a class="xref" href="authorization.html#security-privileges" title="Security privileges">privileges</a> that make it easier to control
which users can manage or view transforms.</p>
<p>To <em>view</em> the configuration and status of transforms, you must have:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<code class="literal">transform_user</code> built-in role or <code class="literal">monitor_transform</code>
cluster privileges
</li>
</ul>
</div>
<p>To <em>manage</em> transforms, you must have:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<code class="literal">transform_admin</code> built-in role or <code class="literal">manage_transform</code>
cluster privileges
</li>
<li class="listitem">
<code class="literal">read</code> and <code class="literal">view_index_metadata</code> index privileges on source indices
</li>
<li class="listitem">
<code class="literal">read</code>, <code class="literal">create_index</code>, and <code class="literal">index</code> index privileges on destination indices
</li>
</ul>
</div>
<p>For more information, see <a class="xref" href="authorization.html#security-privileges" title="Security privileges">Security privileges</a> and <a class="xref" href="authorization.html#built-in-roles" title="Built-in roles">Built-in roles</a>.</p>
</div>

<div class="section xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="transform-usage"></a>When to use transforms<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/usage.asciidoc">edit</a><a class="xpack_tag" href="/subscriptions"></a></h2>
</div></div></div>
<p>Elasticsearch aggregations are a powerful and flexible feature that enable you to
summarize and retrieve complex insights about your data. You can summarize
complex things like the number of web requests per day on a busy website, broken
down by geography and browser type. If you use the same data set to try to
calculate something as simple as a single number for the average duration of
visitor web sessions, however, you can quickly run out of memory.</p>
<p>Why does this occur? A web session duration is an example of a behavioral
attribute not held on any one log record; it has to be derived by finding the
first and last records for each session in our weblogs. This derivation requires
some complex query expressions and a lot of memory to connect all the data
points. If you have an ongoing background process that fuses related events from
one index into entity-centric summaries in another index, you get a more useful,
joined-up picture. This new index is sometimes referred to as a <em>data frame</em>.</p>
<p>You might want to consider using transforms instead of aggregations when:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<p>You need a complete <em>feature index</em> rather than a top-N set of items.</p>
<p>In machine learning, you often need a complete set of behavioral features rather just the
top-N. For example, if you are predicting customer churn, you might look at
features such as the number of website visits in the last week, the total number
of sales, or the number of emails sent. The Elastic Stack machine learning features create models
based on this multi-dimensional feature space, so they benefit from the full
feature indices that are created by transforms.</p>
<p>This scenario also applies when you are trying to search across the results of
an aggregation or multiple aggregations. Aggregation results can be ordered or
filtered, but there are
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.10/search-aggregations-bucket-terms-aggregation.html#search-aggregations-bucket-terms-aggregation-order" class="ulink" target="_top">limitations to ordering</a>
and
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.10/search-aggregations-pipeline-bucket-selector-aggregation.html" class="ulink" target="_top">filtering by bucket selector</a>
is constrained by the maximum number of buckets returned. If you want to search
all aggregation results, you need to create the complete data frame. If you
need to sort or filter the aggregation results by multiple fields, transforms
are particularly useful.</p>
</li>
<li class="listitem">
<p>You need to sort aggregation results by a pipeline aggregation.</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.10/search-aggregations-pipeline.html" class="ulink" target="_top">Pipeline aggregations</a> cannot be used
for sorting. Technically, this is because pipeline aggregations are run during
the reduce phase after all other aggregations have already completed. If you
create a transform, you can effectively perform multiple passes over the data.</p>
</li>
<li class="listitem">
<p>You want to create summary tables to optimize queries.</p>
<p>For example, if you
have a high level dashboard that is accessed by a large number of users and it
uses a complex aggregation over a large dataset, it may be more efficient to
create a transform to cache results. Thus, each user doesn&#8217;t need to run the
aggregation query.</p>
</li>
</ul>
</div>
</div>

<div class="section xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="transform-scale"></a>Working with transforms at scale<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/transforms-at-scale.asciidoc">edit</a><a class="xpack_tag" href="/subscriptions"></a></h2>
</div></div></div>

<p>Transforms convert existing Elasticsearch indices into summarized indices, which
provide opportunities for new insights and analytics. The search and index
operations performed by transforms use standard Elasticsearch features so similar
considerations for working with Elasticsearch at scale are often applicable to
transforms. If you experience performance issues, start by identifying the
bottleneck areas (search, indexing, processing, or storage) then review the
relevant considerations in this guide to improve performance. It also helps to
understand how transforms work as different considerations apply depending on
whether or not your transform is running in continuous mode or in batch.</p>
<p>In this guide, you’ll learn how to:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Understand the impact of configuration options on the performance of
transforms.
</li>
</ul>
</div>
<p><span class="strong strong"><strong>Prerequisites:</strong></span></p>
<p>These guildelines assume you have a transform you want to tune, and you’re
already familiar with:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<a class="xref" href="transforms.html#transform-overview" title="Transform overview">How transforms work</a>.
</li>
<li class="listitem">
<a class="xref" href="transforms.html#transform-setup" title="Set up transforms">How to set up transforms</a>.
</li>
<li class="listitem">
<a class="xref" href="transforms.html#transform-checkpoints" title="How transform checkpoints work">How transform checkpoints work in continuous mode</a>.
</li>
</ul>
</div>
<p>The following considerations are not sequential – the numbers help to navigate
between the list items; you can take action on one or more of them in any order.
Most of the recommendations apply to both continuous and batch transforms. If
a list item only applies to one transform type, this exception is highlighted
in the description.</p>
<p>The keywords in parenthesis at the end of each recommendation title indicates
the bottleneck area that may be improved by following the given recommendation.</p>
<h4><a id="measure-performance"></a>Measure transforms performance<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/transforms-at-scale.asciidoc">edit</a></h4>
<p>In order to optimize transform performance, start by identifying the areas
where most work is being done. The <span class="strong strong"><strong>Stats</strong></span> interface of the
<span class="strong strong"><strong>Transforms</strong></span> page in Kibana contains information that covers three main
areas: indexing, searching, and processing time (alternatively, you can use the
<a class="xref" href="transform-apis.html#get-transform-stats" title="Get transform statistics API">transforms stats API</a>). If, for example, the results
show that the highest proportion of  time is spent on search, then prioritize
efforts on optimizing the search query of the transform. Transforms also
has <a href="https://esrally.readthedocs.io" class="ulink" target="_top">Rally support</a> that makes it possible to run
performance checks on transforms configurations if it is required. If you
optimized the crucial factors and you still experience performance issues, you
may also want to consider improving your hardware.</p>
<h4><a id="frequency"></a>1. Optimize <code class="literal">frequency</code> (index)<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/transforms-at-scale.asciidoc">edit</a></h4>
<p>In a continuous transform, the <code class="literal">frequency</code> configuration option sets the interval
between checks for changes in the source indices. If changes are detected, then
the source data is searched and the changes are applied to the destination
index. Depending on your use case, you may wish to reduce the frequency at which
changes are applied. By setting <code class="literal">frequency</code> to a higher value (maximum is one
hour), the workload can be spread over time at the cost of less up-to-date data.</p>
<h4><a id="increase-shards-dest-index"></a>2. Increase the number of shards of the destination index (index)<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/transforms-at-scale.asciidoc">edit</a></h4>
<p>Depending on the size of the destination index, you may consider increasing its
shard count. Transforms use one shard by default when creating the
destination index. To override the index settings, create the destination index
before starting the transform. For more information about how the number of
shards affects scalability and resilience, refer to <a class="xref" href="elasticsearch-intro.html#scalability" title="Scalability and resilience: clusters, nodes, and shards">Scalability and resilience</a></p>
<div class="tip admon">
<div class="icon"></div>
<div class="admon_content">
<p>Use the <a class="xref" href="transform-apis.html#preview-transform" title="Preview transform API">Preview transform</a> to check the settings that the transform
would use to create the destination index. You can copy and adjust these in
order to create the destination index prior to starting the transform.</p>
</div>
</div>
<h4><a id="search-queries"></a>3. Profile and optimize your search queries (search)<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/transforms-at-scale.asciidoc">edit</a></h4>
<p>If you have defined a transform source index <code class="literal">query</code>, ensure it is as
efficient as possible. Use the <span class="strong strong"><strong>Search Profiler</strong></span> under <span class="strong strong"><strong>Dev Tools</strong></span> in Kibana
to get detailed timing information about the execution of individual components
in the search request. Alternatively, you can use the <a class="xref" href="search.html#search-profile" title="Profile API">Profile</a>. The
results give you insight into how search requests are executed at a low level so
that you can understand why certain requests are slow, and take steps to improve
them.</p>
<p>Transforms execute standard Elasticsearch search requests. There are different ways
to write Elasticsearch queries, and some of them are more efficient than others. Consult
<a class="xref" href="tune-for-search-speed.html" title="Tune for search speed"><em>Tune for search speed</em></a> to learn more about Elasticsearch performance tuning.</p>
<h4><a id="limit-source-query"></a>4. Limit the scope of the source query (search)<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/transforms-at-scale.asciidoc">edit</a></h4>
<p>Imagine your continuous transform is configured to group by <code class="literal">IP</code> and calculate the sum
of <code class="literal">bytes_sent</code>. For each checkpoint, a continuous transform detects changes in the
source data since the previous checkpoint, identifying the IPs for which new
data has been ingested. Then it performs a second search, filtered for this
group of IPs, in order to calculate the total <code class="literal">bytes_sent</code>. If this second
search matches many shards, then this could be resource intensive. Consider
limiting the scope that the source index pattern and query will match.</p>
<p>Use an absolute time value as a date range filter in your source query (for
example, greater than <code class="literal">2020-01-01T00:00:00</code>) to limit which historical indices
are accessed. If you use a relative time value (for example, <code class="literal">now-30d</code>) then
this date range is re-evaluated at the point of each checkpoint execution.</p>
<h4><a id="optimize-shading-strategy"></a>5. Optimize the sharding strategy for the source index (search)<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/transforms-at-scale.asciidoc">edit</a></h4>
<p>There is no one-size-fits-all sharding strategy. A strategy that works in one
environment may not scale in another. A good sharding strategy must account for
your infrastructure, use case, and performance expectations.</p>
<p>Too few shards may mean that the benefits of distributing the workload cannot be
realised; however too many shards may impact your cluster health. To learn more
about sizing your shards, read this <a class="xref" href="size-your-shards.html" title="How to size your shards">guide</a>.</p>
<h4><a id="tune-max-page-search-size"></a>6. Tune <code class="literal">max_page_search_size</code> (search)<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/transforms-at-scale.asciidoc">edit</a></h4>
<p>The <code class="literal">max_page_search_size</code> transform configuration option defines the number
of buckets that are returned for each search request. The default value is 500.
If you increase this value, you get better throughput at the cost of higher
latency and memory usage.</p>
<p>The ideal value of this parameter is highly dependent on your use case. If your
transform executes memory-intensive aggregations – for example, cardinality or
percentiles – then increasing <code class="literal">max_page_search_size</code> requires more available
memory. If memory limits are exceeded, a circuit breaker exception occurs.</p>
<h4><a id="indexed-fields-in-source"></a>7. Use indexed fields in your source indices (search)<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/transforms-at-scale.asciidoc">edit</a></h4>
<p>Scripted fields are not indexed fields; their values are only
computed at search time. While these fields provide flexibility in
how you access your data, they increase performance costs at search time. If
transform performance using scripted fields is a concern,
you may wish to consider using indexed fields instead.</p>
<h4><a id="index-sorting-group-by-ordering"></a>8. Use index sorting and <code class="literal">group_by</code> ordering (search, process)<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/transforms-at-scale.asciidoc">edit</a></h4>
<p>If you use more than one <code class="literal">group_by</code> field in your transform, then the order of
the fields in conjunction with the use of <a class="xref" href="index-modules-index-sorting.html" title="Index Sorting"><em>Index Sorting</em></a> may
improve runtime.</p>
<p>Index sorting enables you to store documents on disk in a specific order which
can improve query efficiency. The ideal sorting logic depends on your use case,
but the rule of thumb may be to sort the fields in descending order (high to low
cardinality) starting with the time-based fields. Then put the time-based
components first in the <code class="literal">group_by</code> if you have any, and then apply the same
order to your <code class="literal">group_by</code> fields as configured for index sorting. Index sorting
can be defined only once at index creation. If you don&#8217;t already have index
sorting on the index that you want to use as a source, consider reindexing it to
a new, sorted index.</p>
<h4><a id="disable-source-dest"></a>9. Disable the <code class="literal">_source</code> field on the destination index (storage)<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/transforms-at-scale.asciidoc">edit</a></h4>
<p>The <a class="xref" href="mapping-fields.html#mapping-source-field" title="_source field"><code class="literal">_source</code> field</a> contains the original JSON document body that was
passed at index time. The <code class="literal">_source</code> field itself is not indexed (and thus is not
searchable), but it is still stored in the index and incurs a storage overhead.
Consider disabling <code class="literal">_source</code> to save storage space if you have a large
destination index. Disabling <code class="literal">_source</code> is only possible during index creation.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>When the <code class="literal">_source</code> field is disabled, a number of features are not
supported. Consult <a class="xref" href="mapping-fields.html#disable-source-field" title="Disabling the _source field">Disabling the <code class="literal">_source</code> field</a> to understand the consequences
before disabling it.</p>
</div>
</div>
<h4><a id="_further_reading"></a>Further reading<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/transforms-at-scale.asciidoc">edit</a></h4>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<a class="xref" href="tune-for-search-speed.html" title="Tune for search speed"><em>Tune for search speed</em></a>
</li>
<li class="listitem">
<a class="xref" href="tune-for-indexing-speed.html" title="Tune for indexing speed"><em>Tune for indexing speed</em></a>
</li>
<li class="listitem">
<a class="xref" href="size-your-shards.html" title="How to size your shards"><em>Size your shards</em></a>
</li>
<li class="listitem">
<a class="xref" href="ilm-concepts.html#ilm-index-lifecycle" title="Index lifecycle">Index lifecycle</a>
</li>
</ul>
</div>
</div>

<div class="section xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="transform-checkpoints"></a>How transform checkpoints work<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/checkpoints.asciidoc">edit</a><a class="xpack_tag" href="/subscriptions"></a></h2>
</div></div></div>

<p>Each time a transform examines the source indices and creates or
updates the destination index, it generates a <em>checkpoint</em>.</p>
<p>If your transform runs only once, there is logically only one
checkpoint. If your transform runs continuously, however, it creates
checkpoints as it ingests and transforms new source data.</p>
<p>To create a checkpoint, the continuous transform:</p>
<div class="olist orderedlist">
<ol class="orderedlist">
<li class="listitem">
<p>Checks for changes to source indices.</p>
<p>Using a simple periodic timer, the transform checks for changes to
the source indices. This check is done based on the interval defined in the
transform&#8217;s <code class="literal">frequency</code> property.</p>
<p>If the source indices remain unchanged or if a checkpoint is already in progress
then it waits for the next timer.</p>
</li>
<li class="listitem">
<p>Identifies which entities have changed.</p>
<p>The transform searches to see which entities have changed since the
last time it checked. The <code class="literal">sync</code> configuration object in the transform
identifies a time field in the source indices. The transform uses the values
in that field to synchronize the source and destination indices.</p>
</li>
<li class="listitem">
<p>Updates the destination index (the data frame) with the changed entities.</p>
<p>The transform applies changes related to either new or changed
entities to the destination index. The set of changed entities is paginated. For
each page, the transform performs a composite aggregation using a
<code class="literal">terms</code> query. After all the pages of changes have been applied, the checkpoint
is complete.</p>
</li>
</ol>
</div>
<p>This checkpoint process involves both search and indexing activity on the
cluster. We have attempted to favor control over performance while developing
transforms. We decided it was preferable for the
transform to take longer to complete, rather than to finish quickly
and take precedence in resource consumption. That being said, the cluster still
requires enough resources to support both the composite aggregation search and
the indexing of its results.</p>
<div class="tip admon">
<div class="icon"></div>
<div class="admon_content">
<p>If the cluster experiences unsuitable performance degradation due to the
transform, stop the transform and refer to <a class="xref" href="transforms.html#transform-performance" title="Performance considerations">Performance considerations</a>.</p>
</div>
</div>
<h4><a id="ml-transform-checkpoint-errors"></a>Error handling<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/checkpoints.asciidoc">edit</a></h4>
<p>Failures in transforms tend to be related to searching or indexing.
To increase the resiliency of transforms, the cursor positions of
the aggregated search and the changed entities search are tracked in memory and
persisted periodically.</p>
<p>Checkpoint failures can be categorized as follows:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Temporary failures: The checkpoint is retried. If 10 consecutive failures
occur, the transform has a failed status. For example, this
situation might occur when there are shard failures and queries return only
partial results.
</li>
<li class="listitem">
Irrecoverable failures: The transform immediately fails. For
example, this situation occurs when the source index is not found.
</li>
<li class="listitem">
Adjustment failures: The transform retries with adjusted settings.
For example, if a parent circuit breaker memory errors occur during the
composite aggregation, the transform receives partial results. The aggregated
search is retried with a smaller number of buckets. This retry is performed at
the interval defined in the <code class="literal">frequency</code> property for the transform. If the
search is retried to the point where it reaches a minimal number of buckets, an
irrecoverable failure occurs.
</li>
</ul>
</div>
<p>If the node running the transforms fails, the transform restarts
from the most recent persisted cursor position. This recovery process might
repeat some of the work the transform had already done, but it ensures data
consistency.</p>
</div>

<div class="section xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="transform-api-quickref"></a>API quick reference<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/api-quickref.asciidoc">edit</a><a class="xpack_tag" href="/subscriptions"></a></h2>
</div></div></div>
<p>All transform endpoints have the following base:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">_transform/</pre>
</div>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<a class="xref" href="transform-apis.html#put-transform" title="Create transform API">Create transforms</a>
</li>
<li class="listitem">
<a class="xref" href="transform-apis.html#delete-transform" title="Delete transform API">Delete transforms</a>
</li>
<li class="listitem">
<a class="xref" href="transform-apis.html#get-transform" title="Get transforms API">Get transforms</a>
</li>
<li class="listitem">
<a class="xref" href="transform-apis.html#get-transform-stats" title="Get transform statistics API">Get transforms statistics</a>
</li>
<li class="listitem">
<a class="xref" href="transform-apis.html#preview-transform" title="Preview transform API">Preview transforms</a>
</li>
<li class="listitem">
<a class="xref" href="transform-apis.html#start-transform" title="Start transform API">Start transforms</a>
</li>
<li class="listitem">
<a class="xref" href="transform-apis.html#stop-transform" title="Stop transforms API">Stop transforms</a>
</li>
<li class="listitem">
<a class="xref" href="transform-apis.html#update-transform" title="Update transform API">Update transforms</a>
</li>
</ul>
</div>
<p>For the full list, see <a class="xref" href="transform-apis.html" title="Transform APIs"><em>Transform APIs</em></a>.</p>
</div>

<div class="section xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="ecommerce-transforms"></a>Tutorial: Transforming the eCommerce sample data<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/ecommerce-tutorial.asciidoc">edit</a><a class="xpack_tag" href="/subscriptions"></a></h2>
</div></div></div>
<p><a class="xref" href="transforms.html" title="Transforming data">Transforms</a> enable you to retrieve information
from an Elasticsearch index, transform it, and store it in another index. Let&#8217;s use the
<a href="https://www.elastic.co/guide/en/kibana/7.10/add-sample-data.html" class="ulink" target="_top">Kibana sample data</a> to demonstrate how you can
pivot and summarize your data with transforms.</p>
<div class="olist orderedlist">
<ol class="orderedlist">
<li class="listitem">
Verify that your environment is set up properly to use transforms. If the
Elasticsearch security features are enabled, to complete this tutorial you need a user
that has authority to preview and create transforms. You must also have
specific index privileges for the source and destination indices. See
<a class="xref" href="transforms.html#transform-setup" title="Set up transforms">Setup</a>.
</li>
<li class="listitem">
<p>Choose your <em>source index</em>.</p>
<p>In this example, we&#8217;ll use the eCommerce orders sample data. If you&#8217;re not
already familiar with the <code class="literal">kibana_sample_data_ecommerce</code> index, use the
<span class="strong strong"><strong>Revenue</strong></span> dashboard in Kibana to explore the data. Consider what insights you
might want to derive from this eCommerce data.</p>
</li>
<li class="listitem">
<p>Play with various options for grouping and aggregating the data.</p>
<p><em>Pivoting</em> your data involves using at least one field to group it and applying
at least one aggregation. You can preview what the transformed data will look
like, so go ahead and play with it! You can also enable histogram charts to get
a better understanding of the distribution of values in your data.</p>
<p>For example, you might want to group the data by product ID and calculate the
total number of sales for each product and its average price. Alternatively, you
might want to look at the behavior of individual customers and calculate how
much each customer spent in total and how many different categories of products
they purchased. Or you might want to take the currencies or geographies into
consideration. What are the most interesting ways you can transform and
interpret this data?</p>
<p>Go to <span class="strong strong"><strong>Management</strong></span> &gt; <span class="strong strong"><strong>Stack Management</strong></span> &gt; <span class="strong strong"><strong>Data</strong></span> &gt; <span class="strong strong"><strong>Transforms</strong></span> in Kibana and use
the wizard to create a transform:</p>
<div class="imageblock screenshot">
<div class="content">
<img src="images/ecommerce-pivot1.png" alt="Creating a simple transform in Kibana">
</div>
</div>
<p>In this case, we grouped the data by customer ID and calculated the sum of
products each customer purchased.</p>
<p>Let&#8217;s add some more aggregations to learn more about our customers' orders. For
example, let&#8217;s calculate the total sum of their purchases, the maximum number of
products that they purchased in a single order, and their total number of orders.
We&#8217;ll accomplish this by using the
<a class="xref" href="search-aggregations-metrics.html#search-aggregations-metrics-sum-aggregation" title="Sum aggregation"><code class="literal">sum</code> aggregation</a> on the
<code class="literal">taxless_total_price</code> field, the
<a class="xref" href="search-aggregations-metrics.html#search-aggregations-metrics-max-aggregation" title="Max aggregation"><code class="literal">max</code> aggregation</a> on the
<code class="literal">total_quantity</code> field, and the
<a class="xref" href="search-aggregations-metrics.html#search-aggregations-metrics-cardinality-aggregation" title="Cardinality aggregation"><code class="literal">cardinality</code> aggregation</a>
on the <code class="literal">order_id</code> field:</p>
<div class="imageblock screenshot">
<div class="content">
<img src="images/ecommerce-pivot2.png" alt="Adding multiple aggregations to a transform in Kibana">
</div>
</div>
<div class="tip admon">
<div class="icon"></div>
<div class="admon_content">
<p>If you&#8217;re interested in a subset of the data, you can optionally include a
<a class="xref" href="search.html#request-body-search-query">query</a> element. In this
example, we&#8217;ve filtered the data so that we&#8217;re only looking at orders with a
<code class="literal">currency</code> of <code class="literal">EUR</code>. Alternatively, we could group the data by that field too.
If you want to use more complex queries, you can create your data frame from a
<a href="https://www.elastic.co/guide/en/kibana/7.10/save-open-search.html" class="ulink" target="_top">saved search</a>.</p>
</div>
</div>
<p>If you prefer, you can use the
<a class="xref" href="transform-apis.html#preview-transform" title="Preview transform API">preview transforms API</a>.</p>
<details>
<summary class="title">API example</summary>
<div class="content">
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST _transform/_preview
{
  "source": {
    "index": "kibana_sample_data_ecommerce",
    "query": {
      "bool": {
        "filter": {
          "term": {"currency": "EUR"}
        }
      }
    }
  },
  "pivot": {
    "group_by": {
      "customer_id": {
        "terms": {
          "field": "customer_id"
        }
      }
    },
    "aggregations": {
      "total_quantity.sum": {
        "sum": {
          "field": "total_quantity"
        }
      },
      "taxless_total_price.sum": {
        "sum": {
          "field": "taxless_total_price"
        }
      },
      "total_quantity.max": {
        "max": {
          "field": "total_quantity"
        }
      },
      "order_id.cardinality": {
        "cardinality": {
          "field": "order_id"
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1369.console"></div>
</div>
</details>
</li>
<li class="listitem">
<p>When you are satisfied with what you see in the preview, create the
transform.</p>
<div class="olist orderedlist">
<ol class="orderedlist">
<li class="listitem">
Supply a job ID and the name of the target (or <em>destination</em>) index. If the
target index does not exist, it will be created automatically.
</li>
<li class="listitem">
Decide whether you want the transform to run once or continuously.
</li>
</ol>
</div>
<p>Since this sample data index is unchanging, let&#8217;s use the default behavior and
just run the transform once.</p>
<p>If you want to try it out, however, go ahead and click on <span class="strong strong"><strong>Continuous mode</strong></span>.
You must choose a field that the transform can use to check which
entities have changed. In general, it&#8217;s a good idea to use the ingest timestamp
field. In this example, however, you can use the <code class="literal">order_date</code> field.</p>
<p>If you prefer, you can use the
<a class="xref" href="transform-apis.html#put-transform" title="Create transform API">create transforms API</a>.</p>
<details>
<summary class="title">API example</summary>
<div class="content">
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT _transform/ecommerce-customer-transform
{
  "source": {
    "index": [
      "kibana_sample_data_ecommerce"
    ],
    "query": {
      "bool": {
        "filter": {
          "term": {
            "currency": "EUR"
          }
        }
      }
    }
  },
  "pivot": {
    "group_by": {
      "customer_id": {
        "terms": {
          "field": "customer_id"
        }
      }
    },
    "aggregations": {
      "total_quantity.sum": {
        "sum": {
          "field": "total_quantity"
        }
      },
      "taxless_total_price.sum": {
        "sum": {
          "field": "taxless_total_price"
        }
      },
      "total_quantity.max": {
        "max": {
          "field": "total_quantity"
        }
      },
      "order_id.cardinality": {
        "cardinality": {
          "field": "order_id"
        }
      }
    }
  },
  "dest": {
    "index": "ecommerce-customers"
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1370.console"></div>
</div>
</details>
</li>
<li class="listitem">
<p>Start the transform.</p>
<div class="tip admon">
<div class="icon"></div>
<div class="admon_content">
<p>Even though resource utilization is automatically adjusted based on the
cluster load, a transform increases search and indexing load on your
cluster while it runs. If you&#8217;re experiencing an excessive load, however, you
can stop it.</p>
</div>
</div>
<p>You can start, stop, and manage transforms in Kibana:</p>
<div class="imageblock screenshot">
<div class="content">
<img src="images/manage-transforms.png" alt="Managing transforms in Kibana">
</div>
</div>
<p>Alternatively, you can use the
<a class="xref" href="transform-apis.html#start-transform" title="Start transform API">start transforms</a> and
<a class="xref" href="transform-apis.html#stop-transform" title="Stop transforms API">stop transforms</a> APIs.</p>
<details>
<summary class="title">API example</summary>
<div class="content">
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST _transform/ecommerce-customer-transform/_start</pre>
</div>
<div class="console_widget" data-snippet="snippets/1371.console"></div>
</div>
</details>
<div class="tip admon">
<div class="icon"></div>
<div class="admon_content">
<p>If you chose a batch transform, it is a single operation that has a
single checkpoint. You cannot restart it when it&#8217;s complete. Continuous transforms
differ in that they continually increment and process checkpoints as new source
data is ingested.</p>
</div>
</div>
</li>
<li class="listitem">
<p>Explore the data in your new index.</p>
<p>For example, use the <span class="strong strong"><strong>Discover</strong></span> application in Kibana:</p>
<div class="imageblock screenshot">
<div class="content">
<img src="images/ecommerce-results.png" alt="Exploring the new index in Kibana">
</div>
</div>
</li>
</ol>
</div>
<div class="tip admon">
<div class="icon"></div>
<div class="admon_content">
<p>If you do not want to keep the transform, you can delete it in
Kibana or use the
<a class="xref" href="transform-apis.html#delete-transform" title="Delete transform API">delete transform API</a>. When
you delete a transform, its destination index and Kibana index
patterns remain.</p>
</div>
</div>
<p>Now that you&#8217;ve created a simple transform for Kibana sample data, consider
possible use cases for your own data. For more ideas, see
<a class="xref" href="transforms.html#transform-usage" title="When to use transforms">When to use transforms</a> and <a class="xref" href="transforms.html#transform-examples" title="Transform examples">Examples</a>.</p>
</div>

<div class="section xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="transform-examples"></a>Transform examples<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/examples.asciidoc">edit</a><a class="xpack_tag" href="/subscriptions"></a></h2>
</div></div></div>

<p>These examples demonstrate how to use transforms to derive useful
insights from your data. All the examples use one of the
<a href="https://www.elastic.co/guide/en/kibana/7.10/add-sample-data.html" class="ulink" target="_top">Kibana sample datasets</a>. For a more detailed,
step-by-step example, see
<a class="xref" href="transforms.html#ecommerce-transforms" title="Tutorial: Transforming the eCommerce sample data">Tutorial: Transforming the eCommerce sample data</a>.</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<a class="xref" href="transforms.html#example-best-customers" title="Finding your best customers">Finding your best customers</a>
</li>
<li class="listitem">
<a class="xref" href="transforms.html#example-airline" title="Finding air carriers with the most delays">Finding air carriers with the most delays</a>
</li>
<li class="listitem">
<a class="xref" href="transforms.html#example-clientips" title="Finding suspicious client IPs">Finding suspicious client IPs</a>
</li>
</ul>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="example-best-customers"></a>Finding your best customers<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/examples.asciidoc">edit</a></h3>
</div></div></div>
<p>In this example, we use the eCommerce orders sample dataset to find the
customers who spent the most in our hypothetical webshop. Let&#8217;s transform the
data such that the destination index contains the number of orders, the total
price of the orders, the amount of unique products and the average price per
order, and the total amount of ordered products for each customer.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST _transform/_preview
{
  "source": {
    "index": "kibana_sample_data_ecommerce"
  },
  "dest" : { <a id="CO487-1"></a><i class="conum" data-value="1"></i>
    "index" : "sample_ecommerce_orders_by_customer"
  },
  "pivot": {
    "group_by": { <a id="CO487-2"></a><i class="conum" data-value="2"></i>
      "user": { "terms": { "field": "user" }},
      "customer_id": { "terms": { "field": "customer_id" }}
    },
    "aggregations": {
      "order_count": { "value_count": { "field": "order_id" }},
      "total_order_amt": { "sum": { "field": "taxful_total_price" }},
      "avg_amt_per_order": { "avg": { "field": "taxful_total_price" }},
      "avg_unique_products_per_order": { "avg": { "field": "total_unique_products" }},
      "total_unique_products": { "cardinality": { "field": "products.product_id" }}
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1372.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO487-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>This is the destination index for the transform. It is ignored by
<code class="literal">_preview</code>.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO487-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>Two <code class="literal">group_by</code> fields have been selected. This means the transform will
contain a unique row per <code class="literal">user</code> and <code class="literal">customer_id</code> combination. Within this
dataset both these fields are unique. By including both in the transform it
gives more context to the final results.</p>
</td>
</tr>
</table>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>In the example above, condensed JSON formatting has been used for easier
readability of the pivot object.</p>
</div>
</div>
<p>The preview transforms API enables you to see the layout of the
transform in advance, populated with some sample values. For example:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "preview" : [
    {
      "total_order_amt" : 3946.9765625,
      "order_count" : 59.0,
      "total_unique_products" : 116.0,
      "avg_unique_products_per_order" : 2.0,
      "customer_id" : "10",
      "user" : "recip",
      "avg_amt_per_order" : 66.89790783898304
    },
    ...
    ]
  }</pre>
</div>
<p>This transform makes it easier to answer questions such as:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Which customers spend the most?
</li>
<li class="listitem">
Which customers spend the most per order?
</li>
<li class="listitem">
Which customers order most often?
</li>
<li class="listitem">
Which customers ordered the least number of different products?
</li>
</ul>
</div>
<p>It&#8217;s possible to answer these questions using aggregations alone, however
transforms allow us to persist this data as a customer centric index. This
enables us to analyze data at scale and gives more flexibility to explore and
navigate data from a customer centric perspective. In some cases, it can even
make creating visualizations much simpler.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="example-airline"></a>Finding air carriers with the most delays<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/examples.asciidoc">edit</a></h3>
</div></div></div>
<p>In this example, we use the Flights sample dataset to find out which air carrier
had the most delays. First, we filter the source data such that it excludes all
the cancelled flights by using a query filter. Then we transform the data to
contain the distinct number of flights, the sum of delayed minutes, and the sum
of the flight minutes by air carrier. Finally, we use a
<a class="xref" href="search-aggregations-pipeline.html#search-aggregations-pipeline-bucket-script-aggregation" title="Bucket script aggregation"><code class="literal">bucket_script</code></a>
to determine what percentage of the flight time was actually delay.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST _transform/_preview
{
  "source": {
    "index": "kibana_sample_data_flights",
    "query": { <a id="CO488-1"></a><i class="conum" data-value="1"></i>
      "bool": {
        "filter": [
          { "term":  { "Cancelled": false } }
        ]
      }
    }
  },
  "dest" : { <a id="CO488-2"></a><i class="conum" data-value="2"></i>
    "index" : "sample_flight_delays_by_carrier"
  },
  "pivot": {
    "group_by": { <a id="CO488-3"></a><i class="conum" data-value="3"></i>
      "carrier": { "terms": { "field": "Carrier" }}
    },
    "aggregations": {
      "flights_count": { "value_count": { "field": "FlightNum" }},
      "delay_mins_total": { "sum": { "field": "FlightDelayMin" }},
      "flight_mins_total": { "sum": { "field": "FlightTimeMin" }},
      "delay_time_percentage": { <a id="CO488-4"></a><i class="conum" data-value="4"></i>
        "bucket_script": {
          "buckets_path": {
            "delay_time": "delay_mins_total.value",
            "flight_time": "flight_mins_total.value"
          },
          "script": "(params.delay_time / params.flight_time) * 100"
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1373.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO488-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Filter the source data to select only flights that were not cancelled.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO488-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>This is the destination index for the transform. It is ignored by
<code class="literal">_preview</code>.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO488-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>The data is grouped by the <code class="literal">Carrier</code> field which contains the airline name.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO488-4"><i class="conum" data-value="4"></i></a></p>
</td>
<td align="left" valign="top">
<p>This <code class="literal">bucket_script</code> performs calculations on the results that are returned
by the aggregation. In this particular example, it calculates what percentage of
travel time was taken up by delays.</p>
</td>
</tr>
</table>
</div>
<p>The preview shows you that the new index would contain data like this for each
carrier:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "preview" : [
    {
      "carrier" : "ES-Air",
      "flights_count" : 2802.0,
      "flight_mins_total" : 1436927.5130677223,
      "delay_time_percentage" : 9.335543983955839,
      "delay_mins_total" : 134145.0
    },
    ...
  ]
}</pre>
</div>
<p>This transform makes it easier to answer questions such as:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Which air carrier has the most delays as a percentage of flight time?
</li>
</ul>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>This data is fictional and does not reflect actual delays
or flight stats for any of the featured destination or origin airports.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="example-clientips"></a>Finding suspicious client IPs<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/examples.asciidoc">edit</a></h3>
</div></div></div>
<p>In this example, we use the web log sample dataset to identify suspicious client
IPs. We transform the data such that the new index contains the sum of bytes and
the number of distinct URLs, agents, incoming requests by location, and
geographic destinations for each client IP. We also use filter aggregations to
count the specific types of HTTP responses that each client IP receives.
Ultimately, the example below transforms web log data into an entity centric
index where the entity is <code class="literal">clientip</code>.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT _transform/suspicious_client_ips
{
  "source": {
    "index": "kibana_sample_data_logs"
  },
  "dest" : { <a id="CO489-1"></a><i class="conum" data-value="1"></i>
    "index" : "sample_weblogs_by_clientip"
  },
  "sync" : { <a id="CO489-2"></a><i class="conum" data-value="2"></i>
    "time": {
      "field": "timestamp",
      "delay": "60s"
    }
  },
  "pivot": {
    "group_by": {  <a id="CO489-3"></a><i class="conum" data-value="3"></i>
      "clientip": { "terms": { "field": "clientip" } }
      },
    "aggregations": {
      "url_dc": { "cardinality": { "field": "url.keyword" }},
      "bytes_sum": { "sum": { "field": "bytes" }},
      "geo.src_dc": { "cardinality": { "field": "geo.src" }},
      "agent_dc": { "cardinality": { "field": "agent.keyword" }},
      "geo.dest_dc": { "cardinality": { "field": "geo.dest" }},
      "responses.total": { "value_count": { "field": "timestamp" }},
      "success" : { <a id="CO489-4"></a><i class="conum" data-value="4"></i>
         "filter": {
            "term": { "response" : "200"}}
        },
      "error404" : {
         "filter": {
            "term": { "response" : "404"}}
        },
      "error503" : {
         "filter": {
            "term": { "response" : "503"}}
        },
      "timestamp.min": { "min": { "field": "timestamp" }},
      "timestamp.max": { "max": { "field": "timestamp" }},
      "timestamp.duration_ms": { <a id="CO489-5"></a><i class="conum" data-value="5"></i>
        "bucket_script": {
          "buckets_path": {
            "min_time": "timestamp.min.value",
            "max_time": "timestamp.max.value"
          },
          "script": "(params.max_time - params.min_time)"
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1374.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO489-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>This is the destination index for the transform.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO489-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>Configures the transform to run continuously. It uses the <code class="literal">timestamp</code> field
to synchronize the source and destination indices. The worst case
ingestion delay is 60 seconds.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO489-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>The data is grouped by the <code class="literal">clientip</code> field.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO489-4"><i class="conum" data-value="4"></i></a></p>
</td>
<td align="left" valign="top">
<p>Filter aggregation that counts the occurrences of successful (<code class="literal">200</code>)
responses in the <code class="literal">response</code> field. The following two aggregations (<code class="literal">error404</code>
and <code class="literal">error503</code>) count the error responses by error codes.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO489-5"><i class="conum" data-value="5"></i></a></p>
</td>
<td align="left" valign="top">
<p>This <code class="literal">bucket_script</code> calculates the duration of the <code class="literal">clientip</code> access based
on the results of the aggregation.</p>
</td>
</tr>
</table>
</div>
<p>After you create the transform, you must start it:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST _transform/suspicious_client_ips/_start</pre>
</div>
<div class="console_widget" data-snippet="snippets/1375.console"></div>
<p>Shortly thereafter, the first results should be available in the destination
index:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET sample_weblogs_by_clientip/_search</pre>
</div>
<div class="console_widget" data-snippet="snippets/1376.console"></div>
<p>The search result shows you data like this for each client IP:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">    "hits" : [
      {
        "_index" : "sample_weblogs_by_clientip",
        "_id" : "MOeHH_cUL5urmartKj-b5UQAAAAAAAAA",
        "_score" : 1.0,
        "_source" : {
          "geo" : {
            "src_dc" : 2.0,
            "dest_dc" : 2.0
          },
          "success" : 2,
          "error404" : 0,
          "error503" : 0,
          "clientip" : "0.72.176.46",
          "agent_dc" : 2.0,
          "bytes_sum" : 4422.0,
          "responses" : {
            "total" : 2.0
          },
          "url_dc" : 2.0,
          "timestamp" : {
            "duration_ms" : 5.2191698E8,
            "min" : "2020-03-16T07:51:57.333Z",
            "max" : "2020-03-22T08:50:34.313Z"
          }
        }
      }
    ]</pre>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>Like other Kibana sample data sets, the web log sample dataset contains
timestamps relative to when you installed it, including timestamps in the
future. The continuous transform will pick up the data points once they are in the past.
If you installed the web log sample dataset some time ago, you can uninstall and
reinstall it and the timestamps will change.</p>
</div>
</div>
<p>This transform makes it easier to answer questions such as:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Which client IPs are transferring the most amounts of data?
</li>
<li class="listitem">
Which client IPs are interacting with a high number of different URLs?
</li>
<li class="listitem">
Which client IPs have high error rates?
</li>
<li class="listitem">
Which client IPs are interacting with a high number of destination countries?
</li>
</ul>
</div>
</div>

</div>

<div class="section xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="transform-painless-examples"></a>Painless examples for transforms<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/painless-examples.asciidoc">edit</a><a class="xpack_tag" href="/subscriptions"></a></h2>
</div></div></div>

<p>These examples demonstrate how to use Painless in transforms. You can learn
more about the Painless scripting language in the
<a href="https://www.elastic.co/guide/en/elasticsearch/painless/7.10/painless-guide.html" class="ulink" target="_top">Painless guide</a>.</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<a class="xref" href="transforms.html#painless-top-hits" title="Getting top hits by using scripted metric aggregation">Getting top hits by using scripted metric aggregation</a>
</li>
<li class="listitem">
<a class="xref" href="transforms.html#painless-time-features" title="Getting time features by using aggregations">Getting time features by using aggregations</a>
</li>
<li class="listitem">
<a class="xref" href="transforms.html#painless-group-by" title="Using Painless in group_by">Using Painless in <code class="literal">group_by</code></a>
</li>
<li class="listitem">
<a class="xref" href="transforms.html#painless-bucket-script" title="Getting duration by using bucket script">Getting duration by using bucket script</a>
</li>
<li class="listitem">
<a class="xref" href="transforms.html#painless-count-http" title="Counting HTTP responses by using scripted metric aggregation">Counting HTTP responses by using scripted metric aggregation</a>
</li>
<li class="listitem">
<a class="xref" href="transforms.html#painless-compare" title="Comparing indices by using scripted metric aggregations">Comparing indices by using scripted metric aggregations</a>
</li>
<li class="listitem">
<a class="xref" href="transforms.html#painless-web-session" title="Getting web session details by using scripted metric aggregation">Getting web session details by using scripted metric aggregation</a>
</li>
</ul>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
While the context of the following examples is the transform use case,
the Painless scripts in the snippets below can be used in other Elasticsearch search
aggregations, too.
</li>
<li class="listitem">
All the following examples use scripts, transforms cannot deduce mappings of
output fields when the fields are created by a script. Transforms don&#8217;t
create any mappings in the destination index for these fields, which means they
get dynamically mapped. Create the destination index prior to starting the
transform in case you want explicit mappings.
</li>
</ul>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="painless-top-hits"></a>Getting top hits by using scripted metric aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/painless-examples.asciidoc">edit</a></h3>
</div></div></div>
<p>This snippet shows how to find the latest document, in other words the document
with the latest timestamp. From a technical perspective, it helps to achieve
the function of a <a class="xref" href="search-aggregations-metrics.html#search-aggregations-metrics-top-hits-aggregation" title="Top hits aggregation">Top hits</a> by using
scripted metric aggregation in a transform, which provides a metric output.</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">"aggregations": {
  "latest_doc": {
    "scripted_metric": {
      "init_script": "state.timestamp_latest = 0L; state.last_doc = ''", <a id="CO490-1"></a><i class="conum" data-value="1"></i>
      "map_script": """ <a id="CO490-2"></a><i class="conum" data-value="2"></i>
        def current_date = doc['@timestamp'].getValue().toInstant().toEpochMilli();
        if (current_date &gt; state.timestamp_latest)
        {state.timestamp_latest = current_date;
        state.last_doc = new HashMap(params['_source']);}
      """,
      "combine_script": "return state", <a id="CO490-3"></a><i class="conum" data-value="3"></i>
      "reduce_script": """ <a id="CO490-4"></a><i class="conum" data-value="4"></i>
        def last_doc = '';
        def timestamp_latest = 0L;
        for (s in states) {if (s.timestamp_latest &gt; (timestamp_latest))
        {timestamp_latest = s.timestamp_latest; last_doc = s.last_doc;}}
        return last_doc
      """
    }
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO490-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">init_script</code> creates a long type <code class="literal">timestamp_latest</code> and a string type
<code class="literal">last_doc</code> in the <code class="literal">state</code> object.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO490-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">map_script</code> defines <code class="literal">current_date</code> based on the timestamp of the
document, then compares <code class="literal">current_date</code> with <code class="literal">state.timestamp_latest</code>, finally
returns <code class="literal">state.last_doc</code> from the shard. By using <code class="literal">new HashMap(...)</code> you copy
the source document, this is important whenever you want to pass the full source
object from one phase to the next.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO490-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">combine_script</code> returns <code class="literal">state</code> from each shard.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO490-4"><i class="conum" data-value="4"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">reduce_script</code> iterates through the value of <code class="literal">s.timestamp_latest</code>
returned by each shard and returns the document with the latest timestamp
(<code class="literal">last_doc</code>). In the response, the top hit (in other words, the <code class="literal">latest_doc</code>) is
nested below the <code class="literal">latest_doc</code> field.</p>
</td>
</tr>
</table>
</div>
<p>Check the
<a class="xref" href="search-aggregations-metrics.html#scripted-metric-aggregation-scope" title="Scope of scripts">scope of scripts</a>
for detailed explanation on the respective scripts.</p>
<p>You can retrieve the last value in a similar way:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">"aggregations": {
  "latest_value": {
    "scripted_metric": {
      "init_script": "state.timestamp_latest = 0L; state.last_value = ''",
      "map_script": """
        def current_date = doc['@timestamp'].getValue().toInstant().toEpochMilli();
        if (current_date &gt; state.timestamp_latest)
        {state.timestamp_latest = current_date;
        state.last_value = params['_source']['value'];}
      """,
      "combine_script": "return state",
      "reduce_script": """
        def last_value = '';
        def timestamp_latest = 0L;
        for (s in states) {if (s.timestamp_latest &gt; (timestamp_latest))
        {timestamp_latest = s.timestamp_latest; last_value = s.last_value;}}
        return last_value
      """
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="painless-time-features"></a>Getting time features by using aggregations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/painless-examples.asciidoc">edit</a></h3>
</div></div></div>
<p>This snippet shows how to extract time based features by using Painless in a
transform. The snippet uses an index where <code class="literal">@timestamp</code> is defined as a <code class="literal">date</code>
type field.</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">"aggregations": {
  "avg_hour_of_day": { <a id="CO491-1"></a><i class="conum" data-value="1"></i>
    "avg":{
      "script": { <a id="CO491-2"></a><i class="conum" data-value="2"></i>
        "source": """
          ZonedDateTime date =  doc['@timestamp'].value; <a id="CO491-3"></a><i class="conum" data-value="3"></i>
          return date.getHour(); <a id="CO491-4"></a><i class="conum" data-value="4"></i>
        """
      }
    }
  },
  "avg_month_of_year": { <a id="CO491-5"></a><i class="conum" data-value="5"></i>
    "avg":{
      "script": { <a id="CO491-6"></a><i class="conum" data-value="6"></i>
        "source": """
          ZonedDateTime date =  doc['@timestamp'].value; <a id="CO491-7"></a><i class="conum" data-value="7"></i>
          return date.getMonthValue(); <a id="CO491-8"></a><i class="conum" data-value="8"></i>
        """
      }
    }
  },
 ...
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO491-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Name of the aggregation.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO491-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>Contains the Painless script that returns the hour of the day.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO491-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>Sets <code class="literal">date</code> based on the timestamp of the document.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO491-4"><i class="conum" data-value="4"></i></a></p>
</td>
<td align="left" valign="top">
<p>Returns the hour value from <code class="literal">date</code>.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO491-5"><i class="conum" data-value="5"></i></a></p>
</td>
<td align="left" valign="top">
<p>Name of the aggregation.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO491-6"><i class="conum" data-value="6"></i></a></p>
</td>
<td align="left" valign="top">
<p>Contains the Painless script that returns the month of the year.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO491-7"><i class="conum" data-value="7"></i></a></p>
</td>
<td align="left" valign="top">
<p>Sets <code class="literal">date</code> based on the timestamp of the document.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO491-8"><i class="conum" data-value="8"></i></a></p>
</td>
<td align="left" valign="top">
<p>Returns the month value from <code class="literal">date</code>.</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="painless-group-by"></a>Using Painless in <code class="literal">group_by</code><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/painless-examples.asciidoc">edit</a></h3>
</div></div></div>
<p>It is possible to base the <code class="literal">group_by</code> property of a transform on the output of
a script. The following example uses the Kibana sample web logs dataset. The goal
here is to make the transform output easier to understand through normalizing
the value of the fields that the data is grouped by.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST _transform/_preview
{
  "source": {
    "index": [ <a id="CO492-1"></a><i class="conum" data-value="1"></i>
      "kibana_sample_data_logs"
    ]
  },
  "pivot": {
    "group_by": {
      "agent": {
        "terms": {
          "script": { <a id="CO492-2"></a><i class="conum" data-value="2"></i>
            "source": """String agent = doc['agent.keyword'].value;
            if (agent.contains("MSIE")) {
              return "internet explorer";
            } else if (agent.contains("AppleWebKit")) {
              return "safari";
            } else if (agent.contains('Firefox')) {
              return "firefox";
            } else { return agent }""",
            "lang": "painless"
          }
        }
      }
    },
    "aggregations": { <a id="CO492-3"></a><i class="conum" data-value="3"></i>
      "all": {
        "value_count": {
          "field": "response.keyword"
        }
      },
      "200": {
        "filter": {
          "term": {
            "response": "200"
          }
        }
      },
      "404": {
        "filter": {
          "term": {
            "response": "404"
          }
        }
      },
      "503": {
        "filter": {
          "term": {
            "response": "503"
          }
        }
      }
    }
  },
  "dest": { <a id="CO492-4"></a><i class="conum" data-value="4"></i>
    "index": "pivot_logs"
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1377.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO492-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Specifies the source index or indices.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO492-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>The script defines an <code class="literal">agent</code> string based on the <code class="literal">agent</code> field of the
documents, then iterates through the values. If an <code class="literal">agent</code> field contains
"MSIE", than the script returns "Internet Explorer". If it contains
<code class="literal">AppleWebKit</code>, it returns "safari". It returns "firefox" if the field value
contains "Firefox". Finally, in every other case, the value of the field is
returned.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO492-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>The aggregations object contains filters that narrow down the results to
documents that contains <code class="literal">200</code>, <code class="literal">404</code>, or <code class="literal">503</code> values in the <code class="literal">response</code> field
and an aggregation that counts responses for each agent.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO492-4"><i class="conum" data-value="4"></i></a></p>
</td>
<td align="left" valign="top">
<p>Specifies the destination index of the transform.</p>
</td>
</tr>
</table>
</div>
<p>The API returns the following result:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "preview" : [
    {
      "all" : 4010,
      "agent" : "explorer",
      "200" : 3674,
      "404" : 210,
      "503" : 126
    },
    {
      "all" : 5362,
      "agent" : "firefox",
      "200" : 4931,
      "404" : 259,
      "503" : 172
    },
    {
      "all" : 4702,
      "agent" : "safari",
      "200" : 4227,
      "404" : 332,
      "503" : 143
    }
  ],
  "generated_dest_index" : {
    "mappings" : {
      "_meta" : {
        "_transform" : {
          "transform" : "transform-preview",
          "version" : {
            "created" : "7.10.0"
          },
          "creation_date_in_millis" : 1610454866455
        },
        "created_by" : "transform"
      },
      "properties" : {
        "all" : {
          "type" : "long"
        },
        "200" : {
          "type" : "long"
        },
        "404" : {
          "type" : "long"
        },
        "503" : {
          "type" : "long"
        }
      }
    },
    "settings" : {
      "index" : {
        "number_of_shards" : "1",
        "auto_expand_replicas" : "0-1"
      }
    },
    "aliases" : { }
  }
}</pre>
</div>
<p>You can see that the <code class="literal">agent</code> values are simplified so it is easier to interpret
them. The table below shows how normalization modifies the output of the
transform in our example compared to the non-normalized values.</p>
<div class="informaltable">
<table border="1" cellpadding="4px" width="50%">
<colgroup>
<col class="col_1"/>
<col class="col_2"/>
</colgroup>
<thead>
<tr>
<th align="left" valign="top">Non-normalized <code class="literal">agent</code> value</th>
<th align="left" valign="top">Normalized <code class="literal">agent</code> value</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p>"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 1.1.4322)"</p></td>
<td align="left" valign="top"><p>"internet explorer"</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>"Mozilla/5.0 (X11; Linux i686) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.696.50 Safari/534.24"</p></td>
<td align="left" valign="top"><p>"safari"</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>"Mozilla/5.0 (X11; Linux x86_64; rv:6.0a1) Gecko/20110421 Firefox/6.0a1"</p></td>
<td align="left" valign="top"><p>"firefox"</p></td>
</tr>
</tbody>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="painless-bucket-script"></a>Getting duration by using bucket script<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/painless-examples.asciidoc">edit</a></h3>
</div></div></div>
<p>This example shows you how to get the duration of a session by client IP from a
data log by using
<a class="xref" href="search-aggregations-pipeline.html#search-aggregations-pipeline-bucket-script-aggregation" title="Bucket script aggregation">bucket script</a>.
The example uses the Kibana sample web logs dataset.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT _transform/data_log
{
  "source": {
    "index": "kibana_sample_data_logs"
  },
  "dest": {
    "index": "data-logs-by-client"
  },
  "pivot": {
    "group_by": {
      "machine.os": {"terms": {"field": "machine.os.keyword"}},
      "machine.ip": {"terms": {"field": "clientip"}}
    },
    "aggregations": {
      "time_frame.lte": {
        "max": {
          "field": "timestamp"
        }
      },
      "time_frame.gte": {
        "min": {
          "field": "timestamp"
        }
      },
      "time_length": { <a id="CO493-1"></a><i class="conum" data-value="1"></i>
        "bucket_script": {
          "buckets_path": { <a id="CO493-2"></a><i class="conum" data-value="2"></i>
            "min": "time_frame.gte.value",
            "max": "time_frame.lte.value"
          },
          "script": "params.max - params.min" <a id="CO493-3"></a><i class="conum" data-value="3"></i>
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1378.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO493-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>To define the length of the sessions, we use a bucket script.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO493-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>The bucket path is a map of script variables and their associated path to
the buckets you want to use for the variable. In this particular case, <code class="literal">min</code> and
<code class="literal">max</code> are variables mapped to <code class="literal">time_frame.gte.value</code> and <code class="literal">time_frame.lte.value</code>.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO493-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>Finally, the script substracts the start date of the session from the end
date which results in the duration of the session.</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="painless-count-http"></a>Counting HTTP responses by using scripted metric aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/painless-examples.asciidoc">edit</a></h3>
</div></div></div>
<p>You can count the different HTTP response types in a web log data set by using
scripted metric aggregation as part of the transform. You can achieve a similar
function with filter aggregations, check the
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.10/transform-examples.html#example-clientips" class="ulink" target="_top">Finding suspicious client IPs</a>
example for details.</p>
<p>The example below assumes that the HTTP response codes are stored as keywords in
the <code class="literal">response</code> field of the documents.</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">"aggregations": { <a id="CO494-1"></a><i class="conum" data-value="1"></i>
  "responses.counts": { <a id="CO494-2"></a><i class="conum" data-value="2"></i>
    "scripted_metric": { <a id="CO494-3"></a><i class="conum" data-value="3"></i>
      "init_script": "state.responses = ['error':0L,'success':0L,'other':0L]", <a id="CO494-4"></a><i class="conum" data-value="4"></i>
      "map_script": """ <a id="CO494-5"></a><i class="conum" data-value="5"></i>
        def code = doc['response.keyword'].value;
        if (code.startsWith('5') || code.startsWith('4')) {
          state.responses.error += 1 ;
        } else if(code.startsWith('2')) {
          state.responses.success += 1;
        } else {
          state.responses.other += 1;
        }
        """,
      "combine_script": "state.responses", <a id="CO494-6"></a><i class="conum" data-value="6"></i>
      "reduce_script": """ <a id="CO494-7"></a><i class="conum" data-value="7"></i>
        def counts = ['error': 0L, 'success': 0L, 'other': 0L];
        for (responses in states) {
          counts.error += responses['error'];
          counts.success += responses['success'];
          counts.other += responses['other'];
        }
        return counts;
        """
      }
    },
  ...
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO494-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">aggregations</code> object of the transform that contains all aggregations.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO494-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>Object of the <code class="literal">scripted_metric</code> aggregation.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO494-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>This <code class="literal">scripted_metric</code> performs a distributed operation on the web log data
to count specific types of HTTP responses (error, success, and other).</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO494-4"><i class="conum" data-value="4"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">init_script</code> creates a <code class="literal">responses</code> array in the <code class="literal">state</code> object with
three properties (<code class="literal">error</code>, <code class="literal">success</code>, <code class="literal">other</code>) with long data type.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO494-5"><i class="conum" data-value="5"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">map_script</code> defines <code class="literal">code</code> based on the <code class="literal">response.keyword</code> value of the
document, then it counts the errors, successes, and other responses based on the
first digit of the responses.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO494-6"><i class="conum" data-value="6"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">combine_script</code> returns <code class="literal">state.responses</code> from each shard.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO494-7"><i class="conum" data-value="7"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">reduce_script</code> creates a <code class="literal">counts</code> array with the <code class="literal">error</code>, <code class="literal">success</code>,
and <code class="literal">other</code> properties, then iterates through the value of <code class="literal">responses</code> returned
by each shard and assigns the different response types to the appropriate
properties of the <code class="literal">counts</code> object; error responses to the error counts, success
responses to the success counts, and other responses to the other counts.
Finally, returns the <code class="literal">counts</code> array with the response counts.</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="painless-compare"></a>Comparing indices by using scripted metric aggregations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/painless-examples.asciidoc">edit</a></h3>
</div></div></div>
<p>This example shows how to compare the content of two indices by a transform
that uses a scripted metric aggregation.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST _transform/_preview
{
  "id" : "index_compare",
  "source" : { <a id="CO495-1"></a><i class="conum" data-value="1"></i>
    "index" : [
      "index1",
      "index2"
    ],
    "query" : {
      "match_all" : { }
    }
  },
  "dest" : { <a id="CO495-2"></a><i class="conum" data-value="2"></i>
    "index" : "compare"
  },
  "pivot" : {
    "group_by" : {
      "unique-id" : {
        "terms" : {
          "field" : "&lt;unique-id-field&gt;" <a id="CO495-3"></a><i class="conum" data-value="3"></i>
        }
      }
    },
    "aggregations" : {
      "compare" : { <a id="CO495-4"></a><i class="conum" data-value="4"></i>
        "scripted_metric" : {
          "map_script" : "state.doc = new HashMap(params['_source'])", <a id="CO495-5"></a><i class="conum" data-value="5"></i>
          "combine_script" : "return state", <a id="CO495-6"></a><i class="conum" data-value="6"></i>
          "reduce_script" : """ <a id="CO495-7"></a><i class="conum" data-value="7"></i>
            if (states.size() != 2) {
              return "count_mismatch"
            }
            if (states.get(0).equals(states.get(1))) {
              return "match"
            } else {
              return "mismatch"
            }
            """
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1379.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO495-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The indices referenced in the <code class="literal">source</code> object are compared to each other.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO495-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">dest</code> index contains the results of the comparison.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO495-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">group_by</code> field needs to be a unique identifier for each document.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO495-4"><i class="conum" data-value="4"></i></a></p>
</td>
<td align="left" valign="top">
<p>Object of the <code class="literal">scripted_metric</code> aggregation.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO495-5"><i class="conum" data-value="5"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">map_script</code> defines <code class="literal">doc</code> in the state object. By using
<code class="literal">new HashMap(...)</code> you copy the source document, this is important whenever you
want to pass the full source object from one phase to the next.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO495-6"><i class="conum" data-value="6"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">combine_script</code> returns <code class="literal">state</code> from each shard.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO495-7"><i class="conum" data-value="7"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">reduce_script</code> checks if the size of the indices are equal. If they are
not equal, than it reports back a <code class="literal">count_mismatch</code>. Then it iterates through all
the values of the two indices and compare them. If the values are equal, then it
returns a <code class="literal">match</code>, otherwise returns a <code class="literal">mismatch</code>.</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="painless-web-session"></a>Getting web session details by using scripted metric aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/painless-examples.asciidoc">edit</a></h3>
</div></div></div>
<p>This example shows how to derive multiple features from a single transaction.
Let&#8217;s take a look on the example source document from the data:</p>
<details open>
<summary class="title">Source document</summary>
<div class="content">
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "_index":"apache-sessions",
  "_type":"_doc",
  "_id":"KvzSeGoB4bgw0KGbE3wP",
  "_score":1.0,
  "_source":{
    "@timestamp":1484053499256,
    "apache":{
      "access":{
        "sessionid":"571604f2b2b0c7b346dc685eeb0e2306774a63c2",
        "url":"http://www.leroymerlin.fr/v3/search/search.do?keyword=Carrelage%20salle%20de%20bain",
        "path":"/v3/search/search.do",
        "query":"keyword=Carrelage%20salle%20de%20bain",
        "referrer":"http://www.leroymerlin.fr/v3/p/produits/carrelage-parquet-sol-souple/carrelage-sol-et-mur/decor-listel-et-accessoires-carrelage-mural-l1308217717?resultOffset=0&amp;resultLimit=51&amp;resultListShape=MOSAIC&amp;priceStyle=SALEUNIT_PRICE",
        "user_agent":{
          "original":"Mobile Safari 10.0 Mac OS X (iPad) Apple Inc.",
          "os_name":"Mac OS X (iPad)"
        },
        "remote_ip":"0337b1fa-5ed4-af81-9ef4-0ec53be0f45d",
        "geoip":{
          "country_iso_code":"FR",
          "location":{
            "lat":48.86,
            "lon":2.35
          }
        },
        "response_code":200,
        "method":"GET"
      }
    }
  }
}
...</pre>
</div>
</div>
</details>
<p>By using the <code class="literal">sessionid</code> as a group-by field, you are able to enumerate events
through the session and get more details of the session by using scripted metric
aggregation.</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">POST _transform/_preview
{
  "source": {
    "index": "apache-sessions"
  },
  "pivot": {
    "group_by": {
      "sessionid": { <a id="CO496-1"></a><i class="conum" data-value="1"></i>
        "terms": {
          "field": "apache.access.sessionid"
        }
      }
    },
    "aggregations": { <a id="CO496-2"></a><i class="conum" data-value="2"></i>
      "distinct_paths": {
        "cardinality": {
          "field": "apache.access.path"
        }
      },
      "num_pages_viewed": {
        "value_count": {
          "field": "apache.access.url"
        }
      },
      "session_details": {
        "scripted_metric": {
          "init_script": "state.docs = []", <a id="CO496-3"></a><i class="conum" data-value="3"></i>
          "map_script": """ <a id="CO496-4"></a><i class="conum" data-value="4"></i>
            Map span = [
              '@timestamp':doc['@timestamp'].value,
              'url':doc['apache.access.url'].value,
              'referrer':doc['apache.access.referrer'].value
            ];
            state.docs.add(span)
          """,
          "combine_script": "return state.docs;", <a id="CO496-5"></a><i class="conum" data-value="5"></i>
          "reduce_script": """ <a id="CO496-6"></a><i class="conum" data-value="6"></i>
            def all_docs = [];
            for (s in states) {
              for (span in s) {
                all_docs.add(span);
              }
            }
            all_docs.sort((HashMap o1, HashMap o2)-&gt;o1['@timestamp'].millis.compareTo(o2['@timestamp'].millis));
            def size = all_docs.size();
            def min_time = all_docs[0]['@timestamp'];
            def max_time = all_docs[size-1]['@timestamp'];
            def duration = max_time.millis - min_time.millis;
            def entry_page = all_docs[0]['url'];
            def exit_path = all_docs[size-1]['url'];
            def first_referrer = all_docs[0]['referrer'];
            def ret = new HashMap();
            ret['first_time'] = min_time;
            ret['last_time'] = max_time;
            ret['duration'] = duration;
            ret['entry_page'] = entry_page;
            ret['exit_path'] = exit_path;
            ret['first_referrer'] = first_referrer;
            return ret;
          """
        }
      }
    }
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO496-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The data is grouped by <code class="literal">sessionid</code>.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO496-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>The aggregations counts the number of paths and enumerate the viewed pages
during the session.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO496-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">init_script</code> creates an array type <code class="literal">doc</code> in the <code class="literal">state</code> object.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO496-4"><i class="conum" data-value="4"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">map_script</code> defines a <code class="literal">span</code> array with a timestamp, a URL, and a
referrer value which are based on the corresponding values of the document, then
adds the value of the <code class="literal">span</code> array to the <code class="literal">doc</code> object.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO496-5"><i class="conum" data-value="5"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">combine_script</code> returns <code class="literal">state.docs</code> from each shard.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO496-6"><i class="conum" data-value="6"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">reduce_script</code> defines various objects like <code class="literal">min_time</code>, <code class="literal">max_time</code>, and
<code class="literal">duration</code> based on the document fields, then declares a <code class="literal">ret</code> object, and
copies the source document by using <code class="literal">new HashMap ()</code>. Next, the script defines
<code class="literal">first_time</code>, <code class="literal">last_time</code>, <code class="literal">duration</code> and other fields inside the <code class="literal">ret</code> object
based on the corresponding object defined earlier, finally returns <code class="literal">ret</code>.</p>
</td>
</tr>
</table>
</div>
<p>The API call results in a similar response:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "num_pages_viewed" : 2.0,
  "session_details" : {
    "duration" : 131374,
    "first_referrer" : "https://www.bing.com/",
    "entry_page" : "http://www.leroymerlin.fr/v3/p/produits/materiaux-menuiserie/porte-coulissante-porte-interieure-escalier-et-rambarde/barriere-de-securite-l1308218463",
    "first_time" : "2017-01-10T21:22:52.982Z",
    "last_time" : "2017-01-10T21:25:04.356Z",
    "exit_path" : "http://www.leroymerlin.fr/v3/p/produits/materiaux-menuiserie/porte-coulissante-porte-interieure-escalier-et-rambarde/barriere-de-securite-l1308218463?__result-wrapper?pageTemplate=Famille%2FMat%C3%A9riaux+et+menuiserie&amp;resultOffset=0&amp;resultLimit=50&amp;resultListShape=PLAIN&amp;nomenclatureId=17942&amp;priceStyle=SALEUNIT_PRICE&amp;fcr=1&amp;*4294718806=4294718806&amp;*14072=14072&amp;*4294718593=4294718593&amp;*17942=17942"
  },
  "distinct_paths" : 1.0,
  "sessionid" : "000046f8154a80fd89849369c984b8cc9d795814"
},
{
  "num_pages_viewed" : 10.0,
  "session_details" : {
    "duration" : 343112,
    "first_referrer" : "https://www.google.fr/",
    "entry_page" : "http://www.leroymerlin.fr/",
    "first_time" : "2017-01-10T16:57:39.937Z",
    "last_time" : "2017-01-10T17:03:23.049Z",
    "exit_path" : "http://www.leroymerlin.fr/v3/p/produits/porte-de-douche-coulissante-adena-e168578"
  },
  "distinct_paths" : 8.0,
  "sessionid" : "000087e825da1d87a332b8f15fa76116c7467da6"
}
...</pre>
</div>
</div>

</div>

<div class="section xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="transform-troubleshooting"></a>Troubleshooting transforms<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/troubleshooting.asciidoc">edit</a><a class="xpack_tag" href="/subscriptions"></a></h2>
</div></div></div>

<p>Use the information in this section to troubleshoot common problems.</p>
<p>For issues that you cannot fix yourself … we’re here to help.
If you are an existing Elastic customer with a support contract, please create
a ticket in the
<a href="https://support.elastic.co/customers/s/login/" class="ulink" target="_top">Elastic Support portal</a>.
Or post in the <a href="https://discuss.elastic.co/" class="ulink" target="_top">Elastic forum</a>.</p>
<p>If you encounter problems with your transforms, you can gather more
information from the following files and APIs:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Lightweight audit messages are stored in <code class="literal">.transform-notifications-read</code>. Search
by your <code class="literal">transform_id</code>.
</li>
<li class="listitem">
The <a class="xref" href="transform-apis.html#get-transform-stats" title="Get transform statistics API">get transform statistics API</a> provides
information about the transform status and failures.
</li>
<li class="listitem">
If the transform exists as a task, you can use the
<a class="xref" href="cluster.html#tasks" title="Task management API">task management API</a> to gather task information. For example:
<code class="literal">GET _tasks?actions=data_frame/transforms*&amp;detailed</code>. Typically, the task exists
when the transform is in a started or failed state.
</li>
<li class="listitem">
The Elasticsearch logs from the node that was running the transform might
also contain useful information. You can identify the node from the notification
messages. Alternatively, if the task still exists, you can get that information
from the get transform statistics API. For more information, see
<a class="xref" href="settings.html#logging" title="Logging">Logging</a>.
</li>
</ul>
</div>
</div>

<div class="section xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="transform-limitations"></a>Transform limitations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/limitations.asciidoc">edit</a><a class="xpack_tag" href="/subscriptions"></a></h2>
</div></div></div>

<p>The following limitations and known problems apply to the 7.10.2 release of
the Elastic transform feature:</p>
<h4><a id="transform-ui-limitation"></a>Transforms UI will not work during a rolling upgrade from 7.2<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/limitations.asciidoc">edit</a></h4>
<p>If your cluster contains mixed version nodes, for example during a rolling
upgrade from 7.2 to a newer version, and transforms have been created in 7.2,
the transforms UI (earler data frame UI) will not work. Please wait until all
nodes have been upgraded to the newer version before using the transforms UI.</p>
<h4><a id="transform-rolling-upgrade-limitation"></a>Transforms reassignment suspended during a rolling upgrade from 7.2 and 7.3<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/limitations.asciidoc">edit</a></h4>
<p>If your cluster contains mixed version nodes, for example during a rolling
upgrade from 7.2 or 7.3 to a newer version, transforms whose nodes are stopped
will not be reassigned until the upgrade is complete. After the upgrade is done,
transforms resume automatically; no action is required.</p>
<h4><a id="transform-datatype-limitations"></a>Data frame data type limitation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/limitations.asciidoc">edit</a></h4>
<p>Data frames do not (yet) support fields containing arrays – in the UI or
the API. If you try to create one, the UI will fail to show the source index
table.</p>
<h4><a id="transform-kibana-limitations"></a>Up to 1,000 transforms are supported<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/limitations.asciidoc">edit</a></h4>
<p>A single cluster will support up to 1,000 transforms. When using the
<a class="xref" href="transform-apis.html#get-transform" title="Get transforms API">GET transforms API</a> a total <code class="literal">count</code> of transforms
is returned. Use the <code class="literal">size</code> and <code class="literal">from</code> parameters to enumerate through the full
list.</p>
<h4><a id="transform-aggresponse-limitations"></a>Aggregation responses may be incompatible with destination index mappings<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/limitations.asciidoc">edit</a></h4>
<p>When a transform is first started, it will deduce the mappings
required for the destination index. This process is based on the field types of
the source index and the aggregations used. If the fields are derived from
<a class="xref" href="search-aggregations-metrics.html#search-aggregations-metrics-scripted-metric-aggregation" title="Scripted metric aggregation"><code class="literal">scripted_metrics</code></a>
or <a class="xref" href="search-aggregations-pipeline.html#search-aggregations-pipeline-bucket-script-aggregation" title="Bucket script aggregation"><code class="literal">bucket_scripts</code></a>,
<a class="xref" href="dynamic-mapping.html" title="Dynamic Mapping">dynamic mappings</a> will be used. In some instances the
deduced mappings may be incompatible with the actual data. For example, numeric
overflows might occur or dynamically mapped fields might contain both numbers
and strings. Please check Elasticsearch logs if you think this may have occurred.</p>
<p>You can view the deduced mappings by using the
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/preview-transform.html" class="ulink" target="_top">Preview transform API</a>.
See the <code class="literal">generated_dest_index</code> object in the API response.</p>
<p>If it&#8217;s required, you may define custom mappings prior to starting the
transform by creating a custom destination index using the
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-create-index.html" class="ulink" target="_top">Create index API</a>.
As deduced mappings cannot be overwritten by an index template, use the Create
index API to define custom mappings. The index templates only apply to fields
derived from scripts that use dynamic mappings.</p>
<h4><a id="transform-batch-limitations"></a>Batch transforms may not account for changed documents<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/limitations.asciidoc">edit</a></h4>
<p>A batch transform uses a
<a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-composite-aggregation" title="Composite aggregation">composite aggregation</a>
which allows efficient pagination through all buckets. Composite aggregations
do not yet support a search context, therefore if the source data is changed
(deleted, updated, added) while the batch data frame is in progress, then the
results may not include these changes.</p>
<h4><a id="transform-consistency-limitations"></a>Continuous transform consistency does not account for deleted or updated documents<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/limitations.asciidoc">edit</a></h4>
<p>While the process for transforms allows the continual recalculation of the
transform as new data is being ingested, it does also have some limitations.</p>
<p>Changed entities will only be identified if their time field has also been
updated and falls within the range of the action to check for changes. This has
been designed in principle for, and is suited to, the use case where new data is
given a timestamp for the time of ingest.</p>
<p>If the indices that fall within the scope of the source index pattern are
removed, for example when deleting historical time-based indices, then the
composite aggregation performed in consecutive checkpoint processing will search
over different source data, and entities that only existed in the deleted index
will not be removed from the data frame destination index.</p>
<p>Depending on your use case, you may wish to recreate the transform entirely
after deletions. Alternatively, if your use case is tolerant to historical
archiving, you may wish to include a max ingest timestamp in your aggregation.
This will allow you to exclude results that have not been recently updated when
viewing the destination index.</p>
<h4><a id="transform-deletion-limitations"></a>Deleting a transform does not delete the destination index or Kibana index pattern<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/limitations.asciidoc">edit</a></h4>
<p>When deleting a transform using <code class="literal">DELETE _transform/index</code>
neither the destination index nor the Kibana index pattern, should one have been
created, are deleted. These objects must be deleted separately.</p>
<h4><a id="transform-aggregation-page-limitations"></a>Handling dynamic adjustment of aggregation page size<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/limitations.asciidoc">edit</a></h4>
<p>During the development of transforms, control was favoured over performance.
In the design considerations, it is preferred for the transform to take longer
to complete quietly in the background rather than to finish quickly and take
precedence in resource consumption.</p>
<p>Composite aggregations are well suited for high cardinality data enabling
pagination through results. If a <a class="xref" href="settings.html#circuit-breaker" title="Circuit breaker settings">circuit breaker</a> memory
exception occurs when performing the composite aggregated search then we try
again reducing the number of buckets requested. This circuit breaker is
calculated based upon all activity within the cluster, not just activity from
transforms, so it therefore may only be a temporary resource
availability issue.</p>
<p>For a batch transform, the number of buckets requested is only ever adjusted
downwards. The lowering of value may result in a longer duration for the
transform checkpoint to complete. For continuous transforms, the number of buckets
requested is reset back to its default at the start of every checkpoint and it
is possible for circuit breaker exceptions to occur repeatedly in the Elasticsearch logs.</p>
<p>The transform retrieves data in batches which means it calculates several
buckets at once. Per default this is 500 buckets per search/index operation. The
default can be changed using <code class="literal">max_page_search_size</code> and the minimum value is 10.
If failures still occur once the number of buckets requested has been reduced to
its minimum, then the transform will be set to a failed state.</p>
<h4><a id="transform-dynamic-adjustments-limitations"></a>Handling dynamic adjustments for many terms<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/limitations.asciidoc">edit</a></h4>
<p>For each checkpoint, entities are identified that have changed since the last
time the check was performed. This list of changed entities is supplied as a
<a class="xref" href="term-level-queries.html#query-dsl-terms-query" title="Terms query">terms query</a> to the transform composite aggregation,
one page at a time. Then updates are applied to the destination index for each
page of entities.</p>
<p>The page <code class="literal">size</code> is defined by <code class="literal">max_page_search_size</code> which is also used to
define the number of buckets returned by the composite aggregation search. The
default value is 500, the minimum is 10.</p>
<p>The index setting <a class="xref" href="index-modules.html#dynamic-index-settings" title="Dynamic index settings"><code class="literal">index.max_terms_count</code></a> defines
the maximum number of terms that can be used in a terms query. The default value
is 65536. If <code class="literal">max_page_search_size</code> exceeds <code class="literal">index.max_terms_count</code> the
transform will fail.</p>
<p>Using smaller values for <code class="literal">max_page_search_size</code> may result in a longer duration
for the transform checkpoint to complete.</p>
<h4><a id="transform-scheduling-limitations"></a>Continuous transform scheduling limitations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/limitations.asciidoc">edit</a></h4>
<p>A continuous transform periodically checks for changes to source data. The functionality
of the scheduler is currently limited to a basic periodic timer which can be
within the <code class="literal">frequency</code> range from 1s to 1h. The default is 1m. This is designed
to run little and often. When choosing a <code class="literal">frequency</code> for this timer consider
your ingest rate along with the impact that the transform
search/index operations has other users in your cluster. Also note that retries
occur at <code class="literal">frequency</code> interval.</p>
<h4><a id="transform-failed-limitations"></a>Handling of failed transforms<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/limitations.asciidoc">edit</a></h4>
<p>Failed transforms remain as a persistent task and should be handled
appropriately, either by deleting it or by resolving the root cause of the
failure and re-starting.</p>
<p>When using the API to delete a failed transform, first stop it using
<code class="literal">_stop?force=true</code>, then delete it.</p>
<h4><a id="transform-availability-limitations"></a>Continuous transforms may give incorrect results if documents are not yet available to search<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/limitations.asciidoc">edit</a></h4>
<p>After a document is indexed, there is a very small delay until it is available
to search.</p>
<p>A continuous transform periodically checks for changed entities between the time since
it last checked and <code class="literal">now</code> minus <code class="literal">sync.time.delay</code>. This time window moves
without overlapping. If the timestamp of a recently indexed document falls
within this time window but this document is not yet available to search then
this entity will not be updated.</p>
<p>If using a <code class="literal">sync.time.field</code> that represents the data ingest time and using a
zero second or very small <code class="literal">sync.time.delay</code>, then it is more likely that this
issue will occur.</p>
<h4><a id="transform-date-nanos"></a>Support for date nanoseconds data type<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/limitations.asciidoc">edit</a></h4>
<p>If your data uses the <a class="xref" href="mapping-types.html#date_nanos" title="Date nanoseconds field type">date nanosecond data type</a>, aggregations
are nonetheless on millisecond resolution. This limitation also affects the
aggregations in your transforms.</p>
<h4><a id="transform-data-streams-destination"></a>Data streams as destination indices are not supported<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/limitations.asciidoc">edit</a></h4>
<p>Transforms update data in the destination index which requires writing
into the destination. <a class="xref" href="data-streams.html" title="Data streams"><em>Data streams</em></a> are designed to be append-only, which
means you cannot send update or delete requests directly to a data stream. For
this reason, data streams are not supported as destination indices for
transforms.</p>
<h4><a id="transform-ilm-destination"></a>ILM as destination index may cause duplicated documents<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/limitations.asciidoc">edit</a></h4>
<p><a class="xref" href="index-lifecycle-management.html" title="ILM: Manage the index lifecycle">ILM</a> is not recommended to use as a transform
destination index. Transforms update documents in the current destination,
and cannot delete documents in the indices previously used by ILM. This may lead
to duplicated documents when you use transforms combined with ILM in case of a
rollover.</p>
<p>If you use ILM to have time-based indices, please consider using the
<a class="xref" href="ingest-processors.html#date-index-name-processor" title="Date index name processor">Date index name</a> instead. The processor works without duplicated
documents if your transform contains a <code class="literal">group_by</code> based on <code class="literal">date_histogram</code>.</p>
<h4><a id="transform-painless-imitation"></a>Using scripts in transforms<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/transform/limitations.asciidoc">edit</a></h4>
<p>Transforms support scripting in every case when aggregations support them.
However, there are certain factors you might want to consider when using scripts
in transforms:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Transforms cannot deduce index mappings for output fields when the
fields are created by a script. In this case, you might want to create the
mappings of the destination index yourself prior to creating the transform.
</li>
<li class="listitem">
Scripted fields may increase the runtime of the transform.
</li>
<li class="listitem">
Transforms cannot optimize queries when you use scripts for all the
groupings defined in <code class="literal">group_by</code>, you will receive a warning message when you
use scripts this way.
</li>
</ul>
</div>
</div>

</div>
<div class="navfooter">
<span class="prev">
<a href="xpack-rollup.html">« Rolling up historical data</a>
</span>
<span class="next">
<a href="high-availability.html">Set up a cluster for high availability »</a>
</span>
</div>
</div>
</body>
</html>
