<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>SQL Language | Elasticsearch Guide | Elastic</title>
<meta class="elastic" name="content" content="SQL Language | Elasticsearch Guide">

<link rel="home" href="index.html" title="Elasticsearch Guide"/>
<link rel="up" href="xpack-sql.html" title="SQL access"/>
<link rel="prev" href="sql-client-apps.html" title="SQL Client Applications"/>
<link rel="next" href="sql-functions.html" title="Functions and Operators"/>
<meta class="elastic" name="product_version" content=""/>
<meta class="elastic" name="product_name" content=""/>
<meta class="elastic" name="website_area" content="documentation"/>
<meta name="DC.type" content="Learn/Docs/"/>
<meta name="DC.subject" content=""/>
<meta name="DC.identifier" content=""/>
</head>
<body>
<div id="content">
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="/guide/">Elastic Docs</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="index.html">Elasticsearch Guide</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="xpack-sql.html">SQL access</a></span>
</div>
<div class="navheader">
<span class="prev">
<a href="sql-client-apps.html">« SQL Client Applications</a>
</span>
<span class="next">
<a href="sql-functions.html">Functions and Operators »</a>
</span>
</div>
<div class="chapter xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="sql-spec"></a>SQL Language<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/sql/language/index.asciidoc">edit</a><a class="xpack_tag" href="/subscriptions"></a></h2>
</div></div></div>
<p>This chapter describes the SQL syntax and semantics supported namely:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<a class="xref" href="sql-spec.html#sql-lexical-structure" title="Lexical Structure">Lexical Structure</a>
</span>
</dt>
<dd>
Lexical structure
</dd>
<dt>
<span class="term">
<a class="xref" href="sql-spec.html#sql-commands" title="SQL Commands">SQL Commands</a>
</span>
</dt>
<dd>
Commands
</dd>
<dt>
<span class="term">
<a class="xref" href="sql-spec.html#sql-data-types" title="Data Types">Data Types</a>
</span>
</dt>
<dd>
Data types
</dd>
<dt>
<span class="term">
<a class="xref" href="sql-spec.html#sql-index-patterns" title="Index patterns">Index patterns</a>
</span>
</dt>
<dd>
Index patterns
</dd>
</dl>
</div>
<div class="section xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="sql-lexical-structure"></a>Lexical Structure<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/sql/language/syntax/lexic/index.asciidoc">edit</a><a class="xpack_tag" href="/subscriptions"></a></h2>
</div></div></div>
<p>This section covers the major lexical structure of SQL, which for the most part, is going to resemble that of ANSI SQL itself hence why low-levels details are not discussed in depth.</p>
<p>Elasticsearch SQL currently accepts only one <em>command</em> at a time. A command is a sequence of <em>tokens</em> terminated by the end of input stream.</p>
<p>A token can be a <em>key word</em>, an <em>identifier</em> (<em>quoted</em> or <em>unquoted</em>), a <em>literal</em> (or constant) or a special character symbol (typically a delimiter). Tokens are typically separated by whitespace (be it space, tab) though in some cases, where there is no ambiguity (typically due to a character symbol) this is not needed - however for readability purposes this should be avoided.</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="sql-syntax-keywords"></a>Key Words<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/sql/language/syntax/lexic/index.asciidoc">edit</a></h3>
</div></div></div>
<p>Take the following example:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT * FROM table</pre>
</div>
<p>This query has four tokens: <code class="literal">SELECT</code>, <code class="literal">*</code>, <code class="literal">FROM</code> and <code class="literal">table</code>. The first three, namely <code class="literal">SELECT</code>, <code class="literal">*</code> and <code class="literal">FROM</code> are <em>key words</em> meaning words that have a fixed meaning in SQL. The token <code class="literal">table</code> is an <em>identifier</em> meaning it identifies (by name) an entity inside SQL such as a table (in this case), a column, etc&#8230;&#8203;</p>
<p>As one can see, both key words and identifiers have the <em>same</em> lexical structure and thus one cannot know whether a token is one or the other without knowing the SQL language; the complete list of key words is available in the <a class="xref" href="sql-syntax-reserved.html" title="Reserved keywords">reserved appendix</a>.
Do note that key words are case-insensitive meaning the previous example can be written as:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">select * fRoM table;</pre>
</div>
<p>Identifiers however are not - as Elasticsearch is case sensitive, Elasticsearch SQL uses the received value verbatim.</p>
<p>To help differentiate between the two, through-out the documentation the SQL key words are upper-cased a convention we find increases readability and thus recommend to others.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="sql-syntax-identifiers"></a>Identifiers<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/sql/language/syntax/lexic/index.asciidoc">edit</a></h3>
</div></div></div>
<p>Identifiers can be of two types: <em>quoted</em> and <em>unquoted</em>:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT ip_address FROM "hosts-*"</pre>
</div>
<p>This query has two identifiers, <code class="literal">ip_address</code> and <code class="literal">hosts-*</code> (an <a class="xref" href="api-conventions.html#multi-index" title="Multi-target syntax">index pattern</a>). As <code class="literal">ip_address</code> does not clash with any key words it can be used verbatim, <code class="literal">hosts-*</code> on the other hand cannot as it clashes with <code class="literal">-</code> (minus operation) and <code class="literal">*</code> hence the double quotes.</p>
<p>Another example:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT "from" FROM "&lt;logstash-{now/d}&gt;"</pre>
</div>
<p>The first identifier from needs to quoted as otherwise it clashes with the <code class="literal">FROM</code> key word (which is case insensitive as thus can be written as <code class="literal">from</code>) while the second identifier using Elasticsearch <a class="xref" href="api-conventions.html#date-math-index-names" title="Date math support in index names">Date math support in index names</a> would have otherwise confuse the parser.</p>
<p>Hence why in general, <span class="strong strong"><strong>especially</strong></span> when dealing with user input it is <span class="strong strong"><strong>highly</strong></span> recommended to use quotes for identifiers. It adds minimal increase to your queries and in return offers clarity and disambiguation.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="sql-syntax-literals"></a>Literals (Constants)<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/sql/language/syntax/lexic/index.asciidoc">edit</a></h3>
</div></div></div>
<p>Elasticsearch SQL supports two kind of <em>implicitly-typed</em> literals: strings and numbers.</p>
<h5><a id="sql-syntax-string-literals"></a>String Literals<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/sql/language/syntax/lexic/index.asciidoc">edit</a></h5>
<p>A string literal is an arbitrary number of characters bounded by single quotes <code class="literal">'</code>: <code class="literal">'Giant Robot'</code>.
To include a single quote in the string, escape it using another single quote: <code class="literal">'Captain EO''s Voyage'</code>.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>An escaped single quote is <span class="strong strong"><strong>not</strong></span> a double quote (<code class="literal">"</code>), but a single quote <code class="literal">'</code> <em>repeated</em> (<code class="literal">''</code>).</p>
</div>
</div>
<h5><a id="_numeric_literals"></a>Numeric Literals<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/sql/language/syntax/lexic/index.asciidoc">edit</a></h5>
<p>Numeric literals are accepted both in decimal and scientific notation with exponent marker (<code class="literal">e</code> or <code class="literal">E</code>), starting either with a digit or decimal point <code class="literal">.</code>:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">1969    -- integer notation
3.14    -- decimal notation
.1234   -- decimal notation starting with decimal point
4E5     -- scientific notation (with exponent marker)
1.2e-3  -- scientific notation with decimal point</pre>
</div>
<p>Numeric literals that contain a decimal point are always interpreted as being of type <code class="literal">double</code>. Those without are considered <code class="literal">integer</code> if they fit otherwise their type is <code class="literal">long</code> (or <code class="literal">BIGINT</code> in ANSI SQL types).</p>
<h5><a id="sql-syntax-generic-literals"></a>Generic Literals<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/sql/language/syntax/lexic/index.asciidoc">edit</a></h5>
<p>When dealing with arbitrary type literal, one creates the object by casting, typically, the string representation to the desired type. This can be achieved through the dedicated <a class="xref" href="sql-functions.html#sql-operators-cast" title="Cast Operators">cast operator</a> and <a class="xref" href="sql-functions.html#sql-functions-type-conversion" title="Type Conversion Functions">functions</a>:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">123::LONG                                   -- cast 123 to a LONG
CAST('1969-05-13T12:34:56' AS TIMESTAMP)    -- cast the given string to datetime
CONVERT('10.0.0.1', IP)                     -- cast '10.0.0.1' to an IP</pre>
</div>
<p>Do note that Elasticsearch SQL provides functions that out of the box return popular literals (like <code class="literal">E()</code>) or provide dedicated parsing for certain strings.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="sql-syntax-single-vs-double-quotes"></a>Single vs Double Quotes<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/sql/language/syntax/lexic/index.asciidoc">edit</a></h3>
</div></div></div>
<p>It is worth pointing out that in SQL, single quotes <code class="literal">'</code> and double quotes <code class="literal">"</code> have different meaning and <span class="strong strong"><strong>cannot</strong></span> be used interchangeably.
Single quotes are used to declare a <a class="xref" href="sql-spec.html#sql-syntax-string-literals" title="String Literals">string literal</a> while double quotes for <a class="xref" href="sql-spec.html#sql-syntax-identifiers" title="Identifiers">identifiers</a>.</p>
<p>To wit:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT "first_name" <a id="CO341-1"></a><i class="conum" data-value="1"></i>
  FROM "musicians"  <a id="CO341-2"></a><i class="conum" data-value="1"></i>
 WHERE "last_name"  <a id="CO341-3"></a><i class="conum" data-value="1"></i>
     = 'Carroll'    <a id="CO341-4"></a><i class="conum" data-value="2"></i></pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO341-1"><i class="conum" data-value="1"></i></a><a href="#CO341-2"></a><a href="#CO341-3"></a></p>
</td>
<td align="left" valign="top">
<p>Double quotes <code class="literal">"</code> used for column and table identifiers</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO341-4"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>Single quotes <code class="literal">'</code> used for a string literal</p>
</td>
</tr>
</table>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>To escape single or double quotes, one needs to use that specific quote one more time. For example, the literal <code class="literal">John's</code> can be escaped like
<code class="literal">SELECT 'John''s' AS name</code>. The same goes for double quotes escaping - <code class="literal">SELECT 123 AS "test""number"</code> will display as a result a column with the name <code class="literal">test"number</code>.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="sql-syntax-special-chars"></a>Special characters<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/sql/language/syntax/lexic/index.asciidoc">edit</a></h3>
</div></div></div>
<p>A few characters that are not alphanumeric have a dedicated meaning different from that of an operator. For completeness these are specified below:</p>
<div class="informaltable">
<table border="1" cellpadding="4px">
<colgroup>
<col class="col_1"/>
<col class="col_2"/>
</colgroup>
<tbody>
<tr>
<td align="center" valign="top"><p><span class="strong strong"><strong>Char</strong></span></p></td>
<td align="center" valign="top"><p><span class="strong strong"><strong>Description</strong></span></p></td>
</tr>
<tr>
<td align="center" valign="top"><p><code class="literal">*</code></p></td>
<td align="center" valign="top"><p>The asterisk (or wildcard) is used in some contexts to denote all fields for a table. Can be also used as an argument to some aggregate functions.</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><code class="literal">,</code></p></td>
<td align="center" valign="top"><p>Commas are used to enumerate the elements of a list.</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><code class="literal">.</code></p></td>
<td align="center" valign="top"><p>Used in numeric constants or to separate identifiers qualifiers (catalog, table, column names, etc&#8230;&#8203;).</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><code class="literal">()</code></p></td>
<td align="center" valign="top"><p>Parentheses are used for specific SQL commands, function declarations or to enforce precedence.</p></td>
</tr>
</tbody>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="sql-syntax-operators"></a>Operators<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/sql/language/syntax/lexic/index.asciidoc">edit</a></h3>
</div></div></div>
<p>Most operators in Elasticsearch SQL have the same precedence and are left-associative. As this is done at parsing time, parenthesis need to be used to enforce a different precedence.</p>
<p>The following table indicates the supported operators and their precedence (highest to lowest);</p>
<div class="informaltable">
<table border="1" cellpadding="4px">
<colgroup>
<col class="col_1"/>
<col class="col_2"/>
<col class="col_3"/>
</colgroup>
<tbody>
<tr>
<td align="center" valign="top"><p><span class="strong strong"><strong>Operator/Element</strong></span></p></td>
<td align="center" valign="top"><p><span class="strong strong"><strong>Associativity</strong></span></p></td>
<td align="center" valign="top"><p><span class="strong strong"><strong>Description</strong></span></p></td>
</tr>
<tr>
<td align="center" valign="top"><p><code class="literal">.</code></p></td>
<td align="center" valign="top"><p>left</p></td>
<td align="center" valign="top"><p>qualifier separator</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><code class="literal">::</code></p></td>
<td align="center" valign="top"><p>left</p></td>
<td align="center" valign="top"><p>PostgreSQL-style type cast</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><code class="literal">+ -</code></p></td>
<td align="center" valign="top"><p>right</p></td>
<td align="center" valign="top"><p>unary plus and minus (numeric literal sign)</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><code class="literal">* / %</code></p></td>
<td align="center" valign="top"><p>left</p></td>
<td align="center" valign="top"><p>multiplication, division, modulo</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><code class="literal">+ -</code></p></td>
<td align="center" valign="top"><p>left</p></td>
<td align="center" valign="top"><p>addition, subtraction</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><code class="literal">BETWEEN IN LIKE</code></p></td>
<td align="center" valign="top"><p></p></td>
<td align="center" valign="top"><p>range containment, string matching</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><code class="literal">< > <= >= = <=> <> !=</code></p></td>
<td align="center" valign="top"><p></p></td>
<td align="center" valign="top"><p>comparison</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><code class="literal">NOT</code></p></td>
<td align="center" valign="top"><p>right</p></td>
<td align="center" valign="top"><p>logical negation</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><code class="literal">AND</code></p></td>
<td align="center" valign="top"><p>left</p></td>
<td align="center" valign="top"><p>logical conjunction</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><code class="literal">OR</code></p></td>
<td align="center" valign="top"><p>left</p></td>
<td align="center" valign="top"><p>logical disjunction</p></td>
</tr>
</tbody>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="sql-syntax-comments"></a>Comments<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/sql/language/syntax/lexic/index.asciidoc">edit</a></h3>
</div></div></div>
<p>Elasticsearch SQL allows comments which are sequence of characters ignored by the parsers.</p>
<p>Two styles are supported:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
Single Line
</span>
</dt>
<dd>
Comments start with a double dash <code class="literal">--</code> and continue until the end of the line.
</dd>
<dt>
<span class="term">
Multi line
</span>
</dt>
<dd>
Comments that start with <code class="literal">/*</code> and end with <code class="literal">*/</code> (also known as C-style).
</dd>
</dl>
</div>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">-- single line comment
/* multi
   line
   comment
   that supports /* nested comments */
   */</pre>
</div>
</div>

</div>

<div class="section xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="sql-commands"></a>SQL Commands<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/sql/language/syntax/commands/index.asciidoc">edit</a><a class="xpack_tag" href="/subscriptions"></a></h2>
</div></div></div>
<p>This section contains the list of SQL commands supported by Elasticsearch SQL along with their syntax:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<a class="xref" href="sql-spec.html#sql-syntax-describe-table" title="DESCRIBE TABLE">DESCRIBE TABLE</a>
</span>
</dt>
<dd>
Describe a table.
</dd>
<dt>
<span class="term">
<a class="xref" href="sql-spec.html#sql-syntax-select" title="SELECT">SELECT</a>
</span>
</dt>
<dd>
Retrieve rows from zero or more tables.
</dd>
<dt>
<span class="term">
<a class="xref" href="sql-spec.html#sql-syntax-show-columns" title="SHOW COLUMNS">SHOW COLUMNS</a>
</span>
</dt>
<dd>
List columns in table.
</dd>
<dt>
<span class="term">
<a class="xref" href="sql-spec.html#sql-syntax-show-functions" title="SHOW FUNCTIONS">SHOW FUNCTIONS</a>
</span>
</dt>
<dd>
List supported functions.
</dd>
<dt>
<span class="term">
<a class="xref" href="sql-spec.html#sql-syntax-show-tables" title="SHOW TABLES">SHOW TABLES</a>
</span>
</dt>
<dd>
List tables available.
</dd>
</dl>
</div>
</div>

<div class="section xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="sql-syntax-describe-table"></a>DESCRIBE TABLE<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/sql/language/syntax/commands/describe-table.asciidoc">edit</a><a class="xpack_tag" href="/subscriptions"></a></h2>
</div></div></div>
<p><strong>Synopsis:</strong></p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">DESCRIBE
    [table identifier | <a id="CO342-1"></a><i class="conum" data-value="1"></i>
    [LIKE pattern]]     <a id="CO342-2"></a><i class="conum" data-value="2"></i></pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO342-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>single table identifier or double quoted es multi index</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO342-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>SQL LIKE pattern</p>
</td>
</tr>
</table>
</div>
<p>or</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">DESC
    [table identifier | <a id="CO343-1"></a><i class="conum" data-value="1"></i>
    [LIKE pattern]]     <a id="CO343-2"></a><i class="conum" data-value="2"></i></pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO343-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>single table identifier or double quoted es multi index</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO343-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>SQL LIKE pattern</p>
</td>
</tr>
</table>
</div>
<p><span class="strong strong"><strong>Description</strong></span>: <code class="literal">DESC</code> and <code class="literal">DESCRIBE</code> are aliases to <a class="xref" href="sql-spec.html#sql-syntax-show-columns" title="SHOW COLUMNS">SHOW COLUMNS</a>.</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">DESCRIBE emp;

       column       |     type      |    mapping
--------------------+---------------+---------------
birth_date          |TIMESTAMP      |datetime
dep                 |STRUCT         |nested
dep.dep_id          |VARCHAR        |keyword
dep.dep_name        |VARCHAR        |text
dep.dep_name.keyword|VARCHAR        |keyword
dep.from_date       |TIMESTAMP      |datetime
dep.to_date         |TIMESTAMP      |datetime
emp_no              |INTEGER        |integer
first_name          |VARCHAR        |text
first_name.keyword  |VARCHAR        |keyword
gender              |VARCHAR        |keyword
hire_date           |TIMESTAMP      |datetime
languages           |TINYINT        |byte
last_name           |VARCHAR        |text
last_name.keyword   |VARCHAR        |keyword
salary              |INTEGER        |integer</pre>
</div>
</div>

<div class="section xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="sql-syntax-select"></a>SELECT<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/sql/language/syntax/commands/select.asciidoc">edit</a><a class="xpack_tag" href="/subscriptions"></a></h2>
</div></div></div>
<p><strong>Synopsis:</strong></p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT [TOP [ count ] ] select_expr [, ...]
[ FROM table_name ]
[ WHERE condition ]
[ GROUP BY grouping_element [, ...] ]
[ HAVING condition]
[ ORDER BY expression [ ASC | DESC ] [, ...] ]
[ LIMIT [ count ] ]
[ PIVOT ( aggregation_expr FOR column IN ( value [ [ AS ] alias ] [, ...] ) ) ]</pre>
</div>
<p><span class="strong strong"><strong>Description</strong></span>: Retrieves rows from zero or more tables.</p>
<p>The general execution of <code class="literal">SELECT</code> is as follows:</p>
<div class="olist orderedlist">
<ol class="orderedlist">
<li class="listitem">
All elements in the <code class="literal">FROM</code> list are computed (each element can be base or alias table). Currently <code class="literal">FROM</code> supports exactly one table. Do note however that the table name can be a pattern (see <a class="xref" href="sql-spec.html#sql-syntax-from" title="FROM Clause">FROM Clause</a> below).
</li>
<li class="listitem">
If the <code class="literal">WHERE</code> clause is specified, all rows that do not satisfy the condition are eliminated from the output. (See <a class="xref" href="sql-spec.html#sql-syntax-where" title="WHERE Clause">WHERE Clause</a> below.)
</li>
<li class="listitem">
If the <code class="literal">GROUP BY</code> clause is specified, or if there are aggregate function calls, the output is combined into groups of rows that match on one or more values, and the results of aggregate functions are computed. If the <code class="literal">HAVING</code> clause is present, it eliminates groups that do not satisfy the given condition. (See <a class="xref" href="sql-spec.html#sql-syntax-group-by" title="GROUP BY">GROUP BY Clause</a> and <a class="xref" href="sql-spec.html#sql-syntax-having" title="HAVING">HAVING Clause</a> below.)
</li>
<li class="listitem">
The actual output rows are computed using the <code class="literal">SELECT</code> output expressions for each selected row or row group.
</li>
<li class="listitem">
If the <code class="literal">ORDER BY</code> clause is specified, the returned rows are sorted in the specified order. If <code class="literal">ORDER BY</code> is not given, the rows are returned in whatever order the system finds fastest to produce. (See <a class="xref" href="sql-spec.html#sql-syntax-order-by" title="ORDER BY">ORDER BY Clause</a> below.)
</li>
<li class="listitem">
If the <code class="literal">LIMIT</code> or <code class="literal">TOP</code> is specified (cannot use both in the same query), the <code class="literal">SELECT</code> statement only returns a subset of the result rows. (See <a class="xref" href="sql-spec.html#sql-syntax-limit" title="LIMIT">LIMIT Clause</a> and <a class="xref" href="sql-spec.html#sql-syntax-top" title="TOP">TOP clause</a> below.)
</li>
</ol>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="sql-syntax-select-list"></a><code class="literal">SELECT</code> List<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/sql/language/syntax/commands/select.asciidoc">edit</a></h3>
</div></div></div>
<p><code class="literal">SELECT</code> list, namely the expressions between <code class="literal">SELECT</code> and <code class="literal">FROM</code>, represent the output rows of the <code class="literal">SELECT</code> statement.</p>
<p>As with a table, every output column of a <code class="literal">SELECT</code> has a name which can be either specified per column through the <code class="literal">AS</code> keyword :</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT 1 + 1 AS result;

    result
---------------
2</pre>
</div>
<p>Note: <code class="literal">AS</code> is an optional keyword however it helps with the readability and in some case ambiguity of the query
which is why it is recommended to specify it.</p>
<p>assigned by Elasticsearch SQL if no name is given:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT 1 + 1;

    1 + 1
--------------
2</pre>
</div>
<p>or if it&#8217;s a simple column reference, use its name as the column name:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT emp_no FROM emp LIMIT 1;

    emp_no
---------------
10001</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="sql-syntax-select-wildcard"></a>Wildcard<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/sql/language/syntax/commands/select.asciidoc">edit</a></h3>
</div></div></div>
<p>To select all the columns in the source, one can use <code class="literal">*</code>:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT * FROM emp LIMIT 1;

     birth_date     |    emp_no     |  first_name   |    gender     |     hire_date      |   languages   |   last_name   |    salary
--------------------+---------------+---------------+---------------+--------------------+---------------+---------------+---------------
1953-09-02T00:00:00Z|10001          |Georgi         |M              |1986-06-26T00:00:00Z|2              |Facello        |57305</pre>
</div>
<p>which essentially returns all(top-level fields, sub-fields, such as multi-fields are ignored] columns found.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="sql-syntax-top"></a>TOP<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/sql/language/syntax/commands/select.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">TOP</code> clause can be used before the <a class="xref" href="sql-spec.html#sql-syntax-select-list" title="SELECT List"><code class="literal">SELECT</code> list</a> or the &lt;&lt;sql-syntax-select-wildcard, <code class="literal">wildcard</code>&gt; to
restrict (limit) the number of rows returned using the format:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT TOP &lt;count&gt; &lt;select list&gt; ...</pre>
</div>
<p>where</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
count
</span>
</dt>
<dd>
is a positive integer or zero indicating the maximum <span class="strong strong"><strong>possible</strong></span> number of results being returned (as there might be fewer matches
than the limit). If <code class="literal">0</code> is specified, no results are returned.
</dd>
</dl>
</div>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT TOP 2 first_name, last_name, emp_no FROM emp;

  first_name   |   last_name   |    emp_no
---------------+---------------+---------------
Georgi         |Facello        |10001
Bezalel        |Simmel         |10002</pre>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p><a class="xref" href="sql-spec.html#sql-syntax-top" title="TOP"><code class="literal">TOP</code></a> and <a class="xref" href="sql-spec.html#sql-syntax-limit" title="LIMIT"><code class="literal">LIMIT</code></a> cannot be used together in the same query and an error is returned otherwise.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="sql-syntax-from"></a>FROM Clause<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/sql/language/syntax/commands/select.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">FROM</code> clause specifies one table for the <code class="literal">SELECT</code> and has the following syntax:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">FROM table_name [ [ AS ] alias ]</pre>
</div>
<p>where:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">table_name</code>
</span>
</dt>
<dd>
Represents the name (optionally qualified) of an existing table, either a concrete or base one (actual index) or alias.
</dd>
</dl>
</div>
<p>If the table name contains special SQL characters (such as <code class="literal">.</code>,<code class="literal">-</code>,<code class="literal">*</code>,etc&#8230;&#8203;) use double quotes to escape them:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT * FROM "emp" LIMIT 1;

     birth_date     |    emp_no     |  first_name   |    gender     |     hire_date      |   languages   |   last_name   |    salary
--------------------+---------------+---------------+---------------+--------------------+---------------+---------------+---------------
1953-09-02T00:00:00Z|10001          |Georgi         |M              |1986-06-26T00:00:00Z|2              |Facello        |57305</pre>
</div>
<p>The name can be a <a class="xref" href="api-conventions.html#multi-index" title="Multi-target syntax">pattern</a> pointing to multiple indices (likely requiring quoting as mentioned above) with the restriction that <span class="strong strong"><strong>all</strong></span> resolved concrete tables have <span class="strong strong"><strong>exact mapping</strong></span>.</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT emp_no FROM "e*p" LIMIT 1;

    emp_no
---------------
10001</pre>
</div>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">alias</code>
</span>
</dt>
<dd>
A substitute name for the <code class="literal">FROM</code> item containing the alias. An alias is used for brevity or to eliminate ambiguity. When an alias is provided, it completely hides the actual name of the table and must be used in its place.
</dd>
</dl>
</div>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT e.emp_no FROM emp AS e LIMIT 1;

    emp_no
-------------
10001</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="sql-syntax-where"></a>WHERE Clause<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/sql/language/syntax/commands/select.asciidoc">edit</a></h3>
</div></div></div>
<p>The optional <code class="literal">WHERE</code> clause is used to filter rows from the query and has the following syntax:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">WHERE condition</pre>
</div>
<p>where:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">condition</code>
</span>
</dt>
<dd>
Represents an expression that evaluates to a <code class="literal">boolean</code>. Only the rows that match the condition (to <code class="literal">true</code>) are returned.
</dd>
</dl>
</div>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT last_name FROM emp WHERE emp_no = 10001;

   last_name
---------------
Facello</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="sql-syntax-group-by"></a>GROUP BY<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/sql/language/syntax/commands/select.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">GROUP BY</code> clause is used to divide the results into groups of rows on matching values from the designated columns. It has the following syntax:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">GROUP BY grouping_element [, ...]</pre>
</div>
<p>where:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">grouping_element</code>
</span>
</dt>
<dd>
Represents an expression on which rows are being grouped <em>on</em>. It can be a column name, alias or ordinal number of a column or an arbitrary expression of column values.
</dd>
</dl>
</div>
<p>A common, group by column name:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT gender AS g FROM emp GROUP BY gender;

       g
---------------
null
F
M</pre>
</div>
<p>Grouping by output ordinal:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT gender FROM emp GROUP BY 1;

    gender
---------------
null
F
M</pre>
</div>
<p>Grouping by alias:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT gender AS g FROM emp GROUP BY g;

       g
---------------
null
F
M</pre>
</div>
<p>And grouping by column expression (typically used along-side an alias):</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT languages + 1 AS l FROM emp GROUP BY l;

       l
---------------
null
2
3
4
5
6</pre>
</div>
<p>Or a mixture of the above:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT gender g, languages l, COUNT(*) c FROM "emp" GROUP BY g, l ORDER BY languages ASC, gender DESC;

       g       |       l       |       c
---------------+---------------+---------------
M              |null           |7
F              |null           |3
M              |1              |9
F              |1              |4
null           |1              |2
M              |2              |11
F              |2              |5
null           |2              |3
M              |3              |11
F              |3              |6
M              |4              |11
F              |4              |6
null           |4              |1
M              |5              |8
F              |5              |9
null           |5              |4</pre>
</div>
<p>When a <code class="literal">GROUP BY</code> clause is used in a <code class="literal">SELECT</code>, <em>all</em> output expressions must be either aggregate functions or expressions used for grouping or derivatives of (otherwise there would be more than one possible value to return for each ungrouped column).</p>
<p>To wit:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT gender AS g, COUNT(*) AS c FROM emp GROUP BY gender;

       g       |       c
---------------+---------------
null           |10
F              |33
M              |57</pre>
</div>
<p>Expressions over aggregates used in output:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT gender AS g, ROUND((MIN(salary) / 100)) AS salary FROM emp GROUP BY gender;

       g       |    salary
---------------+---------------
null           |253
F              |260
M              |259</pre>
</div>
<p>Multiple aggregates used:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT gender AS g, KURTOSIS(salary) AS k, SKEWNESS(salary) AS s FROM emp GROUP BY gender;

       g       |        k         |         s
---------------+------------------+-------------------
null           |2.2215791166941923|-0.03373126000214023
F              |1.7873117044424276|0.05504995122217512
M              |2.280646181070106 |0.44302407229580243</pre>
</div>
<div class="tip admon">
<div class="icon"></div>
<div class="admon_content">
<p>If custom bucketing is required, it can be achieved with the use of <a class="xref" href="sql-functions.html#sql-functions-conditional-case" title="CASE"><code class="literal">CASE</code></a>,
as shown <a class="xref" href="sql-functions.html#sql-functions-conditional-case-groupby-custom-buckets" title="Conditional bucketing">here</a>.</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="sql-syntax-group-by-implicit"></a>Implicit Grouping<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/sql/language/syntax/commands/select.asciidoc">edit</a></h4>
</div></div></div>
<p>When an aggregation is used without an associated <code class="literal">GROUP BY</code>, an <em>implicit grouping</em> is applied, meaning all selected rows are considered to form a single default, or implicit group.
As such, the query emits only a single row (as there is only a single group).</p>
<p>A common example is counting the number of records:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT COUNT(*) AS count FROM emp;

     count
---------------
100</pre>
</div>
<p>Of course, multiple aggregations can be applied:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT MIN(salary) AS min, MAX(salary) AS max, AVG(salary) AS avg, COUNT(*) AS count FROM emp;

      min:i    |      max:i    |      avg:d    |     count:l
---------------+---------------+---------------+---------------
25324          |74999          |48248.55       |100</pre>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="sql-syntax-having"></a>HAVING<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/sql/language/syntax/commands/select.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">HAVING</code> clause can be used <em>only</em> along aggregate functions (and thus <code class="literal">GROUP BY</code>) to filter what groups are kept or not and has the following syntax:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">HAVING condition</pre>
</div>
<p>where:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">condition</code>
</span>
</dt>
<dd>
Represents an expression that evaluates to a <code class="literal">boolean</code>. Only groups that match the condition (to <code class="literal">true</code>) are returned.
</dd>
</dl>
</div>
<p>Both <code class="literal">WHERE</code> and <code class="literal">HAVING</code> are used for filtering however there are several significant differences between them:</p>
<div class="olist orderedlist">
<ol class="orderedlist">
<li class="listitem">
<code class="literal">WHERE</code> works on individual <span class="strong strong"><strong>rows</strong></span>, <code class="literal">HAVING</code> works on the <span class="strong strong"><strong>groups</strong></span> created by ``GROUP BY``
</li>
<li class="listitem">
<code class="literal">WHERE</code> is evaluated <span class="strong strong"><strong>before</strong></span> grouping, <code class="literal">HAVING</code> is evaluated <span class="strong strong"><strong>after</strong></span> grouping
</li>
</ol>
</div>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT languages AS l, COUNT(*) AS c FROM emp GROUP BY l HAVING c BETWEEN 15 AND 20;

       l       |       c
---------------+---------------
1              |15
2              |19
3              |17
4              |18</pre>
</div>
<p>Further more, one can use multiple aggregate expressions inside <code class="literal">HAVING</code> even ones that are not used in the output (<code class="literal">SELECT</code>):</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT MIN(salary) AS min, MAX(salary) AS max, MAX(salary) - MIN(salary) AS diff FROM emp GROUP BY languages HAVING diff - max % min &gt; 0 AND AVG(salary) &gt; 30000;

      min      |      max      |     diff
---------------+---------------+---------------
28336          |74999          |46663
25976          |73717          |47741
29175          |73578          |44403
26436          |74970          |48534
27215          |74572          |47357
25324          |66817          |41493</pre>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="sql-syntax-having-group-by-implicit"></a>Implicit Grouping<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/sql/language/syntax/commands/select.asciidoc">edit</a></h4>
</div></div></div>
<p>As indicated above, it is possible to have a <code class="literal">HAVING</code> clause without a <code class="literal">GROUP BY</code>. In this case, the so-called <a class="xref" href="sql-spec.html#sql-syntax-group-by-implicit" title="Implicit Grouping"><em>implicit grouping</em></a> is applied, meaning all selected rows are considered to form a single group and <code class="literal">HAVING</code> can be applied on any of the aggregate functions specified on this group.
As such, the query emits only a single row (as there is only a single group) and <code class="literal">HAVING</code> condition returns either one row (the group) or zero if the condition fails.</p>
<p>In this example, <code class="literal">HAVING</code> matches:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT MIN(salary) AS min, MAX(salary) AS max FROM emp HAVING min &gt; 25000;

      min      |      max
---------------+---------------
25324          |74999</pre>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="sql-syntax-order-by"></a>ORDER BY<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/sql/language/syntax/commands/select.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">ORDER BY</code> clause is used to sort the results of <code class="literal">SELECT</code> by one or more expressions:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">ORDER BY expression [ ASC | DESC ] [, ...]</pre>
</div>
<p>where:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">expression</code>
</span>
</dt>
<dd>
Represents an input column, an output column or an ordinal number of the position (starting from one) of an output column. Additionally, ordering can be done based on the results <em>score</em>.
The direction, if not specified, is by default <code class="literal">ASC</code> (ascending).
Regardless of the ordering specified, null values are ordered last (at the end).
</dd>
</dl>
</div>
<div class="important admon">
<div class="icon"></div>
<div class="admon_content">
<p>When used along-side, <code class="literal">GROUP BY</code> expression can point <em>only</em> to the columns used for grouping or aggregate functions.</p>
</div>
</div>
<p>For example, the following query sorts by an arbitrary input field (<code class="literal">page_count</code>):</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT * FROM library ORDER BY page_count DESC LIMIT 5;

     author      |        name        |  page_count   |    release_date
-----------------+--------------------+---------------+--------------------
Peter F. Hamilton|Pandora's Star      |768            |2004-03-02T00:00:00Z
Vernor Vinge     |A Fire Upon the Deep|613            |1992-06-01T00:00:00Z
Frank Herbert    |Dune                |604            |1965-06-01T00:00:00Z
Alastair Reynolds|Revelation Space    |585            |2000-03-15T00:00:00Z
James S.A. Corey |Leviathan Wakes     |561            |2011-06-02T00:00:00Z</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="sql-syntax-order-by-grouping"></a>Order By and Grouping<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/sql/language/syntax/commands/select.asciidoc">edit</a></h3>
</div></div></div>
<p>For queries that perform grouping, ordering can be applied either on the grouping columns (by default ascending) or on aggregate functions.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>With <code class="literal">GROUP BY</code>, make sure the ordering targets the resulting group - applying it to individual elements inside the group will have no impact on the results since regardless of the order, values inside the group are aggregated.</p>
</div>
</div>
<p>For example, to order groups simply indicate the grouping key:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT gender AS g, COUNT(*) AS c FROM emp GROUP BY gender ORDER BY g DESC;

       g       |       c
---------------+---------------
M              |57
F              |33
null           |10</pre>
</div>
<p>Multiple keys can be specified of course:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT gender g, languages l, COUNT(*) c FROM "emp" GROUP BY g, l ORDER BY languages ASC, gender DESC;

       g       |       l       |       c
---------------+---------------+---------------
M              |null           |7
F              |null           |3
M              |1              |9
F              |1              |4
null           |1              |2
M              |2              |11
F              |2              |5
null           |2              |3
M              |3              |11
F              |3              |6
M              |4              |11
F              |4              |6
null           |4              |1
M              |5              |8
F              |5              |9
null           |5              |4</pre>
</div>
<p>Further more, it is possible to order groups based on aggregations of their values:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT gender AS g, MIN(salary) AS salary FROM emp GROUP BY gender ORDER BY salary DESC;

       g       |    salary
---------------+---------------
F              |25976
M              |25945
null           |25324</pre>
</div>
<div class="important admon">
<div class="icon"></div>
<div class="admon_content">
<p>Ordering by aggregation is possible for up to <span class="strong strong"><strong>10000</strong></span> entries for memory consumption reasons.
In cases where the results pass this threshold, use <a class="xref" href="sql-spec.html#sql-syntax-limit" title="LIMIT"><code class="literal">LIMIT</code></a> or <a class="xref" href="sql-spec.html#sql-syntax-top" title="TOP"><code class="literal">TOP</code></a> to reduce the number
of results.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="sql-syntax-order-by-score"></a>Order By Score<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/sql/language/syntax/commands/select.asciidoc">edit</a></h3>
</div></div></div>
<p>When doing full-text queries in the <code class="literal">WHERE</code> clause, results can be returned based on their
<a href="https://www.elastic.co/guide/en/elasticsearch/guide/2.x/relevance-intro.html" class="ulink" target="_top">score</a> or <em>relevance</em> to the given query.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>When doing multiple text queries in the <code class="literal">WHERE</code> clause then, their scores will be
combined using the same rules as Elasticsearch&#8217;s
<a class="xref" href="compound-queries.html#query-dsl-bool-query" title="Boolean query">bool query</a>.</p>
</div>
</div>
<p>To sort based on the <code class="literal">score</code>, use the special function <code class="literal">SCORE()</code>:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT SCORE(), * FROM library WHERE MATCH(name, 'dune') ORDER BY SCORE() DESC;

    SCORE()    |    author     |       name        |  page_count   |    release_date
---------------+---------------+-------------------+---------------+--------------------
2.2886353      |Frank Herbert  |Dune               |604            |1965-06-01T00:00:00Z
1.8893257      |Frank Herbert  |Dune Messiah       |331            |1969-10-15T00:00:00Z
1.6086556      |Frank Herbert  |Children of Dune   |408            |1976-04-21T00:00:00Z
1.4005898      |Frank Herbert  |God Emperor of Dune|454            |1981-05-28T00:00:00Z</pre>
</div>
<p>Note that you can return <code class="literal">SCORE()</code> by using a full-text search predicate in the <code class="literal">WHERE</code> clause.
This is possible even if <code class="literal">SCORE()</code> is not used for sorting:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT SCORE(), * FROM library WHERE MATCH(name, 'dune') ORDER BY page_count DESC;

    SCORE()    |    author     |       name        |  page_count   |    release_date
---------------+---------------+-------------------+---------------+--------------------
2.2886353      |Frank Herbert  |Dune               |604            |1965-06-01T00:00:00Z
1.4005898      |Frank Herbert  |God Emperor of Dune|454            |1981-05-28T00:00:00Z
1.6086556      |Frank Herbert  |Children of Dune   |408            |1976-04-21T00:00:00Z
1.8893257      |Frank Herbert  |Dune Messiah       |331            |1969-10-15T00:00:00Z</pre>
</div>
<p>NOTE:
Trying to return <code class="literal">score</code> from a non full-text query will return the same value for all results, as
all are equally relevant.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="sql-syntax-limit"></a>LIMIT<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/sql/language/syntax/commands/select.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">LIMIT</code> clause restricts (limits) the number of rows returned using the format:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">LIMIT ( &lt;count&gt; | ALL )</pre>
</div>
<p>where</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
count
</span>
</dt>
<dd>
is a positive integer or zero indicating the maximum <span class="strong strong"><strong>possible</strong></span> number of results being returned (as there might be fewer matches
than the limit). If <code class="literal">0</code> is specified, no results are returned.
</dd>
<dt>
<span class="term">
ALL
</span>
</dt>
<dd>
indicates there is no limit and thus all results are being returned.
</dd>
</dl>
</div>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT first_name, last_name, emp_no FROM emp LIMIT 1;

  first_name   |   last_name   |    emp_no
---------------+---------------+---------------
Georgi         |Facello        |10001</pre>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p><a class="xref" href="sql-spec.html#sql-syntax-top" title="TOP"><code class="literal">TOP</code></a> and <a class="xref" href="sql-spec.html#sql-syntax-limit" title="LIMIT"><code class="literal">LIMIT</code></a> cannot be used together in the same query and an error is returned otherwise.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="sql-syntax-pivot"></a>PIVOT<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/sql/language/syntax/commands/select.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">PIVOT</code> clause performs a cross tabulation on the results of the query: it aggregates the results and rotates rows into columns. The rotation is done by turning unique values from one column in the expression - the pivoting column - into multiple columns in the output. The column values are aggregations on the remaining columns specified in the expression.</p>
<p>The clause can be broken down in three parts: the aggregation, the <code class="literal">FOR</code>- and the <code class="literal">IN</code>-subclause.</p>
<p>The <code class="literal">aggregation_expr</code> subclause specifies an expression containing an <a class="xref" href="sql-functions.html#sql-functions-aggs" title="Aggregate Functions">aggregation function</a> to be applied on one of the source columns. Only one aggregation can be provided, currently.</p>
<p>The <code class="literal">FOR</code>-subclause specifies the pivoting column: the distinct values of this column will become the candidate set of values to be rotated.</p>
<p>The <code class="literal">IN</code>-subclause defines a filter: the intersection between the set provided here and the candidate set from the <code class="literal">FOR</code>-subclause will be rotated to become the headers of the columns appended to the end result. The filter can not be a subquery, one must provide here literal values, obtained in advance.</p>
<p>The pivoting operation will perform an implicit <a class="xref" href="sql-spec.html#sql-syntax-group-by" title="GROUP BY">GROUP BY</a> on all source columns not specified in the <code class="literal">PIVOT</code> clause, along with the values filtered through the <code class="literal">IN</code>-clause. Consider the following statement:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT * FROM test_emp PIVOT (SUM(salary) FOR languages IN (1, 2)) LIMIT 5;

     birth_date      |    emp_no     |  first_name   |    gender     |      hire_date      |   last_name   |       1       |       2
---------------------+---------------+---------------+---------------+---------------------+---------------+---------------+---------------
null                 |10041          |Uri            |F              |1989-11-12 00:00:00.0|Lenart         |56415          |null
null                 |10043          |Yishay         |M              |1990-10-20 00:00:00.0|Tzvieli        |34341          |null
null                 |10044          |Mingsen        |F              |1994-05-21 00:00:00.0|Casley         |39728          |null
1952-04-19 00:00:00.0|10009          |Sumant         |F              |1985-02-18 00:00:00.0|Peac           |66174          |null
1953-01-07 00:00:00.0|10067          |Claudi         |M              |1987-03-04 00:00:00.0|Stavenow       |null           |52044</pre>
</div>
<p>The query execution could logically be broken down in the following steps:</p>
<div class="olist orderedlist">
<ol class="orderedlist">
<li class="listitem">
a <a class="xref" href="sql-spec.html#sql-syntax-group-by" title="GROUP BY">GROUP BY</a> on the column in the <code class="literal">FOR</code>-clause: <code class="literal">languages</code>;
</li>
<li class="listitem">
the resulting values are filtered through the set provided in the <code class="literal">IN</code>-clause;
</li>
<li class="listitem">
the now filtered column is pivoted to form the headers of the two additional columns appended to the result: <code class="literal">1</code> and <code class="literal">2</code>;
</li>
<li class="listitem">
a <a class="xref" href="sql-spec.html#sql-syntax-group-by" title="GROUP BY">GROUP BY</a> on all columns of the source table <code class="literal">test_emp</code>, except <code class="literal">salary</code> (part of the aggregation subclause) and <code class="literal">languages</code> (part of the <code class="literal">FOR</code>-clause);
</li>
<li class="listitem">
the values in these appended columns are the <code class="literal">SUM</code> aggregations of <code class="literal">salary</code>, grouped by the respective language.
</li>
</ol>
</div>
<p>The table-value expression to cross-tabulate can also be the result of a subquery:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT * FROM (SELECT languages, gender, salary FROM test_emp) PIVOT (AVG(salary) FOR gender IN ('F'));

   languages   |       'F'
---------------+------------------
null           |62140.666666666664
1              |47073.25
2              |50684.4
3              |53660.0
4              |49291.5
5              |46705.555555555555</pre>
</div>
<p>The pivoted columns can be aliased (and quoting is required to accommodate white spaces), with or without a supporting <code class="literal">AS</code> token:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT * FROM (SELECT languages, gender, salary FROM test_emp) PIVOT (AVG(salary) FOR gender IN ('M' AS "XY", 'F' "XX"));

   languages   |        XY       |        XX
---------------+-----------------+------------------
null           |48396.28571428572|62140.666666666664
1              |49767.22222222222|47073.25
2              |44103.90909090909|50684.4
3              |51741.90909090909|53660.0
4              |47058.90909090909|49291.5
5              |39052.875        |46705.555555555555</pre>
</div>
<p>The resulting cross tabulation can further have the <a class="xref" href="sql-spec.html#sql-syntax-order-by" title="ORDER BY">ORDER BY</a> and <a class="xref" href="sql-spec.html#sql-syntax-limit" title="LIMIT">LIMIT</a> clauses applied:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT * FROM (SELECT languages, gender, salary FROM test_emp) PIVOT (AVG(salary) FOR gender IN ('F')) ORDER BY languages DESC LIMIT 4;
   languages   |       'F'
---------------+------------------
5              |46705.555555555555
4              |49291.5
3              |53660.0
2              |50684.4</pre>
</div>
</div>

</div>

<div class="section xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="sql-syntax-show-columns"></a>SHOW COLUMNS<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/sql/language/syntax/commands/show-columns.asciidoc">edit</a><a class="xpack_tag" href="/subscriptions"></a></h2>
</div></div></div>
<p><strong>Synopsis:</strong></p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SHOW COLUMNS [ FROM | IN ]?
    [table identifier | <a id="CO344-1"></a><i class="conum" data-value="1"></i>
    [LIKE pattern] ]    <a id="CO344-2"></a><i class="conum" data-value="2"></i></pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO344-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>single table identifier or double quoted es multi index</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO344-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>SQL LIKE pattern</p>
</td>
</tr>
</table>
</div>
<p>See <a class="xref" href="sql-spec.html#sql-index-patterns" title="Index patterns">index patterns</a> for more information about
patterns.</p>
<p><span class="strong strong"><strong>Description</strong></span>: List the columns in table and their data type (and other attributes).</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SHOW COLUMNS IN emp;

       column       |     type      |    mapping
--------------------+---------------+---------------
birth_date          |TIMESTAMP      |datetime
dep                 |STRUCT         |nested
dep.dep_id          |VARCHAR        |keyword
dep.dep_name        |VARCHAR        |text
dep.dep_name.keyword|VARCHAR        |keyword
dep.from_date       |TIMESTAMP      |datetime
dep.to_date         |TIMESTAMP      |datetime
emp_no              |INTEGER        |integer
first_name          |VARCHAR        |text
first_name.keyword  |VARCHAR        |keyword
gender              |VARCHAR        |keyword
hire_date           |TIMESTAMP      |datetime
languages           |TINYINT        |byte
last_name           |VARCHAR        |text
last_name.keyword   |VARCHAR        |keyword
salary              |INTEGER        |integer</pre>
</div>
</div>

<div class="section xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="sql-syntax-show-functions"></a>SHOW FUNCTIONS<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/sql/language/syntax/commands/show-functions.asciidoc">edit</a><a class="xpack_tag" href="/subscriptions"></a></h2>
</div></div></div>
<p><strong>Synopsis:</strong></p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SHOW FUNCTIONS [LIKE pattern?]? <a id="CO345-1"></a><i class="conum" data-value="1"></i></pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO345-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>SQL match pattern</p>
</td>
</tr>
</table>
</div>
<p><span class="strong strong"><strong>Description</strong></span>: List all the SQL functions and their type. The <code class="literal">LIKE</code> clause can be used to restrict the list of names to the given pattern.</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SHOW FUNCTIONS;

      name       |     type
-----------------+---------------
AVG              |AGGREGATE
COUNT            |AGGREGATE
FIRST            |AGGREGATE
FIRST_VALUE      |AGGREGATE
LAST             |AGGREGATE
LAST_VALUE       |AGGREGATE
MAX              |AGGREGATE
MIN              |AGGREGATE
SUM              |AGGREGATE
KURTOSIS         |AGGREGATE
MAD              |AGGREGATE
PERCENTILE       |AGGREGATE
PERCENTILE_RANK  |AGGREGATE
SKEWNESS         |AGGREGATE
STDDEV_POP       |AGGREGATE
STDDEV_SAMP      |AGGREGATE
SUM_OF_SQUARES   |AGGREGATE
VAR_POP          |AGGREGATE
VAR_SAMP         |AGGREGATE
HISTOGRAM        |GROUPING
CASE             |CONDITIONAL
COALESCE         |CONDITIONAL
GREATEST         |CONDITIONAL
IFNULL           |CONDITIONAL
IIF              |CONDITIONAL
ISNULL           |CONDITIONAL
LEAST            |CONDITIONAL
NULLIF           |CONDITIONAL
NVL              |CONDITIONAL
CURDATE          |SCALAR
CURRENT_DATE     |SCALAR
CURRENT_TIME     |SCALAR
CURRENT_TIMESTAMP|SCALAR
CURTIME          |SCALAR
DATEADD          |SCALAR
DATEDIFF         |SCALAR
DATEPART         |SCALAR
DATETIME_FORMAT  |SCALAR
DATETIME_PARSE   |SCALAR
DATETRUNC        |SCALAR
DATE_ADD         |SCALAR
DATE_DIFF        |SCALAR
DATE_PARSE       |SCALAR
DATE_PART        |SCALAR
DATE_TRUNC       |SCALAR
DAY              |SCALAR
DAYNAME          |SCALAR
DAYOFMONTH       |SCALAR
DAYOFWEEK        |SCALAR
DAYOFYEAR        |SCALAR
DAY_NAME         |SCALAR
DAY_OF_MONTH     |SCALAR
DAY_OF_WEEK      |SCALAR
DAY_OF_YEAR      |SCALAR
DOM              |SCALAR
DOW              |SCALAR
DOY              |SCALAR
FORMAT           |SCALAR
HOUR             |SCALAR
HOUR_OF_DAY      |SCALAR
IDOW             |SCALAR
ISODAYOFWEEK     |SCALAR
ISODOW           |SCALAR
ISOWEEK          |SCALAR
ISOWEEKOFYEAR    |SCALAR
ISO_DAY_OF_WEEK  |SCALAR
ISO_WEEK_OF_YEAR |SCALAR
IW               |SCALAR
IWOY             |SCALAR
MINUTE           |SCALAR
MINUTE_OF_DAY    |SCALAR
MINUTE_OF_HOUR   |SCALAR
MONTH            |SCALAR
MONTHNAME        |SCALAR
MONTH_NAME       |SCALAR
MONTH_OF_YEAR    |SCALAR
NOW              |SCALAR
QUARTER          |SCALAR
SECOND           |SCALAR
SECOND_OF_MINUTE |SCALAR
TIMESTAMPADD     |SCALAR
TIMESTAMPDIFF    |SCALAR
TIMESTAMP_ADD    |SCALAR
TIMESTAMP_DIFF   |SCALAR
TIME_PARSE       |SCALAR
TODAY            |SCALAR
WEEK             |SCALAR
WEEK_OF_YEAR     |SCALAR
YEAR             |SCALAR
ABS              |SCALAR
ACOS             |SCALAR
ASIN             |SCALAR
ATAN             |SCALAR
ATAN2            |SCALAR
CBRT             |SCALAR
CEIL             |SCALAR
CEILING          |SCALAR
COS              |SCALAR
COSH             |SCALAR
COT              |SCALAR
DEGREES          |SCALAR
E                |SCALAR
EXP              |SCALAR
EXPM1            |SCALAR
FLOOR            |SCALAR
LOG              |SCALAR
LOG10            |SCALAR
MOD              |SCALAR
PI               |SCALAR
POWER            |SCALAR
RADIANS          |SCALAR
RAND             |SCALAR
RANDOM           |SCALAR
ROUND            |SCALAR
SIGN             |SCALAR
SIGNUM           |SCALAR
SIN              |SCALAR
SINH             |SCALAR
SQRT             |SCALAR
TAN              |SCALAR
TRUNC            |SCALAR
TRUNCATE         |SCALAR
ASCII            |SCALAR
BIT_LENGTH       |SCALAR
CHAR             |SCALAR
CHARACTER_LENGTH |SCALAR
CHAR_LENGTH      |SCALAR
CONCAT           |SCALAR
INSERT           |SCALAR
LCASE            |SCALAR
LEFT             |SCALAR
LENGTH           |SCALAR
LOCATE           |SCALAR
LTRIM            |SCALAR
OCTET_LENGTH     |SCALAR
POSITION         |SCALAR
REPEAT           |SCALAR
REPLACE          |SCALAR
RIGHT            |SCALAR
RTRIM            |SCALAR
SPACE            |SCALAR
STARTS_WITH      |SCALAR
SUBSTRING        |SCALAR
TRIM             |SCALAR
UCASE            |SCALAR
CAST             |SCALAR
CONVERT          |SCALAR
DATABASE         |SCALAR
USER             |SCALAR
ST_ASTEXT        |SCALAR
ST_ASWKT         |SCALAR
ST_DISTANCE      |SCALAR
ST_GEOMETRYTYPE  |SCALAR
ST_GEOMFROMTEXT  |SCALAR
ST_WKTTOSQL      |SCALAR
ST_X             |SCALAR
ST_Y             |SCALAR
ST_Z             |SCALAR
SCORE            |SCORE</pre>
</div>
<p>The list of functions returned can be customized based on the pattern.</p>
<p>It can be an exact match:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SHOW FUNCTIONS LIKE 'ABS';

     name      |     type
---------------+---------------
ABS            |SCALAR</pre>
</div>
<p>A wildcard for exactly one character:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SHOW FUNCTIONS LIKE 'A__';

     name      |     type
---------------+---------------
AVG            |AGGREGATE
ABS            |SCALAR</pre>
</div>
<p>A wildcard matching zero or more characters:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SHOW FUNCTIONS LIKE 'A%';

     name      |     type
---------------+---------------
AVG            |AGGREGATE
ABS            |SCALAR
ACOS           |SCALAR
ASIN           |SCALAR
ATAN           |SCALAR
ATAN2          |SCALAR
ASCII          |SCALAR</pre>
</div>
<p>Or of course, a variation of the above:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SHOW FUNCTIONS LIKE '%DAY%';

     name      |     type
---------------+---------------
DAY            |SCALAR
DAYNAME        |SCALAR
DAYOFMONTH     |SCALAR
DAYOFWEEK      |SCALAR
DAYOFYEAR      |SCALAR
DAY_NAME       |SCALAR
DAY_OF_MONTH   |SCALAR
DAY_OF_WEEK    |SCALAR
DAY_OF_YEAR    |SCALAR
HOUR_OF_DAY    |SCALAR
ISODAYOFWEEK   |SCALAR
ISO_DAY_OF_WEEK|SCALAR
MINUTE_OF_DAY  |SCALAR
TODAY          |SCALAR</pre>
</div>
</div>

<div class="section xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="sql-syntax-show-tables"></a>SHOW TABLES<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/sql/language/syntax/commands/show-tables.asciidoc">edit</a><a class="xpack_tag" href="/subscriptions"></a></h2>
</div></div></div>
<p><strong>Synopsis:</strong></p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SHOW TABLES
    [INCLUDE FROZEN]?   <a id="CO346-1"></a><i class="conum" data-value="1"></i>
    [table identifier | <a id="CO346-2"></a><i class="conum" data-value="2"></i>
    [LIKE pattern ]]?   <a id="CO346-3"></a><i class="conum" data-value="3"></i></pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO346-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Whether or not to include frozen indices</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO346-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>single table identifier or double quoted es multi index</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO346-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>SQL LIKE pattern</p>
</td>
</tr>
</table>
</div>
<p>See <a class="xref" href="sql-spec.html#sql-index-patterns" title="Index patterns">index patterns</a> for more information about
patterns.</p>
<p><span class="strong strong"><strong>Description</strong></span>: List the tables available to the current user and their type.</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SHOW TABLES;

     name      | type     |     kind
---------------+----------+---------------
emp            |TABLE     |INDEX
employees      |VIEW      |ALIAS
library        |TABLE     |INDEX</pre>
</div>
<p>Match multiple indices by using Elasticsearch <a class="xref" href="api-conventions.html#multi-index" title="Multi-target syntax">multi-target syntax</a>
notation:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SHOW TABLES "*,-l*";

     name      | type     |     kind
---------------+----------+---------------
emp            |TABLE     |INDEX
employees      |VIEW      |ALIAS</pre>
</div>
<p>One can also use the <code class="literal">LIKE</code> clause to restrict the list of names to the given pattern.</p>
<p>The pattern can be an exact match:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SHOW TABLES LIKE 'emp';

     name      | type     |     kind
---------------+----------+---------------
emp            |TABLE     |INDEX</pre>
</div>
<p>Multiple chars:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SHOW TABLES LIKE 'emp%';

     name      | type     |     kind
---------------+----------+---------------
emp            |TABLE     |INDEX
employees      |VIEW      |ALIAS</pre>
</div>
<p>A single char:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SHOW TABLES LIKE 'em_';

     name      | type     |     kind
---------------+----------+---------------
emp            |TABLE     |INDEX</pre>
</div>
<p>Or a mixture of single and multiple chars:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SHOW TABLES LIKE '%em_';

     name      | type     |     kind
---------------+----------+---------------
emp            |TABLE     |INDEX</pre>
</div>
</div>

<div class="section xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="sql-data-types"></a>Data Types<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/sql/language/data-types.asciidoc">edit</a><a class="xpack_tag" href="/subscriptions"></a></h2>
</div></div></div>
<div class="informaltable">
<table border="1" cellpadding="4px">
<colgroup>
<col class="col_1"/>
<col class="col_2"/>
<col class="col_3"/>
<col class="col_4"/>
</colgroup>
<tbody>
<tr>
<td align="center" valign="top"><p><span class="strong strong"><strong>Elasticsearch type</strong></span></p></td>
<td align="center" valign="top"><p><span class="strong strong"><strong>Elasticsearch SQL type</strong></span></p></td>
<td align="center" valign="top"><p><span class="strong strong"><strong>SQL type</strong></span></p></td>
<td align="center" valign="top"><p><span class="strong strong"><strong>SQL precision</strong></span></p></td>
</tr>
<tr>
<td align="center" colspan="4" valign="top"><p><span class="strong strong"><strong>Core types</strong></span></p></td>
</tr>
<tr>
<td align="center" valign="top"><p><a class="xref" href="mapping-params.html#null-value" title="null_value"><code class="literal">null</code></a></p></td>
<td align="center" valign="top"><p><code class="literal">null</code></p></td>
<td align="center" valign="top"><p>NULL</p></td>
<td align="center" valign="top"><p>0</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><a class="xref" href="mapping-types.html#boolean" title="Boolean field type"><code class="literal">boolean</code></a></p></td>
<td align="center" valign="top"><p><code class="literal">boolean</code></p></td>
<td align="center" valign="top"><p>BOOLEAN</p></td>
<td align="center" valign="top"><p>1</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><a class="xref" href="mapping-types.html#number" title="Numeric field types"><code class="literal">byte</code></a></p></td>
<td align="center" valign="top"><p><code class="literal">byte</code></p></td>
<td align="center" valign="top"><p>TINYINT</p></td>
<td align="center" valign="top"><p>3</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><a class="xref" href="mapping-types.html#number" title="Numeric field types"><code class="literal">short</code></a></p></td>
<td align="center" valign="top"><p><code class="literal">short</code></p></td>
<td align="center" valign="top"><p>SMALLINT</p></td>
<td align="center" valign="top"><p>5</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><a class="xref" href="mapping-types.html#number" title="Numeric field types"><code class="literal">integer</code></a></p></td>
<td align="center" valign="top"><p><code class="literal">integer</code></p></td>
<td align="center" valign="top"><p>INTEGER</p></td>
<td align="center" valign="top"><p>10</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><a class="xref" href="mapping-types.html#number" title="Numeric field types"><code class="literal">long</code></a></p></td>
<td align="center" valign="top"><p><code class="literal">long</code></p></td>
<td align="center" valign="top"><p>BIGINT</p></td>
<td align="center" valign="top"><p>19</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><a class="xref" href="mapping-types.html#number" title="Numeric field types"><code class="literal">double</code></a></p></td>
<td align="center" valign="top"><p><code class="literal">double</code></p></td>
<td align="center" valign="top"><p>DOUBLE</p></td>
<td align="center" valign="top"><p>15</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><a class="xref" href="mapping-types.html#number" title="Numeric field types"><code class="literal">float</code></a></p></td>
<td align="center" valign="top"><p><code class="literal">float</code></p></td>
<td align="center" valign="top"><p>REAL</p></td>
<td align="center" valign="top"><p>7</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><a class="xref" href="mapping-types.html#number" title="Numeric field types"><code class="literal">half_float</code></a></p></td>
<td align="center" valign="top"><p><code class="literal">half_float</code></p></td>
<td align="center" valign="top"><p>FLOAT</p></td>
<td align="center" valign="top"><p>3</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><a class="xref" href="mapping-types.html#number" title="Numeric field types"><code class="literal">scaled_float</code></a></p></td>
<td align="center" valign="top"><p><code class="literal">scaled_float</code></p></td>
<td align="center" valign="top"><p>DOUBLE</p></td>
<td align="center" valign="top"><p>15</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><a class="xref" href="mapping-types.html#keyword" title="Keyword type family"><code class="literal">keyword</code></a></p></td>
<td align="center" valign="top"><p><code class="literal">keyword</code></p></td>
<td align="center" valign="top"><p>VARCHAR</p></td>
<td align="center" valign="top"><p>32,766</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><a class="xref" href="mapping-types.html#constant-keyword-field-type" title="Constant keyword field type"><code class="literal">constant_keyword</code></a></p></td>
<td align="center" valign="top"><p><code class="literal">constant_keyword</code></p></td>
<td align="center" valign="top"><p>VARCHAR</p></td>
<td align="center" valign="top"><p>32,766</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><a class="xref" href="mapping-types.html#text" title="Text field type"><code class="literal">text</code></a></p></td>
<td align="center" valign="top"><p><code class="literal">text</code></p></td>
<td align="center" valign="top"><p>VARCHAR</p></td>
<td align="center" valign="top"><p>2,147,483,647</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><a class="xref" href="mapping-types.html#binary" title="Binary field type"><code class="literal">binary</code></a></p></td>
<td align="center" valign="top"><p><code class="literal">binary</code></p></td>
<td align="center" valign="top"><p>VARBINARY</p></td>
<td align="center" valign="top"><p>2,147,483,647</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><a class="xref" href="mapping-types.html#date" title="Date field type"><code class="literal">date</code></a></p></td>
<td align="center" valign="top"><p><code class="literal">datetime</code></p></td>
<td align="center" valign="top"><p>TIMESTAMP</p></td>
<td align="center" valign="top"><p>29</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><a class="xref" href="mapping-types.html#ip" title="IP field type"><code class="literal">ip</code></a></p></td>
<td align="center" valign="top"><p><code class="literal">ip</code></p></td>
<td align="center" valign="top"><p>VARCHAR</p></td>
<td align="center" valign="top"><p>39</p></td>
</tr>
<tr>
<td align="center" colspan="4" valign="top"><p><span class="strong strong"><strong>Complex types</strong></span></p></td>
</tr>
<tr>
<td align="center" valign="top"><p><a class="xref" href="mapping-types.html#object" title="Object field type"><code class="literal">object</code></a></p></td>
<td align="center" valign="top"><p><code class="literal">object</code></p></td>
<td align="center" valign="top"><p>STRUCT</p></td>
<td align="center" valign="top"><p>0</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><a class="xref" href="mapping-types.html#nested" title="Nested field type"><code class="literal">nested</code></a></p></td>
<td align="center" valign="top"><p><code class="literal">nested</code></p></td>
<td align="center" valign="top"><p>STRUCT</p></td>
<td align="center" valign="top"><p>0</p></td>
</tr>
<tr>
<td align="center" colspan="4" valign="top"><p><span class="strong strong"><strong>Unsupported types</strong></span></p></td>
</tr>
<tr>
<td align="center" valign="top"><p><em>types not mentioned above</em></p></td>
<td align="center" valign="top"><p><code class="literal">unsupported</code></p></td>
<td align="center" valign="top"><p>OTHER</p></td>
<td align="center" valign="top"><p>0</p></td>
</tr>
</tbody>
</table>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>Most of Elasticsearch <a class="xref" href="mapping-types.html" title="Field data types">data types</a> are available in Elasticsearch SQL, as indicated above.
As one can see, all of Elasticsearch <a class="xref" href="mapping-types.html" title="Field data types">data types</a> are mapped to the data type with the same
name in Elasticsearch SQL, with the exception of <span class="strong strong"><strong>date</strong></span> data type which is mapped to <span class="strong strong"><strong>datetime</strong></span> in Elasticsearch SQL.
This is to avoid confusion with the ANSI SQL types <span class="strong strong"><strong>DATE</strong></span> (date only) and <span class="strong strong"><strong>TIME</strong></span> (time only), which are also
supported by Elasticsearch SQL in queries (with the use of
<a class="xref" href="sql-functions.html#sql-functions-type-conversion-cast" title="CAST"><code class="literal">CAST</code></a>/<a class="xref" href="sql-functions.html#sql-functions-type-conversion-convert" title="CONVERT"><code class="literal">CONVERT</code></a>), but don&#8217;t correspond to an
actual mapping in Elasticsearch (see the <a class="xref" href="sql-spec.html#es-sql-only-types"><code class="literal">table</code></a> below).</p>
</div>
</div>
<p>Obviously, not all types in Elasticsearch have an equivalent in SQL and vice-versa hence why, Elasticsearch SQL
uses the data type <em>particularities</em> of the former over the latter as ultimately Elasticsearch is the backing store.</p>
<p>In addition to the types above, Elasticsearch SQL also supports at <em>runtime</em> SQL-specific types that do not have an equivalent in Elasticsearch.
Such types cannot be loaded from Elasticsearch (as it does not know about them) however can be used inside Elasticsearch SQL in queries or their results.</p>
<p><a id="es-sql-only-types"></a>The table below indicates these types:</p>
<div class="informaltable">
<table border="1" cellpadding="4px">
<colgroup>
<col class="col_1"/>
<col class="col_2"/>
</colgroup>
<tbody>
<tr>
<td align="center" valign="top"><p><span class="strong strong"><strong>SQL type</strong></span></p></td>
<td align="center" valign="top"><p><span class="strong strong"><strong>SQL precision</strong></span></p></td>
</tr>
<tr>
<td align="center" valign="top"><p><code class="literal">date</code></p></td>
<td align="center" valign="top"><p>29</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><code class="literal">time</code></p></td>
<td align="center" valign="top"><p>18</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><code class="literal">interval_year</code></p></td>
<td align="center" valign="top"><p>7</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><code class="literal">interval_month</code></p></td>
<td align="center" valign="top"><p>7</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><code class="literal">interval_day</code></p></td>
<td align="center" valign="top"><p>23</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><code class="literal">interval_hour</code></p></td>
<td align="center" valign="top"><p>23</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><code class="literal">interval_minute</code></p></td>
<td align="center" valign="top"><p>23</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><code class="literal">interval_second</code></p></td>
<td align="center" valign="top"><p>23</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><code class="literal">interval_year_to_month</code></p></td>
<td align="center" valign="top"><p>7</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><code class="literal">interval_day_to_hour</code></p></td>
<td align="center" valign="top"><p>23</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><code class="literal">interval_day_to_minute</code></p></td>
<td align="center" valign="top"><p>23</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><code class="literal">interval_day_to_second</code></p></td>
<td align="center" valign="top"><p>23</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><code class="literal">interval_hour_to_minute</code></p></td>
<td align="center" valign="top"><p>23</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><code class="literal">interval_hour_to_second</code></p></td>
<td align="center" valign="top"><p>23</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><code class="literal">interval_minute_to_second</code></p></td>
<td align="center" valign="top"><p>23</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><code class="literal">geo_point</code></p></td>
<td align="center" valign="top"><p>52</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><code class="literal">geo_shape</code></p></td>
<td align="center" valign="top"><p>2,147,483,647</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><code class="literal">shape</code></p></td>
<td align="center" valign="top"><p>2,147,483,647</p></td>
</tr>
</tbody>
</table>
</div>
<h4><a id="sql-multi-field"></a>SQL and multi-fields<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/sql/language/data-types.asciidoc">edit</a></h4>
<p>A core concept in Elasticsearch is that of an <code class="literal">analyzed</code> field, that is a full-text value that is interpreted in order
to be effectively indexed. These fields are of type <a class="xref" href="mapping-types.html#text" title="Text field type"><code class="literal">text</code></a> and are not used for sorting or aggregations as their actual value depends on the <a class="xref" href="mapping-params.html#analyzer" title="analyzer"><code class="literal">analyzer</code></a> used hence why Elasticsearch also offers the <a class="xref" href="mapping-types.html#keyword" title="Keyword type family"><code class="literal">keyword</code></a> type for storing the <em>exact</em>
value.</p>
<p>In most case, and the default actually, is to use both types for strings which Elasticsearch supports through <a class="xref" href="mapping-params.html#multi-fields" title="fields">multi fields</a>, that is the ability to index the same string in multiple ways; for example index it both as <code class="literal">text</code> for search but also as <code class="literal">keyword</code> for sorting and aggregations.</p>
<p>As SQL requires exact values, when encountering a <code class="literal">text</code> field Elasticsearch SQL will search for an exact multi-field that it can use for comparisons, sorting and aggregations.
To do that, it will search for the first <code class="literal">keyword</code> that it can find that is <em>not</em> normalized and use that as the original field <em>exact</em> value.</p>
<p>Consider the following <code class="literal">string</code> mapping:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "first_name": {
    "type": "text",
    "fields": {
      "raw": {
        "type": "keyword"
      }
    }
  }
}</pre>
</div>
<p>The following SQL query:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT first_name FROM index WHERE first_name = 'John'</pre>
</div>
<p>is identical to:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT first_name FROM index WHERE first_name.raw = 'John'</pre>
</div>
<p>as Elasticsearch SQL automatically <em>picks</em> up the <code class="literal">raw</code> multi-field from <code class="literal">raw</code> for exact matching.</p>
</div>

<div class="section xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="sql-index-patterns"></a>Index patterns<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/sql/language/indices.asciidoc">edit</a><a class="xpack_tag" href="/subscriptions"></a></h2>
</div></div></div>
<p>Elasticsearch SQL supports two types of patterns for matching multiple indices or tables:</p>
<h4><a id="sql-index-patterns-multi"></a>Elasticsearch multi-index<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/sql/language/indices.asciidoc">edit</a></h4>
<p>The Elasticsearch notation for enumerating, including or excluding <a class="xref" href="api-conventions.html#multi-index" title="Multi-target syntax">multi-target syntax</a>
is supported <em>as long</em> as it is quoted or escaped as a table identifier.</p>
<p>For example:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SHOW TABLES "*,-l*";

     name      | type     |     kind
---------------+----------+---------------
emp            |TABLE     |INDEX
employees      |VIEW      |ALIAS</pre>
</div>
<p>Notice the pattern is surrounded by double quotes <code class="literal">"</code>. It enumerated <code class="literal">*</code> meaning all indices however
it excludes (due to <code class="literal">-</code>) all indices that start with <code class="literal">l</code>.
This notation is very convenient and powerful as it allows both inclusion and exclusion, depending on
the target naming convention.</p>
<p>The same kind of patterns can also be used to query multiple indices or tables.</p>
<p>For example:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT emp_no FROM "e*p" LIMIT 1;

    emp_no
---------------
10001</pre>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>There is the restriction that all resolved concrete tables have the exact same mapping.</p>
</div>
</div>
<h4><a id="sql-index-patterns-like"></a>SQL <code class="literal">LIKE</code> notation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/sql/language/indices.asciidoc">edit</a></h4>
<p>The common <code class="literal">LIKE</code> statement (including escaping if needed) to match a wildcard pattern, based on one <code class="literal">_</code>
or multiple <code class="literal">%</code> characters.</p>
<p>Using <code class="literal">SHOW TABLES</code> command again:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SHOW TABLES LIKE 'emp%';

     name      | type     |     kind
---------------+----------+---------------
emp            |TABLE     |INDEX
employees      |VIEW      |ALIAS</pre>
</div>
<p>The pattern matches all tables that start with <code class="literal">emp</code>.</p>
<p>This command supports <em>escaping</em> as well, for example:</p>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SHOW TABLES LIKE 'emp!%' ESCAPE '!';

     name      |     type      |     kind
---------------+---------------+---------------</pre>
</div>
<p>Notice how now <code class="literal">emp%</code> does not match any tables because <code class="literal">%</code>, which means match zero or more characters,
has been escaped by <code class="literal">!</code> and thus becomes an regular char. And since there is no table named <code class="literal">emp%</code>,
an empty table is returned.</p>
<p>In a nutshell, the differences between the two type of patterns are:</p>
<div class="informaltable">
<table border="1" cellpadding="4px">
<colgroup>
<col class="col_1"/>
<col class="col_2"/>
<col class="col_3"/>
</colgroup>
<tbody>
<tr>
<td align="center" valign="top"><p><span class="strong strong"><strong>Feature</strong></span></p></td>
<td align="center" valign="top"><p><span class="strong strong"><strong>Multi index</strong></span></p></td>
<td align="center" valign="top"><p><span class="strong strong"><strong>SQL <code class="literal">LIKE</code></strong></span></p></td>
</tr>
<tr>
<td align="center" valign="top"><p><span class="strong strong"><strong>Type of quoting</strong></span></p></td>
<td align="center" valign="top"><p><code class="literal">"</code></p></td>
<td align="center" valign="top"><p><code class="literal">'</code></p></td>
</tr>
<tr>
<td align="center" valign="top"><p><span class="strong strong"><strong>Inclusion</strong></span></p></td>
<td align="center" valign="top"><p>Yes</p></td>
<td align="center" valign="top"><p>Yes</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><span class="strong strong"><strong>Exclusion</strong></span></p></td>
<td align="center" valign="top"><p>Yes</p></td>
<td align="center" valign="top"><p>No</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><span class="strong strong"><strong>Enumeration</strong></span></p></td>
<td align="center" valign="top"><p>Yes</p></td>
<td align="center" valign="top"><p>No</p></td>
</tr>
<tr>
<td align="center" valign="top"><p><span class="strong strong"><strong>One char pattern</strong></span></p></td>
<td align="center" valign="top"><p>No</p></td>
<td align="center" valign="top"><p><code class="literal">_</code></p></td>
</tr>
<tr>
<td align="center" valign="top"><p><span class="strong strong"><strong>Multi char pattern</strong></span></p></td>
<td align="center" valign="top"><p><code class="literal">*</code></p></td>
<td align="center" valign="top"><p><code class="literal">%</code></p></td>
</tr>
<tr>
<td align="center" valign="top"><p><span class="strong strong"><strong>Escaping</strong></span></p></td>
<td align="center" valign="top"><p>No</p></td>
<td align="center" valign="top"><p><code class="literal">ESCAPE</code></p></td>
</tr>
</tbody>
</table>
</div>
<p>Which one to use, is up to you however try to stick to the same one across your queries for consistency.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>As the query type of quoting between the two patterns is fairly similar (<code class="literal">"</code> vs <code class="literal">'</code>), Elasticsearch SQL <em>always</em>
requires the keyword <code class="literal">LIKE</code> for SQL <code class="literal">LIKE</code> pattern.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="sql-index-frozen"></a>Frozen Indices<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/sql/language/indices.asciidoc">edit</a></h2>
</div></div></div>
<p>Elasticsearch <a class="xref" href="frozen-indices.html" title="Frozen indices">frozen indices</a> are a useful and powerful tool for hot/warm architecture introduced in Elasticsearch 6.6,
essentially by trading speed for memory.
Elasticsearch SQL supports frozen indices and similar to Elasticsearch, due to their performance characteristics, allows searches on them only
when explicitly told so by user - in other words, by default, frozen indices are not included in searches.</p>
<p>One can toggle the use of frozen indices through:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
dedicated configuration parameter
</span>
</dt>
<dd>
Set to <code class="literal">true</code> properties <code class="literal">index_include_frozen</code> in the <a class="xref" href="sql-rest.html" title="SQL REST API"><em>SQL REST API</em></a> or <code class="literal">index.include.frozen</code> in the drivers to include frozen indices.
</dd>
<dt>
<span class="term">
dedicated keyword
</span>
</dt>
<dd>
Explicitly perform the inclusion through the dedicated <code class="literal">FROZEN</code> keyword in the <code class="literal">FROM</code> clause or <code class="literal">INCLUDE FROZEN</code> in the <code class="literal">SHOW</code> commands:
</dd>
</dl>
</div>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SHOW TABLES INCLUDE FROZEN;

     name      | type     |     kind
---------------+----------+---------------
archive        |TABLE     |FROZEN INDEX
emp            |TABLE     |INDEX
employees      |VIEW      |ALIAS
library        |TABLE     |INDEX</pre>
</div>
<div class="pre_wrapper lang-sql">
<pre class="programlisting prettyprint lang-sql">SELECT * FROM FROZEN archive LIMIT 1;

     author      |        name        |  page_count   |    release_date
-----------------+--------------------+---------------+--------------------
James S.A. Corey |Leviathan Wakes     |561            |2011-06-02T00:00:00Z</pre>
</div>
<p>Unless enabled, frozen indices are completely ignored; it is as if they do not exist and as such, queries ran against them are likely to fail.</p>
</div>

</div>
<div class="navfooter">
<span class="prev">
<a href="sql-client-apps.html">« SQL Client Applications</a>
</span>
<span class="next">
<a href="sql-functions.html">Functions and Operators »</a>
</span>
</div>
</div>
</body>
</html>
