<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>What is Elasticsearch? | Elasticsearch Guide | Elastic</title>
<meta class="elastic" name="content" content="What is Elasticsearch? | Elasticsearch Guide">

<link rel="home" href="index.html" title="Elasticsearch Guide"/>
<link rel="up" href="index.html" title="Elasticsearch Guide"/>
<link rel="prev" href="index.html" title="Elasticsearch Guide"/>
<link rel="next" href="release-highlights.html" title="What&#8217;s new in 7.10"/>
<meta class="elastic" name="product_version" content=""/>
<meta class="elastic" name="product_name" content=""/>
<meta class="elastic" name="website_area" content="documentation"/>
<meta name="DC.type" content="Learn/Docs/"/>
<meta name="DC.subject" content=""/>
<meta name="DC.identifier" content=""/>
</head>
<body>
<div id="content">
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="/guide/">Elastic Docs</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="index.html">Elasticsearch Guide</a></span>
</div>
<div class="navheader">
<span class="prev">
</span>
<span class="next">
<a href="release-highlights.html">What&#8217;s new in 7.10 »</a>
</span>
</div>
<div class="chapter">
<div class="titlepage"><div><div>
<h1 class="title"><a id="elasticsearch-intro"></a>What is Elasticsearch?<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/intro.asciidoc">edit</a></h1>
</div></div></div>
<p><em><span class="strong strong"><strong>You know, for search (and analysis)</strong></span></em></p>
<p>Elasticsearch is the distributed search and analytics engine at the heart of
the Elastic Stack. Logstash and Beats facilitate collecting, aggregating, and
enriching your data and storing it in Elasticsearch. Kibana enables you to
interactively explore, visualize, and share insights into your data and manage
and monitor the stack. Elasticsearch is where the indexing, search, and analysis
magic happens.</p>
<p>Elasticsearch provides near real-time search and analytics for all types of data. Whether you
have structured or unstructured text, numerical data, or geospatial data,
Elasticsearch can efficiently store and index it in a way that supports fast searches.
You can go far beyond simple data retrieval and aggregate information to discover
trends and patterns in your data. And as your data and query volume grows, the
distributed nature of Elasticsearch enables your deployment to grow seamlessly right
along with it.</p>
<p>While not <em>every</em> problem is a search problem, Elasticsearch offers speed and flexibility
to handle data in a wide variety of use cases:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Add a search box to an app or website
</li>
<li class="listitem">
Store and analyze logs, metrics, and security event data
</li>
<li class="listitem">
Use machine learning to automatically model the behavior of your data in real
time
</li>
<li class="listitem">
Automate business workflows using Elasticsearch as a storage engine
</li>
<li class="listitem">
Manage, integrate, and analyze spatial information using Elasticsearch as a geographic
information system (GIS)
</li>
<li class="listitem">
Store and process genetic data using Elasticsearch as a bioinformatics research tool
</li>
</ul>
</div>
<p>We’re continually amazed by the novel ways people use search. But whether
your use case is similar to one of these, or you&#8217;re using Elasticsearch to tackle a new
problem, the way you work with your data, documents, and indices in Elasticsearch is
the same.</p>
<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="documents-indices"></a>Data in: documents and indices<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/intro.asciidoc">edit</a></h2>
</div></div></div>
<p>Elasticsearch is a distributed document store. Instead of storing information as rows of
columnar data, Elasticsearch stores complex data structures that have been serialized
as JSON documents. When you have multiple Elasticsearch nodes in a cluster, stored
documents are distributed across the cluster and can be accessed immediately
from any node.</p>
<p>When a document is stored, it is indexed and fully searchable in <a class="xref" href="near-real-time.html" title="Near real-time search">near real-time</a>--within 1 second. Elasticsearch uses a data structure called an
inverted index that supports very fast full-text searches. An inverted index
lists every unique word that appears in any document and identifies all of the
documents each word occurs in.</p>
<p>An index can be thought of as an optimized collection of documents and each
document is a collection of fields, which are the key-value pairs that contain
your data. By default, Elasticsearch indexes all data in every field and each indexed
field has a dedicated, optimized data structure. For example, text fields are
stored in inverted indices, and numeric and geo fields are stored in BKD trees.
The ability to use the per-field data structures to assemble and return search
results is what makes Elasticsearch so fast.</p>
<p>Elasticsearch also has the ability to be schema-less, which means that documents can be
indexed without explicitly specifying how to handle each of the different fields
that might occur in a document. When dynamic mapping is enabled, Elasticsearch
automatically detects and adds new fields to the index. This default
behavior makes it easy to index and explore your data&#8212;&#8203;just start
indexing documents and Elasticsearch will detect and map booleans, floating point and
integer values, dates, and strings to the appropriate Elasticsearch data types.</p>
<p>Ultimately, however, you know more about your data and how you want to use it
than Elasticsearch can. You can define rules to control dynamic mapping and explicitly
define mappings to take full control of how fields are stored and indexed.</p>
<p>Defining your own mappings enables you to:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Distinguish between full-text string fields and exact value string fields
</li>
<li class="listitem">
Perform language-specific text analysis
</li>
<li class="listitem">
Optimize fields for partial matching
</li>
<li class="listitem">
Use custom date formats
</li>
<li class="listitem">
Use data types such as <code class="literal">geo_point</code> and <code class="literal">geo_shape</code> that cannot be automatically
detected
</li>
</ul>
</div>
<p>It’s often useful to index the same field in different ways for different
purposes. For example, you might want to index a string field as both a text
field for full-text search and as a keyword field for sorting or aggregating
your data. Or, you might choose to use more than one language analyzer to
process the contents of a string field that contains user input.</p>
<p>The analysis chain that is applied to a full-text field during indexing is also
used at search time. When you query a full-text field, the query text undergoes
the same analysis before the terms are looked up in the index.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-analyze"></a>Information out: search and analyze<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/intro.asciidoc">edit</a></h2>
</div></div></div>
<p>While you can use Elasticsearch as a document store and retrieve documents and their
metadata, the real power comes from being able to easily access the full suite
of search capabilities built on the Apache Lucene search engine library.</p>
<p>Elasticsearch provides a simple, coherent REST API for managing your cluster and indexing
and searching your data.  For testing purposes, you can easily submit requests
directly from the command line or through the Developer Console in Kibana. From
your applications, you can use the
<a href="https://www.elastic.co/guide/en/elasticsearch/client/index.html" class="ulink" target="_top">Elasticsearch client</a>
for your language of choice: Java, JavaScript, Go, .NET, PHP, Perl, Python
or Ruby.</p>
<h4><a id="search-data"></a>Searching your data<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/intro.asciidoc">edit</a></h4>
<p>The Elasticsearch REST APIs support structured queries, full text queries, and complex
queries that combine the two. Structured queries are
similar to the types of queries you can construct in SQL. For example, you
could search the <code class="literal">gender</code> and <code class="literal">age</code> fields in your <code class="literal">employee</code> index and sort the
matches by the <code class="literal">hire_date</code> field. Full-text queries find all documents that
match the query string and return them sorted by <em>relevance</em>&mdash;how good a
match they are for your search terms.</p>
<p>In addition to searching for individual terms, you can perform phrase searches,
similarity searches, and prefix searches, and get autocomplete suggestions.</p>
<p>Have geospatial or other numerical data that you want to search? Elasticsearch indexes
non-textual data in optimized data structures that support
high-performance geo and numerical queries.</p>
<p>You can access all of these search capabilities using Elasticsearch&#8217;s
comprehensive JSON-style query language (<a class="xref" href="query-dsl.html" title="Query DSL">Query DSL</a>). You can also
construct <a class="xref" href="sql-overview.html" title="Overview">SQL-style queries</a> to search and aggregate data
natively inside Elasticsearch, and JDBC and ODBC drivers enable a broad range of
third-party applications to interact with Elasticsearch via SQL.</p>
<h4><a id="analyze-data"></a>Analyzing your data<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/intro.asciidoc">edit</a></h4>
<p>Elasticsearch aggregations enable you to build complex summaries of your data and gain
insight into key metrics, patterns, and trends. Instead of just finding the
proverbial “needle in a haystack”, aggregations enable you to answer questions
like:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
How many needles are in the haystack?
</li>
<li class="listitem">
What is the average length of the needles?
</li>
<li class="listitem">
What is the median length of the needles, broken down by manufacturer?
</li>
<li class="listitem">
How many needles were added to the haystack in each of the last six months?
</li>
</ul>
</div>
<p>You can also use aggregations to answer more subtle questions, such as:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
What are your most popular needle manufacturers?
</li>
<li class="listitem">
Are there any unusual or anomalous clumps of needles?
</li>
</ul>
</div>
<p>Because aggregations leverage the same data-structures used for search, they are
also very fast. This enables you to analyze and visualize your data in real time.
Your reports and dashboards update as your data changes so you can take action
based on the latest information.</p>
<p>What’s more, aggregations operate alongside search requests. You can search
documents, filter results, and perform analytics at the same time, on the same
data, in a single request. And because aggregations are calculated in the
context of a particular search, you’re not just displaying a count of all
size 70 needles, you’re displaying a count of the size 70 needles
that match your users' search criteria&#8212;&#8203;for example, all size 70 <em>non-stick
embroidery</em> needles.</p>
<h5><a id="more-features"></a>But wait, there’s more<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/intro.asciidoc">edit</a></h5>
<p>Want to automate the analysis of your time series data? You can use
<a href="https://www.elastic.co/guide/en/machine-learning/7.10/ml-overview.html" class="ulink" target="_top">machine learning</a> features to create accurate
baselines of normal behavior in your data and identify anomalous patterns. With
machine learning, you can detect:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Anomalies related to temporal deviations in values, counts, or frequencies
</li>
<li class="listitem">
Statistical rarity
</li>
<li class="listitem">
Unusual behaviors for a member of a population
</li>
</ul>
</div>
<p>And the best part? You can do this without having to specify algorithms, models,
or other data science-related configurations.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="scalability"></a>Scalability and resilience: clusters, nodes, and shards<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/intro.asciidoc">edit</a></h2>
</div></div></div>

<p>Elasticsearch is built to be always available and to scale with your needs. It does this
by being distributed by nature. You can add servers (nodes) to a cluster to
increase capacity and Elasticsearch automatically distributes your data and query load
across all of the available nodes. No need to overhaul your application, Elasticsearch
knows how to balance multi-node clusters to provide scale and high availability.
The more nodes, the merrier.</p>
<p>How does this work? Under the covers, an Elasticsearch index is really just a logical
grouping of one or more physical shards, where each shard is actually a
self-contained index. By distributing the documents in an index across multiple
shards, and distributing those shards across multiple nodes, Elasticsearch can ensure
redundancy, which both protects against hardware failures and increases
query capacity as nodes are added to a cluster. As the cluster grows (or shrinks),
Elasticsearch automatically migrates shards to rebalance the cluster.</p>
<p>There are two types of shards: primaries and replicas. Each document in an index
belongs to one primary shard. A replica shard is a copy of a primary shard.
Replicas provide redundant copies of your data to protect against hardware
failure and increase capacity to serve read requests
like searching or retrieving a document.</p>
<p>The number of primary shards in an index is fixed at the time that an index is
created, but the number of replica shards can be changed at any time, without
interrupting indexing or query operations.</p>
<h4><a id="it-depends"></a>It depends&#8230;&#8203;<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/intro.asciidoc">edit</a></h4>
<p>There are a number of performance considerations and trade offs with respect
to shard size and the number of primary shards configured for an index. The more
shards, the more overhead there is simply in maintaining those indices. The
larger the shard size, the longer it takes to move shards around when Elasticsearch
needs to rebalance a cluster.</p>
<p>Querying lots of small shards makes the processing per shard faster, but more
queries means more overhead, so querying a smaller
number of larger shards might be faster. In short&#8230;&#8203;it depends.</p>
<p>As a starting point:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Aim to keep the average shard size between a few GB and a few tens of GB. For
use cases with time-based data, it is common to see shards in the 20GB to 40GB
range.
</li>
<li class="listitem">
Avoid the gazillion shards problem. The number of shards a node can hold is
proportional to the available heap space. As a general rule, the number of
shards per GB of heap space should be less than 20.
</li>
</ul>
</div>
<p>The best way to determine the optimal configuration for your use case is
through <a href="https://www.elastic.co/elasticon/conf/2016/sf/quantitative-cluster-sizing" class="ulink" target="_top">
testing with your own data and queries</a>.</p>
<h4><a id="disaster-ccr"></a>In case of disaster<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/intro.asciidoc">edit</a></h4>
<p>For performance reasons, the nodes within a cluster need to be on the same
network. Balancing shards in a cluster across nodes in different data centers
simply takes too long. But high-availability architectures demand that you avoid
putting all of your eggs in one basket. In the event of a major outage in one
location, servers in another location need to be able to take over. Seamlessly.
The answer? Cross-cluster replication (CCR).</p>
<p>CCR provides a way to automatically synchronize indices from your primary cluster
to a secondary remote cluster that can serve as a hot backup. If the primary
cluster fails, the secondary cluster can take over. You can also use CCR to
create secondary clusters to serve read requests in geo-proximity to your users.</p>
<p>Cross-cluster replication is active-passive. The index on the primary cluster is
the active leader index and handles all write requests. Indices replicated to
secondary clusters are read-only followers.</p>
<h4><a id="admin"></a>Care and feeding<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/intro.asciidoc">edit</a></h4>
<p>As with any enterprise system, you need tools to secure, manage, and
monitor your Elasticsearch clusters. Security, monitoring, and administrative features
that are integrated into Elasticsearch enable you to use <a href="https://www.elastic.co/guide/en/kibana/7.10/introduction.html" class="ulink" target="_top">Kibana</a>
as a control center for managing a cluster. Features like <a class="xref" href="xpack-rollup.html" title="Rolling up historical data">data rollups</a> and <a class="xref" href="index-lifecycle-management.html" title="ILM: Manage the index lifecycle">index lifecycle management</a>
help you intelligently manage your data over time.</p>
</div>

</div>
<div class="navfooter">
<span class="prev">
</span>
<span class="next">
<a href="release-highlights.html">What&#8217;s new in 7.10 »</a>
</span>
</div>
</div>
</body>
</html>
