<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Metrics aggregations | Elasticsearch Guide | Elastic</title>
<meta class="elastic" name="content" content="Metrics aggregations | Elasticsearch Guide">

<link rel="home" href="index.html" title="Elasticsearch Guide"/>
<link rel="up" href="search-aggregations.html" title="Aggregations"/>
<link rel="prev" href="search-aggregations-bucket.html" title="Bucket aggregations"/>
<link rel="next" href="search-aggregations-pipeline.html" title="Pipeline aggregations"/>
<meta class="elastic" name="product_version" content=""/>
<meta class="elastic" name="product_name" content=""/>
<meta class="elastic" name="website_area" content="documentation"/>
<meta name="DC.type" content="Learn/Docs/"/>
<meta name="DC.subject" content=""/>
<meta name="DC.identifier" content=""/>
</head>
<body>
<div id="content">
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="/guide/">Elastic Docs</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="index.html">Elasticsearch Guide</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="search-aggregations.html">Aggregations</a></span>
</div>
<div class="navheader">
<span class="prev">
<a href="search-aggregations-bucket.html">« Bucket aggregations</a>
</span>
<span class="next">
<a href="search-aggregations-pipeline.html">Pipeline aggregations »</a>
</span>
</div>
<div class="chapter">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-metrics"></a>Metrics aggregations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics.asciidoc">edit</a></h2>
</div></div></div>
<p>The aggregations in this family compute metrics based on values extracted in one way or another from the documents that
are being aggregated. The values are typically extracted from the fields of the document (using the field data), but
can also be generated using scripts.</p>
<p>Numeric metrics aggregations are a special type of metrics aggregation which output numeric values. Some aggregations output
a single numeric metric (e.g. <code class="literal">avg</code>) and are called <code class="literal">single-value numeric metrics aggregation</code>, others generate multiple
metrics (e.g. <code class="literal">stats</code>) and are called <code class="literal">multi-value numeric metrics aggregation</code>. The distinction between single-value and
multi-value numeric metrics aggregations plays a role when these aggregations serve as direct sub-aggregations of some
bucket aggregations (some bucket aggregations enable you to sort the returned buckets based on the numeric metrics in each bucket).</p>
<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-metrics-avg-aggregation"></a>Avg aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/avg-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A <code class="literal">single-value</code> metrics aggregation that computes the average of numeric values that are extracted from the aggregated documents. These values can be extracted either from specific numeric or <a class="xref" href="mapping-types.html#histogram" title="Histogram field type">histogram</a> fields in the documents.</p>
<p>Assuming the data consists of documents representing exams grades (between 0
and 100) of students we can average their scores with:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /exams/_search?size=0
{
  "aggs": {
    "avg_grade": { "avg": { "field": "grade" } }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1351.console"></div>
<p>The above aggregation computes the average grade over all documents. The aggregation type is <code class="literal">avg</code> and the <code class="literal">field</code> setting defines the numeric field of the documents the average will be computed on. The above will return the following:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "avg_grade": {
      "value": 75.0
    }
  }
}</pre>
</div>
<p>The name of the aggregation (<code class="literal">avg_grade</code> above) also serves as the key by which the aggregation result can be retrieved from the returned response.</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_script_2"></a>Script<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/avg-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Let&#8217;s say the exam was exceedingly difficult, and you need to apply a grade correction. Average a <a class="xref" href="runtime.html" title="Runtime fields">runtime field</a> to get a corrected average:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /exams/_search?size=0
{
  "runtime_mappings": {
    "grade.corrected": {
      "type": "double",
      "script": {
        "source": "emit(Math.min(100, doc['grade'].value * params.correction))",
        "params": {
          "correction": 1.2
        }
      }
    }
  },
  "aggs": {
    "avg_corrected_grade": {
      "avg": {
        "field": "grade.corrected"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1352.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_missing_value_6"></a>Missing value<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/avg-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">missing</code> parameter defines how documents that are missing a value should be treated.
By default they will be ignored but it is also possible to treat them as if they
had a value.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /exams/_search?size=0
{
  "aggs": {
    "grade_avg": {
      "avg": {
        "field": "grade",
        "missing": 10     <a id="CO296-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1353.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO296-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Documents without a value in the <code class="literal">grade</code> field will fall into the same bucket as documents that have the value <code class="literal">10</code>.</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-metrics-avg-aggregation-histogram-fields"></a>Histogram fields<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/avg-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>When average is computed on <a class="xref" href="mapping-types.html#histogram" title="Histogram field type">histogram fields</a>, the result of the aggregation is the weighted average
of all elements in the <code class="literal">values</code> array taking into consideration the number in the same position in the <code class="literal">counts</code> array.</p>
<p>For example, for the following index that stores pre-aggregated histograms with latency metrics for different networks:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT metrics_index/_doc/1
{
  "network.name" : "net-1",
  "latency_histo" : {
      "values" : [0.1, 0.2, 0.3, 0.4, 0.5], <a id="CO297-1"></a><i class="conum" data-value="1"></i>
      "counts" : [3, 7, 23, 12, 6] <a id="CO297-2"></a><i class="conum" data-value="2"></i>
   }
}

PUT metrics_index/_doc/2
{
  "network.name" : "net-2",
  "latency_histo" : {
      "values" :  [0.1, 0.2, 0.3, 0.4, 0.5], <a id="CO297-3"></a><i class="conum" data-value="1"></i>
      "counts" : [8, 17, 8, 7, 6] <a id="CO297-4"></a><i class="conum" data-value="2"></i>
   }
}

POST /metrics_index/_search?size=0
{
  "aggs": {
    "avg_latency":
      { "avg": { "field": "latency_histo" }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1354.console"></div>
<p>For each histogram field the <code class="literal">avg</code> aggregation adds each number in the <code class="literal">values</code> array &lt;1&gt; multiplied by its associated count
in the <code class="literal">counts</code> array &lt;2&gt;. Eventually, it will compute the average over those values for all histograms and return the following result:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "avg_latency": {
      "value": 0.29690721649
    }
  }
}</pre>
</div>
</div>

</div>

<div class="section xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-metrics-boxplot-aggregation"></a>Boxplot aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/boxplot-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A <code class="literal">boxplot</code> metrics aggregation that computes boxplot of numeric values extracted from the aggregated documents.
These values can be generated from specific numeric or <a class="xref" href="mapping-types.html#histogram" title="Histogram field type">histogram fields</a> in the documents.</p>
<p>The <code class="literal">boxplot</code> aggregation returns essential information for making a <a href="https://en.wikipedia.org/wiki/Box_plot" class="ulink" target="_top">box plot</a>: minimum, maximum,
median, first quartile (25th percentile)  and third quartile (75th percentile) values.</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_syntax_3"></a>Syntax<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/boxplot-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>A <code class="literal">boxplot</code> aggregation looks like this in isolation:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "boxplot": {
    "field": "load_time"
  }
}</pre>
</div>
<p>Let&#8217;s look at a boxplot representing load time:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET latency/_search
{
  "size": 0,
  "aggs": {
    "load_time_boxplot": {
      "boxplot": {
        "field": "load_time" <a id="CO297-5"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1355.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO297-1"><i class="conum" data-value="1"></i></a><a href="#CO297-3"></a><a href="#CO297-5"></a></p>
</td>
<td align="left" valign="top">
<p>The field <code class="literal">load_time</code> must be a numeric field</p>
</td>
</tr>
</table>
</div>
<p>The response will look like this:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...

 "aggregations": {
    "load_time_boxplot": {
      "min": 0.0,
      "max": 990.0,
      "q1": 167.5,
      "q2": 445.0,
      "q3": 722.5,
      "lower": 0.0,
      "upper": 990.0
    }
  }
}</pre>
</div>
<p>In this case, the lower and upper whisker values are equal to the min and max. In general, these values are the 1.5 *
IQR range, which is to say the nearest values to <code class="literal">q1 - (1.5 * IQR)</code> and <code class="literal">q3 + (1.5 * IQR)</code>. Since this is an approximation, the given values
may not actually be observed values from the data, but should be within a reasonable error bound of them. While the Boxplot aggregation
doesn&#8217;t directly return outlier points, you can check if <code class="literal">lower &gt; min</code> or <code class="literal">upper &lt; max</code> to see if outliers exist on either side, and then
query for them directly.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_script_3"></a>Script<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/boxplot-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>If you need to create a boxplot for values that aren&#8217;t indexed exactly you
should create a <a class="xref" href="runtime.html" title="Runtime fields">runtime field</a> and get the boxplot of that. For
example, if your load times are in milliseconds but you want values calculated
in seconds, use a runtime field to convert them:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET latency/_search
{
  "size": 0,
  "runtime_mappings": {
    "load_time.seconds": {
      "type": "long",
      "script": {
        "source": "emit(doc['load_time'].value / params.timeUnit)",
        "params": {
          "timeUnit": 1000
        }
      }
    }
  },
  "aggs": {
    "load_time_boxplot": {
      "boxplot": { "field": "load_time.seconds" }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1356.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-metrics-boxplot-aggregation-approximation"></a>Boxplot values are (usually) approximate<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/boxplot-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The algorithm used by the <code class="literal">boxplot</code> metric is called TDigest (introduced by
Ted Dunning in
<a href="https://github.com/tdunning/t-digest/blob/master/docs/t-digest-paper/histo.pdf" class="ulink" target="_top">Computing Accurate Quantiles using T-Digests</a>).</p>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>Boxplot as other percentile aggregations are also
<a href="https://en.wikipedia.org/wiki/Nondeterministic_algorithm" class="ulink" target="_top">non-deterministic</a>.
This means you can get slightly different results using the same data.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-metrics-boxplot-aggregation-compression"></a>Compression<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/boxplot-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Approximate algorithms must balance memory utilization with estimation accuracy.
This balance can be controlled using a <code class="literal">compression</code> parameter:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET latency/_search
{
  "size": 0,
  "aggs": {
    "load_time_boxplot": {
      "boxplot": {
        "field": "load_time",
        "compression": 200    <a id="CO298-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1357.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO298-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Compression controls memory usage and approximation error</p>
</td>
</tr>
</table>
</div>
<p>The TDigest algorithm uses a number of "nodes" to approximate percentiles&#8201;&#8212;&#8201;the
more nodes available, the higher the accuracy (and large memory footprint) proportional
to the volume of data. The <code class="literal">compression</code> parameter limits the maximum number of
nodes to <code class="literal">20 * compression</code>.</p>
<p>Therefore, by increasing the compression value, you can increase the accuracy of
your percentiles at the cost of more memory. Larger compression values also
make the algorithm slower since the underlying tree data structure grows in size,
resulting in more expensive operations. The default compression value is
<code class="literal">100</code>.</p>
<p>A "node" uses roughly 32 bytes of memory, so under worst-case scenarios (large amount
of data which arrives sorted and in-order) the default settings will produce a
TDigest roughly 64KB in size. In practice data tends to be more random and
the TDigest will use less memory.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_execution_hint_3"></a>Execution hint<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/boxplot-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The default implementation of TDigest is optimized for performance, scaling to millions or even
billions of sample values while maintaining acceptable accuracy levels (close to 1% relative error
for millions of samples in some cases). There&#8217;s an option to use an implementation optimized
for accuracy by setting parameter <code class="literal">execution_hint</code> to value <code class="literal">high_accuracy</code>:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET latency/_search
{
  "size": 0,
  "aggs": {
    "load_time_boxplot": {
      "boxplot": {
        "field": "load_time",
        "execution_hint": "high_accuracy"    <a id="CO299-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1358.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO299-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Optimize TDigest for accuracy, at the expense of performance</p>
</td>
</tr>
</table>
</div>
<p>This option can lead to improved accuracy (relative error close to 0.01% for millions of samples in some
cases) but then percentile queries take 2x-10x longer to complete.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_missing_value_7"></a>Missing value<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/boxplot-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">missing</code> parameter defines how documents that are missing a value should be treated.
By default they will be ignored but it is also possible to treat them as if they
had a value.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET latency/_search
{
  "size": 0,
  "aggs": {
    "grade_boxplot": {
      "boxplot": {
        "field": "grade",
        "missing": 10     <a id="CO300-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1359.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO300-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Documents without a value in the <code class="literal">grade</code> field will fall into the same bucket as documents that have the value <code class="literal">10</code>.</p>
</td>
</tr>
</table>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-metrics-cardinality-aggregation"></a>Cardinality aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/cardinality-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A <code class="literal">single-value</code> metrics aggregation that calculates an approximate count of
distinct values.</p>
<p>Assume you are indexing store sales and would like to count the unique number of sold products that match a query:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "type_count": {
      "cardinality": {
        "field": "type"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1360.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "type_count": {
      "value": 3
    }
  }
}</pre>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_precision_control"></a>Precision control<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/cardinality-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>This aggregation also supports the <code class="literal">precision_threshold</code> option:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "type_count": {
      "cardinality": {
        "field": "type",
        "precision_threshold": 100 <a id="CO301-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1361.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO301-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">precision_threshold</code> options allows to trade memory for accuracy, and
defines a unique count below which counts are expected to be close to
accurate. Above this value, counts might become a bit more fuzzy. The maximum
supported value is 40000, thresholds above this number will have the same
effect as a threshold of 40000. The default value is <code class="literal">3000</code>.</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_counts_are_approximate"></a>Counts are approximate<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/cardinality-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Computing exact counts requires loading values into a hash set and returning its
size. This doesn&#8217;t scale when working on high-cardinality sets and/or large
values as the required memory usage and the need to communicate those
per-shard sets between nodes would utilize too many resources of the cluster.</p>
<p>This <code class="literal">cardinality</code> aggregation is based on the
<a href="https://static.googleusercontent.com/media/research.google.com/fr//pubs/archive/40671.pdf" class="ulink" target="_top">HyperLogLog++</a>
algorithm, which counts based on the hashes of the values with some interesting
properties:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
configurable precision, which decides on how to trade memory for accuracy,
</li>
<li class="listitem">
excellent accuracy on low-cardinality sets,
</li>
<li class="listitem">
fixed memory usage: no matter if there are tens or billions of unique values,
memory usage only depends on the configured precision.
</li>
</ul>
</div>
<p>For a precision threshold of <code class="literal">c</code>, the implementation that we are using requires
about <code class="literal">c * 8</code> bytes.</p>
<p>The following chart shows how the error varies before and after the threshold:</p>
<p><span class="image"><img src="images/cardinality_error.png" alt="cardinality error"></span></p>
<p>For all 3 thresholds, counts have been accurate up to the configured threshold.
Although not guaranteed, this is likely to be the case. Accuracy in practice depends
on the dataset in question. In general, most datasets show consistently good
accuracy. Also note that even with a threshold as low as 100, the error
remains very low (1-6% as seen in the above graph) even when counting millions of items.</p>
<p>The HyperLogLog++ algorithm depends on the leading zeros of hashed
values, the exact distributions of hashes in a dataset can affect the
accuracy of the cardinality.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_pre_computed_hashes"></a>Pre-computed hashes<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/cardinality-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>On string fields that have a high cardinality, it might be faster to store the
hash of your field values in your index and then run the cardinality aggregation
on this field. This can either be done by providing hash values from client-side
or by letting Elasticsearch compute hash values for you by using the
<a href="https://www.elastic.co/guide/en/elasticsearch/plugins/8.9/mapper-murmur3.html" class="ulink" target="_top"><code class="literal">mapper-murmur3</code></a> plugin.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>Pre-computing hashes is usually only useful on very large and/or
high-cardinality fields as it saves CPU and memory. However, on numeric
fields, hashing is very fast and storing the original values requires as much
or less memory than storing the hashes. This is also true on low-cardinality
string fields, especially given that those have an optimization in order to
make sure that hashes are computed at most once per unique value per segment.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_script_4"></a>Script<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/cardinality-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>If you need the cardinality of the combination of two fields,
create a <a class="xref" href="runtime.html" title="Runtime fields">runtime field</a> combining them and aggregate it.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "runtime_mappings": {
    "type_and_promoted": {
      "type": "keyword",
      "script": "emit(doc['type'].value + ' ' + doc['promoted'].value)"
    }
  },
  "aggs": {
    "type_promoted_count": {
      "cardinality": {
        "field": "type_and_promoted"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1362.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_missing_value_8"></a>Missing value<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/cardinality-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">missing</code> parameter defines how documents that are missing a value should be treated.
By default they will be ignored but it is also possible to treat them as if they
had a value.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "tag_cardinality": {
      "cardinality": {
        "field": "tag",
        "missing": "N/A" <a id="CO302-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1363.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO302-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Documents without a value in the <code class="literal">tag</code> field will fall into the same bucket as documents that have the value <code class="literal">N/A</code>.</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_execution_hint_4"></a>Execution hint<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/cardinality-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>You can run cardinality aggregations using different mechanisms:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
by using field values directly (<code class="literal">direct</code>)
</li>
<li class="listitem">
by using global ordinals of the field and resolving those values after
finishing a shard (<code class="literal">global_ordinals</code>)
</li>
<li class="listitem">
by using segment ordinal values and resolving those values after each
segment (<code class="literal">segment_ordinals</code>)
</li>
</ul>
</div>
<p>Additionally, there are two "heuristic based" modes.  These modes will cause
Elasticsearch to use some data about the state of the index to choose an
appropriate execution method.  The two heuristics are:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<code class="literal">save_time_heuristic</code> - this is the default in Elasticsearch 8.4 and later.
</li>
<li class="listitem">
<code class="literal">save_memory_heuristic</code> - this was the default in Elasticsearch 8.3 and
earlier
</li>
</ul>
</div>
<p>When not specified, Elasticsearch will apply a heuristic to choose the
appropriate mode.  Also note that for some data (non-ordinal fields), <code class="literal">direct</code>
is the only option, and the hint will be ignored in these cases.  Generally
speaking, it should not be necessary to set this value.</p>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-metrics-extendedstats-aggregation"></a>Extended stats aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/extendedstats-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A <code class="literal">multi-value</code> metrics aggregation that computes stats over numeric values extracted from the aggregated documents.</p>
<p>The <code class="literal">extended_stats</code> aggregations is an extended version of the <a class="xref" href="search-aggregations-metrics.html#search-aggregations-metrics-stats-aggregation" title="Stats aggregation"><code class="literal">stats</code></a> aggregation, where additional metrics are added such as <code class="literal">sum_of_squares</code>, <code class="literal">variance</code>, <code class="literal">std_deviation</code> and <code class="literal">std_deviation_bounds</code>.</p>
<p>Assuming the data consists of documents representing exams grades (between 0 and 100) of students</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /exams/_search
{
  "size": 0,
  "aggs": {
    "grades_stats": { "extended_stats": { "field": "grade" } }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1364.console"></div>
<p>The above aggregation computes the grades statistics over all documents. The aggregation type is <code class="literal">extended_stats</code> and the <code class="literal">field</code> setting defines the numeric field of the documents the stats will be computed on. The above will return the following:</p>
<p>The <code class="literal">std_deviation</code> and <code class="literal">variance</code> are calculated as population metrics so they are always the same as <code class="literal">std_deviation_population</code> and <code class="literal">variance_population</code> respectively.</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...

  "aggregations": {
    "grades_stats": {
      "count": 2,
      "min": 50.0,
      "max": 100.0,
      "avg": 75.0,
      "sum": 150.0,
      "sum_of_squares": 12500.0,
      "variance": 625.0,
      "variance_population": 625.0,
      "variance_sampling": 1250.0,
      "std_deviation": 25.0,
      "std_deviation_population": 25.0,
      "std_deviation_sampling": 35.35533905932738,
      "std_deviation_bounds": {
        "upper": 125.0,
        "lower": 25.0,
        "upper_population": 125.0,
        "lower_population": 25.0,
        "upper_sampling": 145.71067811865476,
        "lower_sampling": 4.289321881345245
      }
    }
  }
}</pre>
</div>
<p>The name of the aggregation (<code class="literal">grades_stats</code> above) also serves as the key by which the aggregation result can be retrieved from the returned response.</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_standard_deviation_bounds"></a>Standard Deviation Bounds<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/extendedstats-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>By default, the <code class="literal">extended_stats</code> metric will return an object called <code class="literal">std_deviation_bounds</code>, which provides an interval of plus/minus two standard
deviations from the mean. This can be a useful way to visualize variance of your data. If you want a different boundary, for example
three standard deviations, you can set <code class="literal">sigma</code> in the request:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /exams/_search
{
  "size": 0,
  "aggs": {
    "grades_stats": {
      "extended_stats": {
        "field": "grade",
        "sigma": 3          <a id="CO303-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1365.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO303-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p><code class="literal">sigma</code> controls how many standard deviations +/- from the mean should be displayed</p>
</td>
</tr>
</table>
</div>
<p><code class="literal">sigma</code> can be any non-negative double, meaning you can request non-integer values such as <code class="literal">1.5</code>. A value of <code class="literal">0</code> is valid, but will simply
return the average for both <code class="literal">upper</code> and <code class="literal">lower</code> bounds.</p>
<p>The <code class="literal">upper</code> and <code class="literal">lower</code> bounds are calculated as population metrics so they are always the same as <code class="literal">upper_population</code> and
<code class="literal">lower_population</code> respectively.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<h3>Standard Deviation and Bounds require normality</h3>
<p>The standard deviation and its bounds are displayed by default, but they are not always applicable to all data-sets. Your data must
be normally distributed for the metrics to make sense. The statistics behind standard deviations assumes normally distributed data, so
if your data is skewed heavily left or right, the value returned will be misleading.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_script_5"></a>Script<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/extendedstats-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>If you need to aggregate on a value that isn&#8217;t indexed, use a <a class="xref" href="runtime.html" title="Runtime fields">runtime field</a>.
Say the we found out that the grades we&#8217;ve been working on were for an exam that was above
the level of the students and we want to "correct" it:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /exams/_search
{
  "size": 0,
  "runtime_mappings": {
    "grade.corrected": {
      "type": "double",
      "script": {
        "source": "emit(Math.min(100, doc['grade'].value * params.correction))",
        "params": {
          "correction": 1.2
        }
      }
    }
  },
  "aggs": {
    "grades_stats": {
      "extended_stats": { "field": "grade.corrected" }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1366.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_missing_value_9"></a>Missing value<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/extendedstats-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">missing</code> parameter defines how documents that are missing a value should be treated.
By default they will be ignored but it is also possible to treat them as if they
had a value.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /exams/_search
{
  "size": 0,
  "aggs": {
    "grades_stats": {
      "extended_stats": {
        "field": "grade",
        "missing": 0        <a id="CO304-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1367.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO304-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Documents without a value in the <code class="literal">grade</code> field will fall into the same bucket as documents that have the value <code class="literal">0</code>.</p>
</td>
</tr>
</table>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-metrics-geobounds-aggregation"></a>Geo-bounds aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/geobounds-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A metric aggregation that computes the geographic bounding box containing all values for a <a class="xref" href="mapping-types.html#geo-point" title="Geopoint field type">Geopoint</a> or <a class="xref" href="mapping-types.html#geo-shape" title="Geoshape field type">Geoshape</a> field.</p>
<p>Example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /museums
{
  "mappings": {
    "properties": {
      "location": {
        "type": "geo_point"
      }
    }
  }
}

POST /museums/_bulk?refresh
{"index":{"_id":1}}
{"location": "POINT (4.912350 52.374081)", "name": "NEMO Science Museum"}
{"index":{"_id":2}}
{"location": "POINT (4.901618 52.369219)", "name": "Museum Het Rembrandthuis"}
{"index":{"_id":3}}
{"location": "POINT (4.914722 52.371667)", "name": "Nederlands Scheepvaartmuseum"}
{"index":{"_id":4}}
{"location": "POINT (4.405200 51.222900)", "name": "Letterenhuis"}
{"index":{"_id":5}}
{"location": "POINT (2.336389 48.861111)", "name": "Musée du Louvre"}
{"index":{"_id":6}}
{"location": "POINT (2.327000 48.860000)", "name": "Musée d'Orsay"}

POST /museums/_search?size=0
{
  "query": {
    "match": { "name": "musée" }
  },
  "aggs": {
    "viewport": {
      "geo_bounds": {
        "field": "location",    <a id="CO305-1"></a><i class="conum" data-value="1"></i>
        "wrap_longitude": true  <a id="CO305-2"></a><i class="conum" data-value="2"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1368.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO305-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">geo_bounds</code> aggregation specifies the field to use to obtain the bounds, which must be a <a class="xref" href="mapping-types.html#geo-point" title="Geopoint field type">Geopoint</a> or a <a class="xref" href="mapping-types.html#geo-shape" title="Geoshape field type">Geoshape</a> type.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO305-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p><a id="geo-bounds-wrap-longitude"></a> <code class="literal">wrap_longitude</code> is an optional parameter which specifies whether the bounding box should be allowed to overlap the international date line. The default value is <code class="literal">true</code>.</p>
</td>
</tr>
</table>
</div>
<p>The above aggregation demonstrates how one would compute the bounding box of the location field for all documents with a name matching "musée".</p>
<p>The response for the above aggregation:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "viewport": {
      "bounds": {
        "top_left": {
          "lat": 48.86111099738628,
          "lon": 2.3269999679178
        },
        "bottom_right": {
          "lat": 48.85999997612089,
          "lon": 2.3363889567553997
        }
      }
    }
  }
}</pre>
</div>
<h4 class="xpack"><a id="geobounds-aggregation-geo-shape"></a>Geo Bounds Aggregation on <code class="literal">geo_shape</code> fields<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/geobounds-aggregation.asciidoc">edit</a></h4>
<p>The Geo Bounds Aggregation is also supported on <code class="literal">geo_shape</code> fields.</p>
<p>If <a class="xref" href="search-aggregations-metrics.html#geo-bounds-wrap-longitude"><code class="literal">wrap_longitude</code></a> is set to <code class="literal">true</code>
(the default), the bounding box can overlap the international date line and
return a bounds where the <code class="literal">top_left</code> longitude is larger than the <code class="literal">top_right</code>
longitude.</p>
<p>For example, the upper right longitude will typically be greater than the lower
left longitude of a geographic bounding box. However, when the area
crosses the 180° meridian, the value of the lower left longitude will be
greater than the value of the upper right longitude. See
<a href="http://docs.opengeospatial.org/is/12-063r5/12-063r5.html#30" class="ulink" target="_top">Geographic bounding box</a> on the Open Geospatial Consortium website for more information.</p>
<p>Example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /places
{
  "mappings": {
    "properties": {
      "geometry": {
        "type": "geo_shape"
      }
    }
  }
}

POST /places/_bulk?refresh
{"index":{"_id":1}}
{"name": "NEMO Science Museum", "geometry": "POINT(4.912350 52.374081)" }
{"index":{"_id":2}}
{"name": "Sportpark De Weeren", "geometry": { "type": "Polygon", "coordinates": [ [ [ 4.965305328369141, 52.39347642069457 ], [ 4.966979026794433, 52.391721758934835 ], [ 4.969425201416015, 52.39238958618537 ], [ 4.967944622039794, 52.39420969150824 ], [ 4.965305328369141, 52.39347642069457 ] ] ] } }

POST /places/_search?size=0
{
  "aggs": {
    "viewport": {
      "geo_bounds": {
        "field": "geometry"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1369.console"></div>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "viewport": {
      "bounds": {
        "top_left": {
          "lat": 52.39420966710895,
          "lon": 4.912349972873926
        },
        "bottom_right": {
          "lat": 52.374080987647176,
          "lon": 4.969425117596984
        }
      }
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-metrics-geocentroid-aggregation"></a>Geo-centroid aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/geocentroid-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A metric aggregation that computes the weighted <a href="https://en.wikipedia.org/wiki/Centroid" class="ulink" target="_top">centroid</a> from all coordinate values for geo fields.</p>
<p>Example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /museums
{
  "mappings": {
    "properties": {
      "location": {
        "type": "geo_point"
      }
    }
  }
}

POST /museums/_bulk?refresh
{"index":{"_id":1}}
{"location": "POINT (4.912350 52.374081)", "city": "Amsterdam", "name": "NEMO Science Museum"}
{"index":{"_id":2}}
{"location": "POINT (4.901618 52.369219)", "city": "Amsterdam", "name": "Museum Het Rembrandthuis"}
{"index":{"_id":3}}
{"location": "POINT (4.914722 52.371667)", "city": "Amsterdam", "name": "Nederlands Scheepvaartmuseum"}
{"index":{"_id":4}}
{"location": "POINT (4.405200 51.222900)", "city": "Antwerp", "name": "Letterenhuis"}
{"index":{"_id":5}}
{"location": "POINT (2.336389 48.861111)", "city": "Paris", "name": "Musée du Louvre"}
{"index":{"_id":6}}
{"location": "POINT (2.327000 48.860000)", "city": "Paris", "name": "Musée d'Orsay"}

POST /museums/_search?size=0
{
  "aggs": {
    "centroid": {
      "geo_centroid": {
        "field": "location" <a id="CO306-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1370.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO306-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">geo_centroid</code> aggregation specifies the field to use for computing the centroid. (NOTE: field must be a <a class="xref" href="mapping-types.html#geo-point" title="Geopoint field type">Geopoint</a> type)</p>
</td>
</tr>
</table>
</div>
<p>The above aggregation demonstrates how one would compute the centroid of the location field for all museums' documents.</p>
<p>The response for the above aggregation:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "centroid": {
      "location": {
        "lat": 51.00982965203002,
        "lon": 3.9662131341174245
      },
      "count": 6
    }
  }
}</pre>
</div>
<p>The <code class="literal">geo_centroid</code> aggregation is more interesting when combined as a sub-aggregation to other bucket aggregations.</p>
<p>Example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /museums/_search?size=0
{
  "aggs": {
    "cities": {
      "terms": { "field": "city.keyword" },
      "aggs": {
        "centroid": {
          "geo_centroid": { "field": "location" }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1371.console"></div>
<p>The above example uses <code class="literal">geo_centroid</code> as a sub-aggregation to a
<a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation" title="Terms aggregation">terms</a> bucket aggregation
for finding the central location for museums in each city.</p>
<p>The response for the above aggregation:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "cities": {
      "sum_other_doc_count": 0,
      "doc_count_error_upper_bound": 0,
      "buckets": [
        {
          "key": "Amsterdam",
          "doc_count": 3,
          "centroid": {
            "location": {
              "lat": 52.371655656024814,
              "lon": 4.909563297405839
            },
            "count": 3
          }
        },
        {
          "key": "Paris",
          "doc_count": 2,
          "centroid": {
            "location": {
              "lat": 48.86055548675358,
              "lon": 2.3316944623366
            },
            "count": 2
          }
        },
        {
          "key": "Antwerp",
          "doc_count": 1,
          "centroid": {
            "location": {
              "lat": 51.22289997059852,
              "lon": 4.40519998781383
            },
            "count": 1
          }
        }
      ]
    }
  }
}</pre>
</div>
<h4 class="xpack"><a id="geocentroid-aggregation-geo-shape"></a>Geo Centroid Aggregation on <code class="literal">geo_shape</code> fields<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/geocentroid-aggregation.asciidoc">edit</a></h4>
<p>The centroid metric for geoshapes is more nuanced than for points. The centroid of a specific aggregation bucket
containing shapes is the centroid of the highest-dimensionality shape type in the bucket. For example, if a bucket contains
shapes comprising of polygons and lines, then the lines do not contribute to the centroid metric. Each type of shape&#8217;s
centroid is calculated differently. Envelopes and circles ingested via the <a class="xref" href="processors.html#ingest-circle-processor" title="Circle processor">Circle</a> are treated
as polygons.</p>
<div class="informaltable">
<table border="1" cellpadding="4px">
<colgroup>
<col class="col_1"/>
<col class="col_2"/>
</colgroup>
<thead>
<tr>
<th align="left" valign="top">Geometry Type</th>
<th align="left" valign="top">Centroid Calculation</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p>[Multi]Point</p></td>
<td align="left" valign="top"><p>equally weighted average of all the coordinates</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>[Multi]LineString</p></td>
<td align="left" valign="top"><p>a weighted average of all the centroids of each segment, where the weight of each segment is its length in degrees</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>[Multi]Polygon</p></td>
<td align="left" valign="top"><p>a weighted average of all the centroids of all the triangles of a polygon where the triangles are formed by every two consecutive vertices and the starting-point.
 holes have negative weights. weights represent the area of the triangle in deg^2 calculated</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>GeometryCollection</p></td>
<td align="left" valign="top"><p>The centroid of all the underlying geometries with the highest dimension. If Polygons and Lines and/or Points, then lines and/or points are ignored.
 If Lines and Points, then points are ignored</p></td>
</tr>
</tbody>
</table>
</div>
<p>Example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /places
{
  "mappings": {
    "properties": {
      "geometry": {
        "type": "geo_shape"
      }
    }
  }
}

POST /places/_bulk?refresh
{"index":{"_id":1}}
{"name": "NEMO Science Museum", "geometry": "POINT(4.912350 52.374081)" }
{"index":{"_id":2}}
{"name": "Sportpark De Weeren", "geometry": { "type": "Polygon", "coordinates": [ [ [ 4.965305328369141, 52.39347642069457 ], [ 4.966979026794433, 52.391721758934835 ], [ 4.969425201416015, 52.39238958618537 ], [ 4.967944622039794, 52.39420969150824 ], [ 4.965305328369141, 52.39347642069457 ] ] ] } }

POST /places/_search?size=0
{
  "aggs": {
    "centroid": {
      "geo_centroid": {
        "field": "geometry"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1372.console"></div>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "centroid": {
      "location": {
        "lat": 52.39296147599816,
        "lon": 4.967404240742326
      },
      "count": 2
    }
  }
}</pre>
</div>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<h3>Using <code class="literal">geo_centroid</code> as a sub-aggregation of <code class="literal">geohash_grid</code></h3>
<p>The <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-geohashgrid-aggregation" title="Geohash grid aggregation"><code class="literal">geohash_grid</code></a>
aggregation places documents, not individual geopoints, into buckets. If a
document&#8217;s <code class="literal">geo_point</code> field contains <a class="xref" href="mapping-types.html#array" title="Arrays">multiple values</a>, the document
could be assigned to multiple buckets, even if one or more of its geopoints are
outside the bucket boundaries.</p>
<p>If a <code class="literal">geocentroid</code> sub-aggregation is also used, each centroid is calculated
using all geopoints in a bucket, including those outside the bucket boundaries.
This can result in centroids outside of bucket boundaries.</p>
</div>
</div>
</div>

<div class="section xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-metrics-geo-line"></a>Geo-line aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/geoline-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>The <code class="literal">geo_line</code> aggregation aggregates all <code class="literal">geo_point</code> values within a bucket into a <code class="literal">LineString</code> ordered
by the chosen <code class="literal">sort</code> field. This <code class="literal">sort</code> can be a date field, for example. The bucket returned is a valid
<a href="https://tools.ietf.org/html/rfc7946#section-3.2" class="ulink" target="_top">GeoJSON Feature</a> representing the line geometry.</p>
<a id="search-aggregations-metrics-geo-line-simple"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT test
{
    "mappings": {
        "properties": {
            "my_location": { "type": "geo_point" },
            "group":       { "type": "keyword" },
            "@timestamp":  { "type": "date" }
        }
    }
}

POST /test/_bulk?refresh
{"index":{}}
{"my_location": {"lat":52.373184, "lon":4.889187}, "@timestamp": "2023-01-02T09:00:00Z"}
{"index":{}}
{"my_location": {"lat":52.370159, "lon":4.885057}, "@timestamp": "2023-01-02T10:00:00Z"}
{"index":{}}
{"my_location": {"lat":52.369219, "lon":4.901618}, "@timestamp": "2023-01-02T13:00:00Z"}
{"index":{}}
{"my_location": {"lat":52.374081, "lon":4.912350}, "@timestamp": "2023-01-02T16:00:00Z"}
{"index":{}}
{"my_location": {"lat":52.371667, "lon":4.914722}, "@timestamp": "2023-01-03T12:00:00Z"}

POST /test/_search?filter_path=aggregations
{
  "aggs": {
    "line": {
      "geo_line": {
        "point": {"field": "my_location"},
        "sort":  {"field": "@timestamp"}
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1373.console"></div>
<p>Which returns:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "aggregations": {
    "line": {
      "type": "Feature",
      "geometry": {
        "type": "LineString",
        "coordinates": [
            [ 4.889187, 52.373184 ],
            [ 4.885057, 52.370159 ],
            [ 4.901618, 52.369219 ],
            [ 4.912350, 52.374081 ],
            [ 4.914722, 52.371667 ]
        ]
      },
      "properties": {
        "complete": true
      }
    }
  }
}</pre>
</div>
<p>The resulting <a href="https://tools.ietf.org/html/rfc7946#section-3.2" class="ulink" target="_top">GeoJSON Feature</a> contains both a <code class="literal">LineString</code> geometry
for the path generated by the aggregation, as well as a map of <code class="literal">properties</code>.
The property <code class="literal">complete</code> informs of whether all documents matched were used to generate the geometry.
The <a class="xref" href="search-aggregations-metrics.html#search-aggregations-metrics-geo-line-size"><code class="literal">size</code> option</a> can be used to limit the number of documents included in the aggregation,
leading to results  with <code class="literal">complete: false</code>.
Exactly which documents are dropped from results <a class="xref" href="search-aggregations-metrics.html#search-aggregations-metrics-geo-line-grouping-time-series-advantages" title="Why group with time-series?">depends on whether the aggregation is based
on <code class="literal">time_series</code> or not</a>.</p>
<p>This result could be displayed in a map user interface:</p>
<p><span class="image"><img src="images/spatial/geo_line.png" alt="Kibana map with museum tour of Amsterdam"></span></p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-metrics-geo-line-options"></a>Options<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/geoline-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">point</code>
</span>
</dt>
<dd>
(Required)
</dd>
</dl>
</div>
<p>This option specifies the name of the <code class="literal">geo_point</code> field</p>
<p>Example usage configuring <code class="literal">my_location</code> as the point field:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">"point": {
  "field": "my_location"
}</pre>
</div>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">sort</code>
</span>
</dt>
<dd>
(Required outside <a class="xref" href="search-aggregations-metrics.html#search-aggregations-metrics-geo-line-grouping-time-series" title="Grouping with time-series"><code class="literal">time_series</code></a> aggregations)
</dd>
</dl>
</div>
<p>This option specifies the name of the numeric field to use as the sort key for ordering the points.
When the <code class="literal">geo_line</code> aggregation is nested inside a
<a class="xref" href="search-aggregations-metrics.html#search-aggregations-metrics-geo-line-grouping-time-series" title="Grouping with time-series"><code class="literal">time_series</code></a>
aggregation, this field defaults to <code class="literal">@timestamp</code>, and any other value will result in error.</p>
<p>Example usage configuring <code class="literal">@timestamp</code> as the sort key:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">"sort": {
  "field": "@timestamp"
}</pre>
</div>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">include_sort</code>
</span>
</dt>
<dd>
(Optional, boolean, default: <code class="literal">false</code>) This option includes, when true, an additional array of the sort values in the
feature properties.
</dd>
<dt>
<span class="term">
<code class="literal">sort_order</code>
</span>
</dt>
<dd>
(Optional, string, default: <code class="literal">"ASC"</code>) This option accepts one of two values: "ASC", "DESC".
The line is sorted in ascending order by the sort key when set to "ASC", and in descending
with "DESC".
</dd>
</dl>
</div>
<div class="variablelist">
<a id="search-aggregations-metrics-geo-line-size"></a>
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">size</code>
</span>
</dt>
<dd>
(Optional, integer, default: <code class="literal">10000</code>) The maximum length of the line represented in the aggregation.
Valid sizes are between one and 10000.
Within <a class="xref" href="search-aggregations-metrics.html#search-aggregations-metrics-geo-line-grouping-time-series" title="Grouping with time-series"><code class="literal">time_series</code></a>
the aggregation uses line simplification to constrain the size, otherwise it uses truncation.
Refer to <a class="xref" href="search-aggregations-metrics.html#search-aggregations-metrics-geo-line-grouping-time-series-advantages" title="Why group with time-series?">Why group with time-series?</a>
for a discussion on the subtleties involved.
</dd>
</dl>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-metrics-geo-line-grouping"></a>Grouping<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/geoline-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>This simple example produces a single track for all the data selected by the query. However, it is far more
common to need to group the data into multiple tracks. For example, grouping flight transponder measurements by
flight call-sign before sorting each flight by timestamp and producing a separate track for each.</p>
<p>In the following examples we will group the locations of points of interest in the cities of
Amsterdam, Antwerp and Paris.
The tracks will be ordered by the planned visit sequence for a walking tour of the museums and others attractions.</p>
<p>In order to demonstrate the difference between a time-series grouping and a non-time-series grouping, we will
first create an index with <a class="xref" href="tsds.html#tsds-index-settings" title="Time series index settings">time-series enabled</a>,
and then give examples of grouping the same data without time-series and with time-series.</p>
<a id="search-aggregations-metrics-geo-line-grouping-setup"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT tour
{
    "mappings": {
        "properties": {
            "city": {
                "type": "keyword",
                "time_series_dimension": true
            },
            "category":   { "type": "keyword" },
            "route":      { "type": "long" },
            "name":       { "type": "keyword" },
            "location":   { "type": "geo_point" },
            "@timestamp": { "type": "date" }
        }
    },
    "settings": {
        "index": {
            "mode": "time_series",
            "routing_path": [ "city" ],
            "time_series": {
                "start_time": "2023-01-01T00:00:00Z",
                "end_time": "2024-01-01T00:00:00Z"
            }
        }
    }
}

POST /tour/_bulk?refresh
{"index":{}}
{"@timestamp": "2023-01-02T09:00:00Z", "route": 0, "location": "POINT(4.889187 52.373184)", "city": "Amsterdam", "category": "Attraction", "name": "Royal Palace Amsterdam"}
{"index":{}}
{"@timestamp": "2023-01-02T10:00:00Z", "route": 1, "location": "POINT(4.885057 52.370159)", "city": "Amsterdam", "category": "Attraction", "name": "The Amsterdam Dungeon"}
{"index":{}}
{"@timestamp": "2023-01-02T13:00:00Z", "route": 2, "location": "POINT(4.901618 52.369219)", "city": "Amsterdam", "category": "Museum", "name": "Museum Het Rembrandthuis"}
{"index":{}}
{"@timestamp": "2023-01-02T16:00:00Z", "route": 3, "location": "POINT(4.912350 52.374081)", "city": "Amsterdam", "category": "Museum", "name": "NEMO Science Museum"}
{"index":{}}
{"@timestamp": "2023-01-03T12:00:00Z", "route": 4, "location": "POINT(4.914722 52.371667)", "city": "Amsterdam", "category": "Museum", "name": "Nederlands Scheepvaartmuseum"}
{"index":{}}
{"@timestamp": "2023-01-04T09:00:00Z", "route": 5, "location": "POINT(4.401384 51.220292)", "city": "Antwerp", "category": "Attraction", "name": "Cathedral of Our Lady"}
{"index":{}}
{"@timestamp": "2023-01-04T12:00:00Z", "route": 6, "location": "POINT(4.405819 51.221758)", "city": "Antwerp", "category": "Museum", "name": "Snijders&amp;Rockoxhuis"}
{"index":{}}
{"@timestamp": "2023-01-04T15:00:00Z", "route": 7, "location": "POINT(4.405200 51.222900)", "city": "Antwerp", "category": "Museum", "name": "Letterenhuis"}
{"index":{}}
{"@timestamp": "2023-01-05T10:00:00Z", "route": 8, "location": "POINT(2.336389 48.861111)", "city": "Paris", "category": "Museum", "name": "Musée du Louvre"}
{"index":{}}
{"@timestamp": "2023-01-05T14:00:00Z", "route": 9, "location": "POINT(2.327000 48.860000)", "city": "Paris", "category": "Museum", "name": "Musée dOrsay"}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1374.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-metrics-geo-line-grouping-terms"></a>Grouping with terms<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/geoline-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Using this data, for a non-time-series use case, the grouping can be done using a
<a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation" title="Terms aggregation">terms aggregation</a> based on city name.
This would work whether or not we had defined the <code class="literal">tour</code> index as a time series index.</p>
<a id="search-aggregations-metrics-geo-line-terms"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /tour/_search?filter_path=aggregations
{
  "aggregations": {
    "path": {
      "terms": {"field": "city"},
      "aggregations": {
        "museum_tour": {
          "geo_line": {
            "point": {"field": "location"},
            "sort": {"field": "@timestamp"}
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1375.console"></div>
<p>Which returns:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "aggregations": {
    "path": {
      "doc_count_error_upper_bound": 0,
      "sum_other_doc_count": 0,
      "buckets": [
        {
          "key": "Amsterdam",
          "doc_count": 5,
          "museum_tour": {
            "type": "Feature",
            "geometry": {
              "coordinates": [ [ 4.889187, 52.373184 ], [ 4.885057, 52.370159 ], [ 4.901618, 52.369219 ], [ 4.91235, 52.374081 ], [ 4.914722, 52.371667 ] ],
              "type": "LineString"
            },
            "properties": {
              "complete": true
            }
          }
        },
        {
          "key": "Antwerp",
          "doc_count": 3,
          "museum_tour": {
            "type": "Feature",
            "geometry": {
              "coordinates": [ [ 4.401384, 51.220292 ], [ 4.405819, 51.221758 ], [ 4.4052, 51.2229 ] ],
              "type": "LineString"
            },
            "properties": {
              "complete": true
            }
          }
        },
        {
          "key": "Paris",
          "doc_count": 2,
          "museum_tour": {
            "type": "Feature",
            "geometry": {
              "coordinates": [ [ 2.336389, 48.861111 ], [ 2.327, 48.86 ] ],
              "type": "LineString"
            },
            "properties": {
              "complete": true
            }
          }
        }
      ]
    }
  }
}</pre>
</div>
<p>These results contain an array of buckets, where each bucket is a JSON object with the <code class="literal">key</code> showing the name
of the <code class="literal">city</code> field, and an inner aggregation result called <code class="literal">museum_tour</code> containing a
<a href="https://tools.ietf.org/html/rfc7946#section-3.2" class="ulink" target="_top">GeoJSON Feature</a> describing the
actual route between the various attractions in that city.
Each result also includes a <code class="literal">properties</code> object with a <code class="literal">complete</code> value which will be <code class="literal">false</code> if the geometry
was truncated to the limits specified in the <code class="literal">size</code> parameter.
Note that when we use <code class="literal">time_series</code> in the next example, we will get the same results structured a little differently.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-metrics-geo-line-grouping-time-series"></a>Grouping with time-series<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/geoline-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>This functionality is in technical preview and may be changed or removed in a future release. Elastic will apply best effort to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.</p>
</div>
</div>
<p>Using the same data as before, we can also perform the grouping with a
<a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-time-series-aggregation" title="Time series aggregation"><code class="literal">time_series</code> aggregation</a>.
This will group by TSID, which is defined as the combinations of all fields with <code class="literal">time_series_dimension: true</code>,
in this case the same <code class="literal">city</code> field used in the previous
<a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation" title="Terms aggregation">terms aggregation</a>.
This example will only work if we defined the <code class="literal">tour</code> index as a time series index using  <code class="literal">index.mode="time_series"</code>.</p>
<a id="search-aggregations-metrics-geo-line-time-series"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /tour/_search?filter_path=aggregations
{
  "aggregations": {
    "path": {
      "time_series": {},
      "aggregations": {
        "museum_tour": {
          "geo_line": {
            "point": {"field": "location"}
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1376.console"></div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>The <code class="literal">geo_line</code> aggregation no longer requires the <code class="literal">sort</code> field when nested within a
<a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-time-series-aggregation" title="Time series aggregation"><code class="literal">time_series</code> aggregation</a>.
This is because the sort field is set to <code class="literal">@timestamp</code>, which all time-series indexes are pre-sorted by.
If you do set this parameter, and set it to something other than <code class="literal">@timestamp</code> you will get an error.</p>
</div>
</div>
<p>This query will result in:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "aggregations": {
    "path": {
      "buckets": {
        "{city=Paris}": {
          "key": {
            "city": "Paris"
          },
          "doc_count": 2,
          "museum_tour": {
            "type": "Feature",
            "geometry": {
              "coordinates": [ [ 2.336389, 48.861111 ], [ 2.327, 48.86 ] ],
              "type": "LineString"
            },
            "properties": {
              "complete": true
            }
          }
        },
        "{city=Antwerp}": {
          "key": {
            "city": "Antwerp"
          },
          "doc_count": 3,
          "museum_tour": {
            "type": "Feature",
            "geometry": {
              "coordinates": [ [ 4.401384, 51.220292 ], [ 4.405819, 51.221758 ], [ 4.4052, 51.2229 ] ],
              "type": "LineString"
            },
            "properties": {
              "complete": true
            }
          }
        },
        "{city=Amsterdam}": {
          "key": {
            "city": "Amsterdam"
          },
          "doc_count": 5,
          "museum_tour": {
            "type": "Feature",
            "geometry": {
              "coordinates": [ [ 4.889187, 52.373184 ], [ 4.885057, 52.370159 ], [ 4.901618, 52.369219 ], [ 4.91235, 52.374081 ], [ 4.914722, 52.371667 ] ],
              "type": "LineString"
            },
            "properties": {
              "complete": true
            }
          }
        }
      }
    }
  }
}</pre>
</div>
<p>These results are essentially the same as with the previous <code class="literal">terms</code> aggregation example, but structured differently.
Here we see the buckets returned as a map, where the key is an internal description of the TSID.
This TSID is unique for each unique combination of fields with <code class="literal">time_series_dimension: true</code>.
Each bucket contains a <code class="literal">key</code> field which is also a map of all dimension values for the TSID, in this case only the city
name is used for grouping.
In addition, there is an inner aggregation result called <code class="literal">museum_tour</code> containing a
<a href="https://tools.ietf.org/html/rfc7946#section-3.2" class="ulink" target="_top">GeoJSON Feature</a> describing the
actual route between the various attractions in that city.
Each result also includes a <code class="literal">properties</code> object with a <code class="literal">complete</code> value which will be false if the geometry
was simplified to the limits specified in the <code class="literal">size</code> parameter.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-metrics-geo-line-grouping-time-series-advantages"></a>Why group with time-series?<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/geoline-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>When reviewing these examples, you might think that there is little difference between using
<a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation" title="Terms aggregation"><code class="literal">terms</code></a> or
<a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-time-series-aggregation" title="Time series aggregation"><code class="literal">time_series</code></a>
to group the geo-lines. However, there are some important differences in behaviour between the two cases.
Time series indexes are stored in a very specific order on disk.
They are pre-grouped by the time-series dimension fields, and pre-sorted by the <code class="literal">@timestamp</code> field.
This allows the <code class="literal">geo_line</code> aggregation to be considerably optimized:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
The same memory allocated for the first bucket can be re-used over and over for all subsequent buckets.
This is substantially less memory than required for non-time-series cases where all buckets are collected
concurrently.
</li>
<li class="listitem">
No sorting needs to be done, since the data is pre-sorted by <code class="literal">@timestamp</code>.
The time-series data will naturally arrive at the aggregation collector in <code class="literal">DESC</code> order.
This means that if we specify <code class="literal">sort_order:ASC</code> (the default), we still collect in <code class="literal">DESC</code> order,
but perform an efficient in-memory reverse order before generating the final <code class="literal">LineString</code> geometry.
</li>
<li class="listitem">
The <code class="literal">size</code> parameter can be used for a streaming line-simplification algorithm.
Without time-series, we are forced to truncate data, by default after 10000 documents per bucket, in order to
prevent memory usage from being unbounded.
This can result in geo-lines being truncated, and therefor loosing important data.
With time-series we can run a streaming line-simplification algorithm, retaining control over memory usage,
while also maintaining the overall geometry shape.
In fact, for most use cases it would work to set this <code class="literal">size</code> parameter to a much lower bound, and save even more
memory. For example, if the <code class="literal">geo_line</code> is to be drawn on a display map with a specific resolution, it might look
just as good to simplify to as few as 100 or 200 points. This will save memory on the server, on the network and
in the client.
</li>
</ul>
</div>
<p>Note: There are other significant advantages to working with time-series data and using <code class="literal">time_series</code> index mode.
These are discussed in the documentation on <a class="xref" href="tsds.html" title="Time series data stream (TSDS)">time series data streams</a>.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-metrics-geo-line-simplification"></a>Streaming line simplification<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/geoline-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Line simplification is a great way to reduce the size of the final results sent to the client, and displayed in a map
user interface. However, normally these algorithms use a lot of memory to perform the simplification, requiring the
entire geometry to be maintained in memory together with supporting data for the simplification itself.
The use of a streaming line simplification algorithm allows for minimal memory usage during the simplification
process by constraining memory to the bounds defined for the simplified geometry. This is only possible if no sorting
is required, which is the case when grouping is done by the
<a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-time-series-aggregation" title="Time series aggregation"><code class="literal">time_series</code> aggregation</a>,
running on an index with the <code class="literal">time_series</code> index mode.</p>
<p>Under these conditions the <code class="literal">geo_line</code> aggregation allocates memory to the <code class="literal">size</code> specified, and then fills that
memory with the incoming documents.
Once the memory is completely filled, documents from within the line are removed as new documents are added.
The choice of document to remove is made to minimize the visual impact on the geometry.
This process makes use of the
<a href="https://en.wikipedia.org/wiki/Visvalingam%E2%80%93Whyatt_algorithm" class="ulink" target="_top">Visvalingam–Whyatt algorithm</a>.
Essentially this means points are removed if they have the minimum triangle area, with the triangle defined
by the point under consideration and the two points before and after it in the line.
In addition, we calculate the area using spherical coordinates so that no planar distortions affect the choice.</p>
<p>In order to demonstrate how much better line simplification is to line truncation, consider this example of the north
shore of Kodiak Island.
The data for this is only 209 points, but if we want to set <code class="literal">size</code> to <code class="literal">100</code> we get dramatic truncation.</p>
<p><span class="image"><img src="images/spatial/kodiak_geo_line_truncated.png" alt="North short of Kodiak Island truncated to 100 points"></span></p>
<p>The grey line is the entire geometry of 209 points, while the blue line is the first 100 points, a very different
geometry than the original.</p>
<p>Now consider the same geometry simplified to 100 points.</p>
<p><span class="image"><img src="images/spatial/kodiak_geo_line_simplified.png" alt="North short of Kodiak Island simplified to 100 points"></span></p>
<p>For comparison we have shown the original in grey, the truncated in blue and the new simplified geometry
in magenta. It is possible to see where the new simplified line deviates from the original, but the overall
geometry appears almost identical and is still clearly recognizable as the north shore of Kodiak Island.</p>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-metrics-cartesian-bounds-aggregation"></a>Cartesian-bounds aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/cartesian-bounds-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A metric aggregation that computes the spatial bounding box containing all values for a <a class="xref" href="mapping-types.html#point" title="Point field type">Point</a> or <a class="xref" href="mapping-types.html#shape" title="Shape field type">Shape</a> field.</p>
<p>Example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /museums
{
  "mappings": {
    "properties": {
      "location": {
        "type": "point"
      }
    }
  }
}

POST /museums/_bulk?refresh
{"index":{"_id":1}}
{"location": "POINT (491.2350 5237.4081)", "city": "Amsterdam", "name": "NEMO Science Museum"}
{"index":{"_id":2}}
{"location": "POINT (490.1618 5236.9219)", "city": "Amsterdam", "name": "Museum Het Rembrandthuis"}
{"index":{"_id":3}}
{"location": "POINT (491.4722 5237.1667)", "city": "Amsterdam", "name": "Nederlands Scheepvaartmuseum"}
{"index":{"_id":4}}
{"location": "POINT (440.5200 5122.2900)", "city": "Antwerp", "name": "Letterenhuis"}
{"index":{"_id":5}}
{"location": "POINT (233.6389 4886.1111)", "city": "Paris", "name": "Musée du Louvre"}
{"index":{"_id":6}}
{"location": "POINT (232.7000 4886.0000)", "city": "Paris", "name": "Musée d'Orsay"}

POST /museums/_search?size=0
{
  "query": {
    "match": { "name": "musée" }
  },
  "aggs": {
    "viewport": {
      "cartesian_bounds": {
        "field": "location"    <a id="CO307-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1377.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO307-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">cartesian_bounds</code> aggregation specifies the field to use to obtain the bounds, which must be a <a class="xref" href="mapping-types.html#point" title="Point field type">Point</a> or a <a class="xref" href="mapping-types.html#shape" title="Shape field type">Shape</a> type.</p>
</td>
</tr>
</table>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>Unlike the case with the <a class="xref" href="search-aggregations-metrics.html#geobounds-aggregation-geo-shape" title="Geo Bounds Aggregation on geo_shape fields"><code class="literal">geo_bounds</code></a> aggregation,
there is no option to set <a class="xref" href="search-aggregations-metrics.html#geo-bounds-wrap-longitude"><code class="literal">wrap_longitude</code></a>.
This is because the cartesian space is euclidean and does not wrap back on itself.
So the bounds will always have a minimum x value less than or equal to the maximum x value.</p>
</div>
</div>
<p>The above aggregation demonstrates how one would compute the bounding box of the location field for all documents with a name matching "musée".</p>
<p>The response for the above aggregation:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "viewport": {
      "bounds": {
        "top_left": {
          "x": 232.6999969482422,
          "y": 4886.111328125
        },
        "bottom_right": {
          "x": 233.63890075683594,
          "y": 4886.0
        }
      }
    }
  }
}</pre>
</div>
<h4 class="xpack"><a id="cartesian-bounds-aggregation-shape"></a>Cartesian Bounds Aggregation on <code class="literal">shape</code> fields<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/cartesian-bounds-aggregation.asciidoc">edit</a></h4>
<p>The Cartesian Bounds Aggregation is also supported on <code class="literal">cartesian_shape</code> fields.</p>
<p>Example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /places
{
  "mappings": {
    "properties": {
      "geometry": {
        "type": "shape"
      }
    }
  }
}

POST /places/_bulk?refresh
{"index":{"_id":1}}
{"name": "NEMO Science Museum", "geometry": "POINT(491.2350 5237.4081)" }
{"index":{"_id":2}}
{"name": "Sportpark De Weeren", "geometry": { "type": "Polygon", "coordinates": [ [ [ 496.5305328369141, 5239.347642069457 ], [ 496.6979026794433, 5239.1721758934835 ], [ 496.9425201416015, 5239.238958618537 ], [ 496.7944622039794, 5239.420969150824 ], [ 496.5305328369141, 5239.347642069457 ] ] ] } }

POST /places/_search?size=0
{
  "aggs": {
    "viewport": {
      "cartesian_bounds": {
        "field": "geometry"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1378.console"></div>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "viewport": {
      "bounds": {
        "top_left": {
          "x": 491.2349853515625,
          "y": 5239.4208984375
        },
        "bottom_right": {
          "x": 496.9425048828125,
          "y": 5237.408203125
        }
      }
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-metrics-cartesian-centroid-aggregation"></a>Cartesian-centroid aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/cartesian-centroid-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A metric aggregation that computes the weighted <a href="https://en.wikipedia.org/wiki/Centroid" class="ulink" target="_top">centroid</a> from all coordinate values for point and shape fields.</p>
<p>Example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /museums
{
  "mappings": {
    "properties": {
      "location": {
        "type": "point"
      }
    }
  }
}

POST /museums/_bulk?refresh
{"index":{"_id":1}}
{"location": "POINT (491.2350 5237.4081)", "city": "Amsterdam", "name": "NEMO Science Museum"}
{"index":{"_id":2}}
{"location": "POINT (490.1618 5236.9219)", "city": "Amsterdam", "name": "Museum Het Rembrandthuis"}
{"index":{"_id":3}}
{"location": "POINT (491.4722 5237.1667)", "city": "Amsterdam", "name": "Nederlands Scheepvaartmuseum"}
{"index":{"_id":4}}
{"location": "POINT (440.5200 5122.2900)", "city": "Antwerp", "name": "Letterenhuis"}
{"index":{"_id":5}}
{"location": "POINT (233.6389 4886.1111)", "city": "Paris", "name": "Musée du Louvre"}
{"index":{"_id":6}}
{"location": "POINT (232.7000 4886.0000)", "city": "Paris", "name": "Musée d'Orsay"}

POST /museums/_search?size=0
{
  "aggs": {
    "centroid": {
      "cartesian_centroid": {
        "field": "location" <a id="CO308-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1379.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO308-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">cartesian_centroid</code> aggregation specifies the field to use for computing the centroid, which must be a <a class="xref" href="mapping-types.html#point" title="Point field type">Point</a> or a <a class="xref" href="mapping-types.html#shape" title="Shape field type">Shape</a> type.</p>
</td>
</tr>
</table>
</div>
<p>The above aggregation demonstrates how one would compute the centroid of the location field for all museums' documents.</p>
<p>The response for the above aggregation:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "centroid": {
      "location": {
        "x": 396.6213124593099,
        "y": 5100.982991536458
      },
      "count": 6
    }
  }
}</pre>
</div>
<p>The <code class="literal">cartesian_centroid</code> aggregation is more interesting when combined as a sub-aggregation to other bucket aggregations.</p>
<p>Example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /museums/_search?size=0
{
  "aggs": {
    "cities": {
      "terms": { "field": "city.keyword" },
      "aggs": {
        "centroid": {
          "cartesian_centroid": { "field": "location" }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1380.console"></div>
<p>The above example uses <code class="literal">cartesian_centroid</code> as a sub-aggregation to a
<a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation" title="Terms aggregation">terms</a> bucket aggregation for finding the central location for museums in each city.</p>
<p>The response for the above aggregation:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "cities": {
      "sum_other_doc_count": 0,
      "doc_count_error_upper_bound": 0,
      "buckets": [
        {
          "key": "Amsterdam",
          "doc_count": 3,
          "centroid": {
            "location": {
              "x": 490.9563293457031,
              "y": 5237.16552734375
            },
            "count": 3
          }
        },
        {
          "key": "Paris",
          "doc_count": 2,
          "centroid": {
            "location": {
              "x": 233.16944885253906,
              "y": 4886.0556640625
            },
            "count": 2
          }
        },
        {
          "key": "Antwerp",
          "doc_count": 1,
          "centroid": {
            "location": {
              "x": 440.5199890136719,
              "y": 5122.2900390625
            },
            "count": 1
          }
        }
      ]
    }
  }
}</pre>
</div>
<h4 class="xpack"><a id="cartesian-centroid-aggregation-geo-shape"></a>Cartesian Centroid Aggregation on <code class="literal">shape</code> fields<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/cartesian-centroid-aggregation.asciidoc">edit</a></h4>
<p>The centroid metric for shapes is more nuanced than for points.
The centroid of a specific aggregation bucket containing shapes is the centroid of the highest-dimensionality shape type in the bucket.
For example, if a bucket contains shapes consisting of polygons and lines, then the lines do not contribute to the centroid metric.
Each type of shape&#8217;s centroid is calculated differently.
Envelopes and circles ingested via the <a class="xref" href="processors.html#ingest-circle-processor" title="Circle processor">Circle</a> are treated as polygons.</p>
<div class="informaltable">
<table border="1" cellpadding="4px">
<colgroup>
<col class="col_1"/>
<col class="col_2"/>
</colgroup>
<thead>
<tr>
<th align="left" valign="top">Geometry Type</th>
<th align="left" valign="top">Centroid Calculation</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p>[Multi]Point</p></td>
<td align="left" valign="top"><p>equally weighted average of all the coordinates</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>[Multi]LineString</p></td>
<td align="left" valign="top"><p>a weighted average of all the centroids of each segment, where the weight of each segment is its length in the same units as the coordinates</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>[Multi]Polygon</p></td>
<td align="left" valign="top"><p>a weighted average of all the centroids of all the triangles of a polygon where the triangles are formed by every two consecutive vertices and the starting-point.
holes have negative weights. weights represent the area of the triangle is calculated in the square of the units of the coordinates</p></td>
</tr>
<tr>
<td align="left" valign="top"><p>GeometryCollection</p></td>
<td align="left" valign="top"><p>The centroid of all the underlying geometries with the highest dimension. If Polygons and Lines and/or Points, then lines and/or points are ignored.
If Lines and Points, then points are ignored</p></td>
</tr>
</tbody>
</table>
</div>
<p>Example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /places
{
  "mappings": {
    "properties": {
      "geometry": {
        "type": "shape"
      }
    }
  }
}

POST /places/_bulk?refresh
{"index":{"_id":1}}
{"name": "NEMO Science Museum", "geometry": "POINT(491.2350 5237.4081)" }
{"index":{"_id":2}}
{"name": "Sportpark De Weeren", "geometry": { "type": "Polygon", "coordinates": [ [ [ 496.5305328369141, 5239.347642069457 ], [ 496.6979026794433, 5239.1721758934835 ], [ 496.9425201416015, 5239.238958618537 ], [ 496.7944622039794, 5239.420969150824 ], [ 496.5305328369141, 5239.347642069457 ] ] ] } }

POST /places/_search?size=0
{
  "aggs": {
    "centroid": {
      "cartesian_centroid": {
        "field": "geometry"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1381.console"></div>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "centroid": {
      "location": {
        "x": 496.74041748046875,
        "y": 5239.29638671875
      },
      "count": 2
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-matrix-stats-aggregation"></a>Matrix stats aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/matrix-stats-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>The <code class="literal">matrix_stats</code> aggregation is a numeric aggregation that computes the following statistics over a set of document fields:</p>
<div class="informaltable">
<table border="0" cellpadding="4px">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody valign="top">
<tr>
<td valign="top">
<p>
<code class="literal">count</code>
</p>
</td>
<td valign="top">
<p>
Number of per field samples included in the calculation.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">mean</code>
</p>
</td>
<td valign="top">
<p>
The average value for each field.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">variance</code>
</p>
</td>
<td valign="top">
<p>
Per field Measurement for how spread out the samples are from the mean.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">skewness</code>
</p>
</td>
<td valign="top">
<p>
Per field measurement quantifying the asymmetric distribution around the mean.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">kurtosis</code>
</p>
</td>
<td valign="top">
<p>
Per field measurement quantifying the shape of the distribution.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">covariance</code>
</p>
</td>
<td valign="top">
<p>
A matrix that quantitatively describes how changes in one field are associated with another.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">correlation</code>
</p>
</td>
<td valign="top">
<p>
The covariance matrix scaled to a range of -1 to 1, inclusive. Describes the relationship between field
distributions.
</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="important admon">
<div class="icon"></div>
<div class="admon_content">
<p>Unlike other metric aggregations, the <code class="literal">matrix_stats</code> aggregation does
not support scripting.</p>
</div>
</div>
<p>The following example demonstrates the use of matrix stats to describe the relationship between income and poverty.</p>
<a id="stats-aggregation-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "statistics": {
      "matrix_stats": {
        "fields": [ "poverty", "income" ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1382.console"></div>
<p>The aggregation type is <code class="literal">matrix_stats</code> and the <code class="literal">fields</code> setting defines the set of fields (as an array) for computing
the statistics. The above request returns the following response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "statistics": {
      "doc_count": 50,
      "fields": [ {
          "name": "income",
          "count": 50,
          "mean": 51985.1,
          "variance": 7.383377037755103E7,
          "skewness": 0.5595114003506483,
          "kurtosis": 2.5692365287787124,
          "covariance": {
            "income": 7.383377037755103E7,
            "poverty": -21093.65836734694
          },
          "correlation": {
            "income": 1.0,
            "poverty": -0.8352655256272504
          }
        }, {
          "name": "poverty",
          "count": 50,
          "mean": 12.732000000000001,
          "variance": 8.637730612244896,
          "skewness": 0.4516049811903419,
          "kurtosis": 2.8615929677997767,
          "covariance": {
            "income": -21093.65836734694,
            "poverty": 8.637730612244896
          },
          "correlation": {
            "income": -0.8352655256272504,
            "poverty": 1.0
          }
        } ]
    }
  }
}</pre>
</div>
<p>The <code class="literal">doc_count</code> field indicates the number of documents involved in the computation of the statistics.</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_multi_value_fields"></a>Multi Value Fields<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/matrix-stats-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">matrix_stats</code> aggregation treats each document field as an independent sample. The <code class="literal">mode</code> parameter controls what
array value the aggregation will use for array or multi-valued fields. This parameter can take one of the following:</p>
<div class="informaltable">
<table border="0" cellpadding="4px">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody valign="top">
<tr>
<td valign="top">
<p>
<code class="literal">avg</code>
</p>
</td>
<td valign="top">
<p>
(default) Use the average of all values.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">min</code>
</p>
</td>
<td valign="top">
<p>
Pick the lowest value.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">max</code>
</p>
</td>
<td valign="top">
<p>
Pick the highest value.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">sum</code>
</p>
</td>
<td valign="top">
<p>
Use the sum of all values.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">median</code>
</p>
</td>
<td valign="top">
<p>
Use the median of all values.
</p>
</td>
</tr>
</tbody>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_missing_values_3"></a>Missing Values<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/matrix-stats-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">missing</code> parameter defines how documents that are missing a value should be treated.
By default they will be ignored but it is also possible to treat them as if they had a value.
This is done by adding a set of fieldname : value mappings to specify default values per field.</p>
<a id="stats-aggregation-missing-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "aggs": {
    "matrixstats": {
      "matrix_stats": {
        "fields": [ "poverty", "income" ],
        "missing": { "income": 50000 }      <a id="CO309-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1383.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO309-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Documents without a value in the <code class="literal">income</code> field will have the default value <code class="literal">50000</code>.</p>
</td>
</tr>
</table>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-metrics-max-aggregation"></a>Max aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/max-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A <code class="literal">single-value</code> metrics aggregation that keeps track and returns the maximum
value among the numeric values extracted from the aggregated documents.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>The <code class="literal">min</code> and <code class="literal">max</code> aggregation operate on the <code class="literal">double</code> representation of
the data. As a consequence, the result may be approximate when running on longs
whose absolute value is greater than <code class="literal">2^53</code>.</p>
</div>
</div>
<p>Computing the max price value across all documents</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "max_price": { "max": { "field": "price" } }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1384.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
      "max_price": {
          "value": 200.0
      }
  }
}</pre>
</div>
<p>As can be seen, the name of the aggregation (<code class="literal">max_price</code> above) also serves as
the key by which the aggregation result can be retrieved from the returned
response.</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_script_6"></a>Script<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/max-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>If you need to get the <code class="literal">max</code> of something more complex than a single field,
run an aggregation on a <a class="xref" href="runtime.html" title="Runtime fields">runtime field</a>.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search
{
  "size": 0,
  "runtime_mappings": {
    "price.adjusted": {
      "type": "double",
      "script": """
        double price = doc['price'].value;
        if (doc['promoted'].value) {
          price *= 0.8;
        }
        emit(price);
      """
    }
  },
  "aggs": {
    "max_price": {
      "max": { "field": "price.adjusted" }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1385.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_missing_value_10"></a>Missing value<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/max-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">missing</code> parameter defines how documents that are missing a value should
be treated. By default they will be ignored but it is also possible to treat
them as if they had a value.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search
{
  "aggs" : {
      "grade_max" : {
          "max" : {
              "field" : "grade",
              "missing": 10       <a id="CO310-1"></a><i class="conum" data-value="1"></i>
          }
      }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1386.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO310-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Documents without a value in the <code class="literal">grade</code> field will fall into the same
bucket as documents that have the value <code class="literal">10</code>.</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-metrics-max-aggregation-histogram-fields"></a>Histogram fields<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/max-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>When <code class="literal">max</code> is computed on <a class="xref" href="mapping-types.html#histogram" title="Histogram field type">histogram fields</a>, the result of the aggregation is the maximum
of all elements in the <code class="literal">values</code> array. Note, that the <code class="literal">counts</code> array of the histogram is ignored.</p>
<p>For example, for the following index that stores pre-aggregated histograms with latency metrics for different networks:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT metrics_index
{
  "mappings": {
    "properties": {
      "latency_histo": { "type": "histogram" }
    }
  }
}

PUT metrics_index/_doc/1?refresh
{
  "network.name" : "net-1",
  "latency_histo" : {
      "values" : [0.1, 0.2, 0.3, 0.4, 0.5],
      "counts" : [3, 7, 23, 12, 6]
   }
}

PUT metrics_index/_doc/2?refresh
{
  "network.name" : "net-2",
  "latency_histo" : {
      "values" :  [0.1, 0.2, 0.3, 0.4, 0.5],
      "counts" : [8, 17, 8, 7, 6]
   }
}

POST /metrics_index/_search?size=0&amp;filter_path=aggregations
{
  "aggs" : {
    "max_latency" : { "max" : { "field" : "latency_histo" } }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1387.console"></div>
<p>The <code class="literal">max</code> aggregation will return the maximum value of all histogram fields:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "aggregations": {
    "max_latency": {
      "value": 0.5
    }
  }
}</pre>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-metrics-median-absolute-deviation-aggregation"></a>Median absolute deviation aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/median-absolute-deviation-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>This <code class="literal">single-value</code> aggregation approximates the <a href="https://en.wikipedia.org/wiki/Median_absolute_deviation" class="ulink" target="_top">median absolute deviation</a>
of its search results.</p>
<p>Median absolute deviation is a measure of variability. It is a robust
statistic, meaning that it is useful for describing data that may have
outliers, or may not be normally distributed. For such data it can be more
descriptive than standard deviation.</p>
<p>It is calculated as the median of each data point&#8217;s deviation from the median
of the entire sample. That is, for a random variable X, the median absolute
deviation is median(|median(X) - X<sub>i</sub>|).</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_example_5"></a>Example<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/median-absolute-deviation-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Assume our data represents product reviews on a one to five star scale.
Such reviews are usually summarized as a mean, which is easily understandable
but doesn&#8217;t describe the reviews' variability. Estimating the median absolute
deviation can provide insight into how much reviews vary from one another.</p>
<p>In this example we have a product which has an average rating of
3 stars. Let&#8217;s look at its ratings' median absolute deviation to determine
how much they vary</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET reviews/_search
{
  "size": 0,
  "aggs": {
    "review_average": {
      "avg": {
        "field": "rating"
      }
    },
    "review_variability": {
      "median_absolute_deviation": {
        "field": "rating" <a id="CO311-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1388.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO311-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p><code class="literal">rating</code> must be a numeric field</p>
</td>
</tr>
</table>
</div>
<p>The resulting median absolute deviation of <code class="literal">2</code> tells us that there is a fair
amount of variability in the ratings. Reviewers must have diverse opinions about
this product.</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "review_average": {
      "value": 3.0
    },
    "review_variability": {
      "value": 2.0
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_approximation"></a>Approximation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/median-absolute-deviation-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The naive implementation of calculating median absolute deviation stores the
entire sample in memory, so this aggregation instead calculates an
approximation. It uses the <a href="https://github.com/tdunning/t-digest" class="ulink" target="_top">TDigest data structure</a>
to approximate the sample median and the median of deviations from the sample
median. For more about the approximation characteristics of TDigests, see
<a class="xref" href="search-aggregations-metrics.html#search-aggregations-metrics-percentile-aggregation-approximation" title="Percentiles are (usually) approximate">Percentiles are (usually) approximate</a>.</p>
<p>The tradeoff between resource usage and accuracy of a TDigest&#8217;s quantile
approximation, and therefore the accuracy of this aggregation&#8217;s approximation
of median absolute deviation, is controlled by the <code class="literal">compression</code> parameter. A
higher <code class="literal">compression</code> setting provides a more accurate approximation at the
cost of higher memory usage. For more about the characteristics of the TDigest
<code class="literal">compression</code> parameter see
<a class="xref" href="search-aggregations-metrics.html#search-aggregations-metrics-percentile-aggregation-compression" title="Compression">Compression</a>.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET reviews/_search
{
  "size": 0,
  "aggs": {
    "review_variability": {
      "median_absolute_deviation": {
        "field": "rating",
        "compression": 100
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1389.console"></div>
<p>The default <code class="literal">compression</code> value for this aggregation is <code class="literal">1000</code>. At this
compression level this aggregation is usually within 5% of the exact result,
but observed performance will depend on the sample data.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_script_7"></a>Script<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/median-absolute-deviation-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>In the example above, product reviews are on a scale of one to five. If you
want to modify them to a scale of one to ten, use a <a class="xref" href="runtime.html" title="Runtime fields">runtime field</a>.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET reviews/_search?filter_path=aggregations
{
  "size": 0,
  "runtime_mappings": {
    "rating.out_of_ten": {
      "type": "long",
      "script": {
        "source": "emit(doc['rating'].value * params.scaleFactor)",
        "params": {
          "scaleFactor": 2
        }
      }
    }
  },
  "aggs": {
    "review_average": {
      "avg": {
        "field": "rating.out_of_ten"
      }
    },
    "review_variability": {
      "median_absolute_deviation": {
        "field": "rating.out_of_ten"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1390.console"></div>
<p>Which will result in:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "aggregations": {
    "review_average": {
      "value": 6.0
    },
    "review_variability": {
      "value": 4.0
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_missing_value_11"></a>Missing value<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/median-absolute-deviation-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">missing</code> parameter defines how documents that are missing a value should be
treated. By default they will be ignored but it is also possible to treat them
as if they had a value.</p>
<p>Let&#8217;s be optimistic and assume some reviewers loved the product so much that
they forgot to give it a rating. We&#8217;ll assign them five stars</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET reviews/_search
{
  "size": 0,
  "aggs": {
    "review_variability": {
      "median_absolute_deviation": {
        "field": "rating",
        "missing": 5
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1391.console"></div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-metrics-min-aggregation"></a>Min aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/min-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A <code class="literal">single-value</code> metrics aggregation that keeps track and returns the minimum
value among numeric values extracted from the aggregated documents.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>The <code class="literal">min</code> and <code class="literal">max</code> aggregation operate on the <code class="literal">double</code> representation of
the data. As a consequence, the result may be approximate when running on longs
whose absolute value is greater than <code class="literal">2^53</code>.</p>
</div>
</div>
<p>Computing the min price value across all documents:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "min_price": { "min": { "field": "price" } }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1392.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...

  "aggregations": {
    "min_price": {
      "value": 10.0
    }
  }
}</pre>
</div>
<p>As can be seen, the name of the aggregation (<code class="literal">min_price</code> above) also serves as
the key by which the aggregation result can be retrieved from the returned
response.</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_script_8"></a>Script<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/min-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>If you need to get the <code class="literal">min</code> of something more complex than a single field,
run the aggregation on a <a class="xref" href="runtime.html" title="Runtime fields">runtime field</a>.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search
{
  "size": 0,
  "runtime_mappings": {
    "price.adjusted": {
      "type": "double",
      "script": """
        double price = doc['price'].value;
        if (doc['promoted'].value) {
          price *= 0.8;
        }
        emit(price);
      """
    }
  },
  "aggs": {
    "min_price": {
      "min": { "field": "price.adjusted" }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1393.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_missing_value_12"></a>Missing value<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/min-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">missing</code> parameter defines how documents that are missing a value should
be treated. By default they will be ignored but it is also possible to treat
them as if they had a value.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search
{
  "aggs": {
    "grade_min": {
      "min": {
        "field": "grade",
        "missing": 10 <a id="CO312-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1394.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO312-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Documents without a value in the <code class="literal">grade</code> field will fall into the same
bucket as documents that have the value <code class="literal">10</code>.</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-metrics-min-aggregation-histogram-fields"></a>Histogram fields<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/min-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>When <code class="literal">min</code> is computed on <a class="xref" href="mapping-types.html#histogram" title="Histogram field type">histogram fields</a>, the result of the aggregation is the minimum
of all elements in the <code class="literal">values</code> array. Note, that the <code class="literal">counts</code> array of the histogram is ignored.</p>
<p>For example, for the following index that stores pre-aggregated histograms with latency metrics for different networks:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT metrics_index
{
  "mappings": {
    "properties": {
      "latency_histo": { "type": "histogram" }
    }
  }
}

PUT metrics_index/_doc/1?refresh
{
  "network.name" : "net-1",
  "latency_histo" : {
      "values" : [0.1, 0.2, 0.3, 0.4, 0.5],
      "counts" : [3, 7, 23, 12, 6]
   }
}

PUT metrics_index/_doc/2?refresh
{
  "network.name" : "net-2",
  "latency_histo" : {
      "values" :  [0.1, 0.2, 0.3, 0.4, 0.5],
      "counts" : [8, 17, 8, 7, 6]
   }
}

POST /metrics_index/_search?size=0&amp;filter_path=aggregations
{
  "aggs" : {
    "min_latency" : { "min" : { "field" : "latency_histo" } }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1395.console"></div>
<p>The <code class="literal">min</code> aggregation will return the minimum value of all histogram fields:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "aggregations": {
    "min_latency": {
      "value": 0.1
    }
  }
}</pre>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-metrics-percentile-rank-aggregation"></a>Percentile ranks aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/percentile-rank-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A <code class="literal">multi-value</code> metrics aggregation that calculates one or more percentile ranks
over numeric values extracted from the aggregated documents. These values can be
extracted from specific numeric or <a class="xref" href="mapping-types.html#histogram" title="Histogram field type">histogram fields</a> in the documents.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>Please see <a class="xref" href="search-aggregations-metrics.html#search-aggregations-metrics-percentile-aggregation-approximation" title="Percentiles are (usually) approximate">Percentiles are (usually) approximate</a>,
<a class="xref" href="search-aggregations-metrics.html#search-aggregations-metrics-percentile-aggregation-compression" title="Compression">Compression</a> and
<a class="xref" href="search-aggregations-metrics.html#search-aggregations-metrics-percentile-aggregation-execution-hint" title="Execution hint">Execution hint</a> for advice
regarding approximation, performance and memory use of the percentile ranks aggregation</p>
</div>
</div>
<p>Percentile rank show the percentage of observed values which are below certain
value. For example, if a value is greater than or equal to 95% of the observed values
it is said to be at the 95th percentile rank.</p>
<p>Assume your data consists of website load times. You may have a service agreement that
95% of page loads complete within 500ms and 99% of page loads complete within 600ms.</p>
<p>Let&#8217;s look at a range of percentiles representing load time:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET latency/_search
{
  "size": 0,
  "aggs": {
    "load_time_ranks": {
      "percentile_ranks": {
        "field": "load_time",   <a id="CO313-1"></a><i class="conum" data-value="1"></i>
        "values": [ 500, 600 ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1396.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO313-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The field <code class="literal">load_time</code> must be a numeric field</p>
</td>
</tr>
</table>
</div>
<p>The response will look like this:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...

 "aggregations": {
    "load_time_ranks": {
      "values": {
        "500.0": 55.0,
        "600.0": 64.0
      }
    }
  }
}</pre>
</div>
<p>From this information you can determine you are hitting the 99% load time target but not quite
hitting the 95% load time target</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_keyed_response_5"></a>Keyed Response<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/percentile-rank-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>By default the <code class="literal">keyed</code> flag is set to <code class="literal">true</code> associates a unique string key with each bucket and returns the ranges as a hash rather than an array. Setting the <code class="literal">keyed</code> flag to <code class="literal">false</code> will disable this behavior:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET latency/_search
{
  "size": 0,
  "aggs": {
    "load_time_ranks": {
      "percentile_ranks": {
        "field": "load_time",
        "values": [ 500, 600 ],
        "keyed": false
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1397.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...

  "aggregations": {
    "load_time_ranks": {
      "values": [
        {
          "key": 500.0,
          "value": 55.0
        },
        {
          "key": 600.0,
          "value": 64.0
        }
      ]
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_script_9"></a>Script<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/percentile-rank-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>If you need to run the aggregation against values that aren&#8217;t indexed, use
a <a class="xref" href="runtime.html" title="Runtime fields">runtime field</a>. For example, if our load times
are in milliseconds but we want percentiles calculated in seconds:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET latency/_search
{
  "size": 0,
  "runtime_mappings": {
    "load_time.seconds": {
      "type": "long",
      "script": {
        "source": "emit(doc['load_time'].value / params.timeUnit)",
        "params": {
          "timeUnit": 1000
        }
      }
    }
  },
  "aggs": {
    "load_time_ranks": {
      "percentile_ranks": {
        "values": [ 500, 600 ],
        "field": "load_time.seconds"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1398.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_hdr_histogram"></a>HDR Histogram<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/percentile-rank-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p><a href="https://github.com/HdrHistogram/HdrHistogram" class="ulink" target="_top">HDR Histogram</a> (High Dynamic Range Histogram) is an alternative implementation
that can be useful when calculating percentile ranks for latency measurements as it can be faster than the t-digest implementation
with the trade-off of a larger memory footprint. This implementation maintains a fixed worse-case percentage error (specified as a
number of significant digits). This means that if data is recorded with values from 1 microsecond up to 1 hour (3,600,000,000
microseconds) in a histogram set to 3 significant digits, it will maintain a value resolution of 1 microsecond for values up to
1 millisecond and 3.6 seconds (or better) for the maximum tracked value (1 hour).</p>
<p>The HDR Histogram can be used by specifying the <code class="literal">hdr</code> object in the request:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET latency/_search
{
  "size": 0,
  "aggs": {
    "load_time_ranks": {
      "percentile_ranks": {
        "field": "load_time",
        "values": [ 500, 600 ],
        "hdr": {                                  <a id="CO314-1"></a><i class="conum" data-value="1"></i>
          "number_of_significant_value_digits": 3 <a id="CO314-2"></a><i class="conum" data-value="2"></i>
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1399.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO314-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p><code class="literal">hdr</code> object indicates that HDR Histogram should be used to calculate the percentiles and specific settings for this algorithm can be specified inside the object</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO314-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p><code class="literal">number_of_significant_value_digits</code> specifies the resolution of values for the histogram in number of significant digits</p>
</td>
</tr>
</table>
</div>
<p>The HDRHistogram only supports positive values and will error if it is passed a negative value. It is also not a good idea to use
the HDRHistogram if the range of values is unknown as this could lead to high memory usage.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_missing_value_13"></a>Missing value<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/percentile-rank-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">missing</code> parameter defines how documents that are missing a value should be treated.
By default they will be ignored but it is also possible to treat them as if they
had a value.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET latency/_search
{
  "size": 0,
  "aggs": {
    "load_time_ranks": {
      "percentile_ranks": {
        "field": "load_time",
        "values": [ 500, 600 ],
        "missing": 10           <a id="CO315-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1400.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO315-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Documents without a value in the <code class="literal">load_time</code> field will fall into the same bucket as documents that have the value <code class="literal">10</code>.</p>
</td>
</tr>
</table>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-metrics-percentile-aggregation"></a>Percentiles aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/percentile-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A <code class="literal">multi-value</code> metrics aggregation that calculates one or more percentiles
over numeric values extracted from the aggregated documents. These values can be
extracted from specific numeric or <a class="xref" href="mapping-types.html#histogram" title="Histogram field type">histogram fields</a> in the documents.</p>
<p>Percentiles show the point at which a certain percentage of observed values
occur. For example, the 95th percentile is the value which is greater than 95%
of the observed values.</p>
<p>Percentiles are often used to find outliers. In normal distributions, the
0.13th and 99.87th percentiles represents three standard deviations from the
mean. Any data which falls outside three standard deviations is often considered
an anomaly.</p>
<p>When a range of percentiles are retrieved, they can be used to estimate the
data distribution and determine if the data is skewed, bimodal, etc.</p>
<p>Assume your data consists of website load times. The average and median
load times are not overly useful to an administrator. The max may be interesting,
but it can be easily skewed by a single slow response.</p>
<p>Let&#8217;s look at a range of percentiles representing load time:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET latency/_search
{
  "size": 0,
  "aggs": {
    "load_time_outlier": {
      "percentiles": {
        "field": "load_time" <a id="CO316-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1401.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO316-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The field <code class="literal">load_time</code> must be a numeric field</p>
</td>
</tr>
</table>
</div>
<p>By default, the <code class="literal">percentile</code> metric will generate a range of
percentiles: <code class="literal">[ 1, 5, 25, 50, 75, 95, 99 ]</code>. The response will look like this:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...

 "aggregations": {
    "load_time_outlier": {
      "values": {
        "1.0": 10.0,
        "5.0": 30.0,
        "25.0": 170.0,
        "50.0": 445.0,
        "75.0": 720.0,
        "95.0": 940.0,
        "99.0": 980.0
      }
    }
  }
}</pre>
</div>
<p>As you can see, the aggregation will return a calculated value for each percentile
in the default range. If we assume response times are in milliseconds, it is
immediately obvious that the webpage normally loads in 10-725ms, but occasionally
spikes to 945-985ms.</p>
<p>Often, administrators are only interested in outliers&#8201;&#8212;&#8201;the extreme percentiles.
We can specify just the percents we are interested in (requested percentiles
must be a value between 0-100 inclusive):</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET latency/_search
{
  "size": 0,
  "aggs": {
    "load_time_outlier": {
      "percentiles": {
        "field": "load_time",
        "percents": [ 95, 99, 99.9 ] <a id="CO317-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1402.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO317-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Use the <code class="literal">percents</code> parameter to specify particular percentiles to calculate</p>
</td>
</tr>
</table>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_keyed_response_6"></a>Keyed Response<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/percentile-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>By default the <code class="literal">keyed</code> flag is set to <code class="literal">true</code> which associates a unique string key with each bucket and returns the ranges as a hash rather than an array. Setting the <code class="literal">keyed</code> flag to <code class="literal">false</code> will disable this behavior:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET latency/_search
{
  "size": 0,
  "aggs": {
    "load_time_outlier": {
      "percentiles": {
        "field": "load_time",
        "keyed": false
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1403.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...

  "aggregations": {
    "load_time_outlier": {
      "values": [
        {
          "key": 1.0,
          "value": 10.0
        },
        {
          "key": 5.0,
          "value": 30.0
        },
        {
          "key": 25.0,
          "value": 170.0
        },
        {
          "key": 50.0,
          "value": 445.0
        },
        {
          "key": 75.0,
          "value": 720.0
        },
        {
          "key": 95.0,
          "value": 940.0
        },
        {
          "key": 99.0,
          "value": 980.0
        }
      ]
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_script_10"></a>Script<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/percentile-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>If you need to run the aggregation against values that aren&#8217;t indexed, use
a <a class="xref" href="runtime.html" title="Runtime fields">runtime field</a>. For example, if our load times
are in milliseconds but you want percentiles calculated in seconds:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET latency/_search
{
  "size": 0,
  "runtime_mappings": {
    "load_time.seconds": {
      "type": "long",
      "script": {
        "source": "emit(doc['load_time'].value / params.timeUnit)",
        "params": {
          "timeUnit": 1000
        }
      }
    }
  },
  "aggs": {
    "load_time_outlier": {
      "percentiles": {
        "field": "load_time.seconds"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1404.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-metrics-percentile-aggregation-approximation"></a>Percentiles are (usually) approximate<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/percentile-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>There are many different algorithms to calculate percentiles. The naive
implementation simply stores all the values in a sorted array. To find the 50th
percentile, you simply find the value that is at <code class="literal">my_array[count(my_array) * 0.5]</code>.</p>
<p>Clearly, the naive implementation does not scale&#8201;&#8212;&#8201;the sorted array grows
linearly with the number of values in your dataset. To calculate percentiles
across potentially billions of values in an Elasticsearch cluster, <em>approximate</em>
percentiles are calculated.</p>
<p>The algorithm used by the <code class="literal">percentile</code> metric is called TDigest (introduced by
Ted Dunning in
<a href="https://github.com/tdunning/t-digest/blob/master/docs/t-digest-paper/histo.pdf" class="ulink" target="_top">Computing Accurate Quantiles using T-Digests</a>).</p>
<p>When using this metric, there are a few guidelines to keep in mind:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Accuracy is proportional to <code class="literal">q(1-q)</code>. This means that extreme percentiles (e.g. 99%)
are more accurate than less extreme percentiles, such as the median
</li>
<li class="listitem">
For small sets of values, percentiles are highly accurate (and potentially
100% accurate if the data is small enough).
</li>
<li class="listitem">
As the quantity of values in a bucket grows, the algorithm begins to approximate
the percentiles. It is effectively trading accuracy for memory savings. The
exact level of inaccuracy is difficult to generalize, since it depends on your
data distribution and volume of data being aggregated
</li>
</ul>
</div>
<p>The following chart shows the relative error on a uniform distribution depending
on the number of collected values and the requested percentile:</p>
<p><span class="image"><img src="images/percentiles_error.png" alt="percentiles error"></span></p>
<p>It shows how precision is better for extreme percentiles. The reason why error diminishes
for large number of values is that the law of large numbers makes the distribution of
values more and more uniform and the t-digest tree can do a better job at summarizing
it. It would not be the case on more skewed distributions.</p>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>Percentile aggregations are also
<a href="https://en.wikipedia.org/wiki/Nondeterministic_algorithm" class="ulink" target="_top">non-deterministic</a>.
This means you can get slightly different results using the same data.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-metrics-percentile-aggregation-compression"></a>Compression<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/percentile-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Approximate algorithms must balance memory utilization with estimation accuracy.
This balance can be controlled using a <code class="literal">compression</code> parameter:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET latency/_search
{
  "size": 0,
  "aggs": {
    "load_time_outlier": {
      "percentiles": {
        "field": "load_time",
        "tdigest": {
          "compression": 200    <a id="CO318-1"></a><i class="conum" data-value="1"></i>
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1405.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO318-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Compression controls memory usage and approximation error</p>
</td>
</tr>
</table>
</div>
<p>The TDigest algorithm uses a number of "nodes" to approximate percentiles&#8201;&#8212;&#8201;the
more nodes available, the higher the accuracy (and large memory footprint) proportional
to the volume of data. The <code class="literal">compression</code> parameter limits the maximum number of
nodes to <code class="literal">20 * compression</code>.</p>
<p>Therefore, by increasing the compression value, you can increase the accuracy of
your percentiles at the cost of more memory. Larger compression values also
make the algorithm slower since the underlying tree data structure grows in size,
resulting in more expensive operations. The default compression value is
<code class="literal">100</code>.</p>
<p>A "node" uses roughly 32 bytes of memory, so under worst-case scenarios (large amount
of data which arrives sorted and in-order) the default settings will produce a
TDigest roughly 64KB in size. In practice data tends to be more random and
the TDigest will use less memory.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-metrics-percentile-aggregation-execution-hint"></a>Execution hint<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/percentile-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The default implementation of TDigest is optimized for performance, scaling to millions or even
billions of sample values while maintaining acceptable accuracy levels (close to 1% relative error
for millions of samples in some cases). There&#8217;s an option to use an implementation optimized
for accuracy by setting parameter <code class="literal">execution_hint</code> to value <code class="literal">high_accuracy</code>:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET latency/_search
{
  "size": 0,
  "aggs": {
    "load_time_outlier": {
      "percentiles": {
        "field": "load_time",
        "tdigest": {
          "execution_hint": "high_accuracy"    <a id="CO319-1"></a><i class="conum" data-value="1"></i>
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1406.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO319-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Optimize TDigest for accuracy, at the expense of performance</p>
</td>
</tr>
</table>
</div>
<p>This option can lead to improved accuracy (relative error close to 0.01% for millions of samples in some
cases) but then percentile queries take 2x-10x longer to complete.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_hdr_histogram_2"></a>HDR histogram<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/percentile-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p><a href="https://github.com/HdrHistogram/HdrHistogram" class="ulink" target="_top">HDR Histogram</a> (High Dynamic Range Histogram) is an alternative implementation
that can be useful when calculating percentiles for latency measurements as it can be faster than the t-digest implementation
with the trade-off of a larger memory footprint. This implementation maintains a fixed worse-case percentage error (specified
as a number of significant digits). This means that if data is recorded with values from 1 microsecond up to 1 hour
(3,600,000,000 microseconds) in a histogram set to 3 significant digits, it will maintain a value resolution of 1 microsecond
for values up to 1 millisecond and 3.6 seconds (or better) for the maximum tracked value (1 hour).</p>
<p>The HDR Histogram can be used by specifying the <code class="literal">hdr</code> parameter in the request:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET latency/_search
{
  "size": 0,
  "aggs": {
    "load_time_outlier": {
      "percentiles": {
        "field": "load_time",
        "percents": [ 95, 99, 99.9 ],
        "hdr": {                                  <a id="CO320-1"></a><i class="conum" data-value="1"></i>
          "number_of_significant_value_digits": 3 <a id="CO320-2"></a><i class="conum" data-value="2"></i>
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1407.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO320-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p><code class="literal">hdr</code> object indicates that HDR Histogram should be used to calculate the percentiles and specific settings for this algorithm can be specified inside the object</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO320-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p><code class="literal">number_of_significant_value_digits</code> specifies the resolution of values for the histogram in number of significant digits</p>
</td>
</tr>
</table>
</div>
<p>The HDRHistogram only supports positive values and will error if it is passed a negative value. It is also not a good idea to use
the HDRHistogram if the range of values is unknown as this could lead to high memory usage.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_missing_value_14"></a>Missing value<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/percentile-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">missing</code> parameter defines how documents that are missing a value should be treated.
By default they will be ignored but it is also possible to treat them as if they
had a value.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET latency/_search
{
  "size": 0,
  "aggs": {
    "grade_percentiles": {
      "percentiles": {
        "field": "grade",
        "missing": 10       <a id="CO321-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1408.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO321-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Documents without a value in the <code class="literal">grade</code> field will fall into the same bucket as documents that have the value <code class="literal">10</code>.</p>
</td>
</tr>
</table>
</div>
</div>

</div>

<div class="section xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-metrics-rate-aggregation"></a>Rate aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/rate-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A <code class="literal">rate</code> metrics aggregation can be used only inside a <code class="literal">date_histogram</code> or <code class="literal">composite</code> aggregation. It calculates a rate of documents
or a field in each bucket. The field values can be extracted from specific numeric or
<a class="xref" href="mapping-types.html#histogram" title="Histogram field type">histogram fields</a> in the documents.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>For <code class="literal">composite</code> aggregations, there must be exactly one <code class="literal">date_histogram</code> source for the <code class="literal">rate</code> aggregation to be supported.</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_syntax_4"></a>Syntax<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/rate-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>A <code class="literal">rate</code> aggregation looks like this in isolation:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "rate": {
    "unit": "month",
    "field": "requests"
  }
}</pre>
</div>
<p>The following request will group all sales records into monthly buckets and then convert the number of sales transactions in each bucket
into per annual sales rate.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET sales/_search
{
  "size": 0,
  "aggs": {
    "by_date": {
      "date_histogram": {
        "field": "date",
        "calendar_interval": "month"  <a id="CO322-1"></a><i class="conum" data-value="1"></i>
      },
      "aggs": {
        "my_rate": {
          "rate": {
            "unit": "year"  <a id="CO322-2"></a><i class="conum" data-value="2"></i>
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1409.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO322-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Histogram is grouped by month.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO322-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>But the rate is converted into annual rate.</p>
</td>
</tr>
</table>
</div>
<p>The response will return the annual rate of transactions in each bucket. Since there are 12 months per year, the annual rate will
be automatically calculated by multiplying the monthly rate by 12.</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations" : {
    "by_date" : {
      "buckets" : [
        {
          "key_as_string" : "2015/01/01 00:00:00",
          "key" : 1420070400000,
          "doc_count" : 3,
          "my_rate" : {
            "value" : 36.0
          }
        },
        {
          "key_as_string" : "2015/02/01 00:00:00",
          "key" : 1422748800000,
          "doc_count" : 2,
          "my_rate" : {
            "value" : 24.0
          }
        },
        {
          "key_as_string" : "2015/03/01 00:00:00",
          "key" : 1425168000000,
          "doc_count" : 2,
          "my_rate" : {
            "value" : 24.0
          }
        }
      ]
    }
  }
}</pre>
</div>
<p>Instead of counting the number of documents, it is also possible to calculate a sum of all values of the fields in the documents in each
bucket or the number of values in each bucket. The following request will group all sales records into monthly bucket and than calculate
the total monthly sales and convert them into average daily sales.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET sales/_search
{
  "size": 0,
  "aggs": {
    "by_date": {
      "date_histogram": {
        "field": "date",
        "calendar_interval": "month"  <a id="CO323-1"></a><i class="conum" data-value="1"></i>
      },
      "aggs": {
        "avg_price": {
          "rate": {
            "field": "price", <a id="CO323-2"></a><i class="conum" data-value="2"></i>
            "unit": "day"  <a id="CO323-3"></a><i class="conum" data-value="3"></i>
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1410.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO323-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Histogram is grouped by month.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO323-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>Calculate sum of all sale prices</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO323-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>Convert to average daily sales</p>
</td>
</tr>
</table>
</div>
<p>The response will contain the average daily sale prices for each month.</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations" : {
    "by_date" : {
      "buckets" : [
        {
          "key_as_string" : "2015/01/01 00:00:00",
          "key" : 1420070400000,
          "doc_count" : 3,
          "avg_price" : {
            "value" : 17.741935483870968
          }
        },
        {
          "key_as_string" : "2015/02/01 00:00:00",
          "key" : 1422748800000,
          "doc_count" : 2,
          "avg_price" : {
            "value" : 2.142857142857143
          }
        },
        {
          "key_as_string" : "2015/03/01 00:00:00",
          "key" : 1425168000000,
          "doc_count" : 2,
          "avg_price" : {
            "value" : 12.096774193548388
          }
        }
      ]
    }
  }
}</pre>
</div>
<p>You can also take advantage of <code class="literal">composite</code> aggregations to calculate the average daily sale price for each item in
your inventory</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET sales/_search?filter_path=aggregations&amp;size=0
{
  "aggs": {
    "buckets": {
      "composite": { <a id="CO324-1"></a><i class="conum" data-value="1"></i>
        "sources": [
          {
            "month": {
              "date_histogram": { <a id="CO324-2"></a><i class="conum" data-value="2"></i>
                "field": "date",
                "calendar_interval": "month"
              }
            }
          },
          {
            "type": { <a id="CO324-3"></a><i class="conum" data-value="3"></i>
              "terms": {
                "field": "type"
              }
            }
          }
        ]
      },
      "aggs": {
        "avg_price": {
          "rate": {
            "field": "price", <a id="CO324-4"></a><i class="conum" data-value="4"></i>
            "unit": "day" <a id="CO324-5"></a><i class="conum" data-value="5"></i>
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1411.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO324-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Composite aggregation with a date histogram source
and a source for the item type.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO324-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>The date histogram source grouping monthly</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO324-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>The terms source grouping for each sale item type</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO324-4"><i class="conum" data-value="4"></i></a></p>
</td>
<td align="left" valign="top">
<p>Calculate sum of all sale prices, per month and item</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO324-5"><i class="conum" data-value="5"></i></a></p>
</td>
<td align="left" valign="top">
<p>Convert to average daily sales per item</p>
</td>
</tr>
</table>
</div>
<p>The response will contain the average daily sale prices for each month per item.</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "aggregations" : {
    "buckets" : {
      "after_key" : {
        "month" : 1425168000000,
        "type" : "t-shirt"
      },
      "buckets" : [
        {
          "key" : {
            "month" : 1420070400000,
            "type" : "bag"
          },
          "doc_count" : 1,
          "avg_price" : {
            "value" : 4.838709677419355
          }
        },
        {
          "key" : {
            "month" : 1420070400000,
            "type" : "hat"
          },
          "doc_count" : 1,
          "avg_price" : {
            "value" : 6.451612903225806
          }
        },
        {
          "key" : {
            "month" : 1420070400000,
            "type" : "t-shirt"
          },
          "doc_count" : 1,
          "avg_price" : {
            "value" : 6.451612903225806
          }
        },
        {
          "key" : {
            "month" : 1422748800000,
            "type" : "hat"
          },
          "doc_count" : 1,
          "avg_price" : {
            "value" : 1.7857142857142858
          }
        },
        {
          "key" : {
            "month" : 1422748800000,
            "type" : "t-shirt"
          },
          "doc_count" : 1,
          "avg_price" : {
            "value" : 0.35714285714285715
          }
        },
        {
          "key" : {
            "month" : 1425168000000,
            "type" : "hat"
          },
          "doc_count" : 1,
          "avg_price" : {
            "value" : 6.451612903225806
          }
        },
        {
          "key" : {
            "month" : 1425168000000,
            "type" : "t-shirt"
          },
          "doc_count" : 1,
          "avg_price" : {
            "value" : 5.645161290322581
          }
        }
      ]
    }
  }
}</pre>
</div>
<p>By adding the <code class="literal">mode</code> parameter with the value <code class="literal">value_count</code>, we can change the calculation from <code class="literal">sum</code> to the number of values of the field:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET sales/_search
{
  "size": 0,
  "aggs": {
    "by_date": {
      "date_histogram": {
        "field": "date",
        "calendar_interval": "month"  <a id="CO325-1"></a><i class="conum" data-value="1"></i>
      },
      "aggs": {
        "avg_number_of_sales_per_year": {
          "rate": {
            "field": "price", <a id="CO325-2"></a><i class="conum" data-value="2"></i>
            "unit": "year",  <a id="CO325-3"></a><i class="conum" data-value="3"></i>
            "mode": "value_count" <a id="CO325-4"></a><i class="conum" data-value="4"></i>
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1412.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO325-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Histogram is grouped by month.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO325-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>Calculate number of all sale prices</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO325-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>Convert to annual counts</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO325-4"><i class="conum" data-value="4"></i></a></p>
</td>
<td align="left" valign="top">
<p>Changing the mode to value count</p>
</td>
</tr>
</table>
</div>
<p>The response will contain the average daily sale prices for each month.</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations" : {
    "by_date" : {
      "buckets" : [
        {
          "key_as_string" : "2015/01/01 00:00:00",
          "key" : 1420070400000,
          "doc_count" : 3,
          "avg_number_of_sales_per_year" : {
            "value" : 36.0
          }
        },
        {
          "key_as_string" : "2015/02/01 00:00:00",
          "key" : 1422748800000,
          "doc_count" : 2,
          "avg_number_of_sales_per_year" : {
            "value" : 24.0
          }
        },
        {
          "key_as_string" : "2015/03/01 00:00:00",
          "key" : 1425168000000,
          "doc_count" : 2,
          "avg_number_of_sales_per_year" : {
            "value" : 24.0
          }
        }
      ]
    }
  }
}</pre>
</div>
<p>By default <code class="literal">sum</code> mode is used.</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">"mode": "sum"</code>
</span>
</dt>
<dd>
calculate the sum of all values field
</dd>
<dt>
<span class="term">
<code class="literal">"mode": "value_count"</code>
</span>
</dt>
<dd>
use the number of values in the field
</dd>
</dl>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_relationship_between_bucket_sizes_and_rate"></a>Relationship between bucket sizes and rate<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/rate-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">rate</code> aggregation supports all rate that can be used <a class="xref" href="search-aggregations-bucket.html#calendar_intervals" title="Calendar intervals">calendar_intervals parameter</a> of <code class="literal">date_histogram</code>
aggregation. The specified rate should compatible with the <code class="literal">date_histogram</code> aggregation interval, i.e. it should be possible to
convert the bucket size into the rate. By default the interval of the <code class="literal">date_histogram</code> is used.</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">"rate": "second"</code>
</span>
</dt>
<dd>
compatible with all intervals
</dd>
<dt>
<span class="term">
<code class="literal">"rate": "minute"</code>
</span>
</dt>
<dd>
compatible with all intervals
</dd>
<dt>
<span class="term">
<code class="literal">"rate": "hour"</code>
</span>
</dt>
<dd>
compatible with all intervals
</dd>
<dt>
<span class="term">
<code class="literal">"rate": "day"</code>
</span>
</dt>
<dd>
compatible with all intervals
</dd>
<dt>
<span class="term">
<code class="literal">"rate": "week"</code>
</span>
</dt>
<dd>
compatible with all intervals
</dd>
<dt>
<span class="term">
<code class="literal">"rate": "month"</code>
</span>
</dt>
<dd>
compatible with only with <code class="literal">month</code>, <code class="literal">quarter</code> and <code class="literal">year</code> calendar intervals
</dd>
<dt>
<span class="term">
<code class="literal">"rate": "quarter"</code>
</span>
</dt>
<dd>
compatible with only with <code class="literal">month</code>, <code class="literal">quarter</code> and <code class="literal">year</code> calendar intervals
</dd>
<dt>
<span class="term">
<code class="literal">"rate": "year"</code>
</span>
</dt>
<dd>
compatible with only with <code class="literal">month</code>, <code class="literal">quarter</code> and <code class="literal">year</code> calendar intervals
</dd>
</dl>
</div>
<p>There is also an additional limitations if the date histogram is not a direct parent of the rate histogram. In this case both rate interval
and histogram interval have to be in the same group: [<code class="literal">second</code>, ` minute`, <code class="literal">hour</code>, <code class="literal">day</code>, <code class="literal">week</code>] or [<code class="literal">month</code>, <code class="literal">quarter</code>, <code class="literal">year</code>]. For
example, if the date histogram is <code class="literal">month</code> based, only rate intervals of <code class="literal">month</code>, <code class="literal">quarter</code> or <code class="literal">year</code> are supported. If the date histogram
is <code class="literal">day</code> based, only  <code class="literal">second</code>, ` minute`, <code class="literal">hour</code>, <code class="literal">day</code>, and <code class="literal">week</code> rate intervals are supported.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_script_11"></a>Script<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/rate-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>If you need to run the aggregation against values that aren&#8217;t indexed, run the
aggregation on a <a class="xref" href="runtime.html" title="Runtime fields">runtime field</a>. For example, if we need to adjust
our prices before calculating rates:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET sales/_search
{
  "size": 0,
  "runtime_mappings": {
    "price.adjusted": {
      "type": "double",
      "script": {
        "source": "emit(doc['price'].value * params.adjustment)",
        "params": {
          "adjustment": 0.9
        }
      }
    }
  },
  "aggs": {
    "by_date": {
      "date_histogram": {
        "field": "date",
        "calendar_interval": "month"
      },
      "aggs": {
        "avg_price": {
          "rate": {
            "field": "price.adjusted"
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1413.console"></div>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations" : {
    "by_date" : {
      "buckets" : [
        {
          "key_as_string" : "2015/01/01 00:00:00",
          "key" : 1420070400000,
          "doc_count" : 3,
          "avg_price" : {
            "value" : 495.0
          }
        },
        {
          "key_as_string" : "2015/02/01 00:00:00",
          "key" : 1422748800000,
          "doc_count" : 2,
          "avg_price" : {
            "value" : 54.0
          }
        },
        {
          "key_as_string" : "2015/03/01 00:00:00",
          "key" : 1425168000000,
          "doc_count" : 2,
          "avg_price" : {
            "value" : 337.5
          }
        }
      ]
    }
  }
}</pre>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-metrics-scripted-metric-aggregation"></a>Scripted metric aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/scripted-metric-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A metric aggregation that executes using scripts to provide a metric output.</p>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>Using scripts can result in slower search speeds. See
<a class="xref" href="modules-scripting-using.html#scripts-and-search-speed" title="Scripts, caching, and search speed">Scripts, caching, and search speed</a>.</p>
</div>
</div>
<p>Example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST ledger/_search?size=0
{
  "query": {
    "match_all": {}
  },
  "aggs": {
    "profit": {
      "scripted_metric": {
        "init_script": "state.transactions = []", <a id="CO326-1"></a><i class="conum" data-value="1"></i>
        "map_script": "state.transactions.add(doc.type.value == 'sale' ? doc.amount.value : -1 * doc.amount.value)",
        "combine_script": "double profit = 0; for (t in state.transactions) { profit += t } return profit",
        "reduce_script": "double profit = 0; for (a in states) { profit += a } return profit"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1414.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO326-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p><code class="literal">init_script</code> is an optional parameter, all other scripts are required.</p>
</td>
</tr>
</table>
</div>
<p>The above aggregation demonstrates how one would use the script aggregation compute the total profit from sale and cost transactions.</p>
<p>The response for the above aggregation:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "took": 218,
  ...
  "aggregations": {
    "profit": {
      "value": 240.0
    }
  }
}</pre>
</div>
<p>The above example can also be specified using stored scripts as follows:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST ledger/_search?size=0
{
  "aggs": {
    "profit": {
      "scripted_metric": {
        "init_script": {
          "id": "my_init_script"
        },
        "map_script": {
          "id": "my_map_script"
        },
        "combine_script": {
          "id": "my_combine_script"
        },
        "params": {
          "field": "amount"           <a id="CO327-1"></a><i class="conum" data-value="1"></i>
        },
        "reduce_script": {
          "id": "my_reduce_script"
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1415.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO327-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>script parameters for <code class="literal">init</code>, <code class="literal">map</code> and <code class="literal">combine</code> scripts must be specified
in a global <code class="literal">params</code> object so that it can be shared between the scripts.</p>
</td>
</tr>
</table>
</div>
<p>For more details on specifying scripts see <a class="xref" href="modules-scripting.html" title="Scripting">script documentation</a>.</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="scripted-metric-aggregation-return-types"></a>Allowed return types<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/scripted-metric-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Whilst any valid script object can be used within a single script, the scripts must return or store in the <code class="literal">state</code> object only the following types:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
primitive types
</li>
<li class="listitem">
String
</li>
<li class="listitem">
Map (containing only keys and values of the types listed here)
</li>
<li class="listitem">
Array (containing elements of only the types listed here)
</li>
</ul>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="scripted-metric-aggregation-scope"></a>Scope of scripts<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/scripted-metric-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The scripted metric aggregation uses scripts at 4 stages of its execution:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
init_script
</span>
</dt>
<dd>
<p>
Executed prior to any collection of documents. Allows the aggregation to set up any initial state.
</p>
<p>In the above example, the <code class="literal">init_script</code> creates an array <code class="literal">transactions</code> in the <code class="literal">state</code> object.</p>
</dd>
<dt>
<span class="term">
map_script
</span>
</dt>
<dd>
<p>
Executed once per document collected. This is a required script. If no combine_script is specified, the resulting state
needs to be stored in the <code class="literal">state</code> object.
</p>
<p>In the above example, the <code class="literal">map_script</code> checks the value of the type field. If the value is <em>sale</em> the value of the amount field
is added to the transactions array. If the value of the type field is not <em>sale</em> the negated value of the amount field is added
to transactions.</p>
</dd>
<dt>
<span class="term">
combine_script
</span>
</dt>
<dd>
<p>
Executed once on each shard after document collection is complete. This is a required script. Allows the aggregation to
consolidate the state returned from each shard.
</p>
<p>In the above example, the <code class="literal">combine_script</code> iterates through all the stored transactions, summing the values in the <code class="literal">profit</code> variable
and finally returns <code class="literal">profit</code>.</p>
</dd>
<dt>
<span class="term">
reduce_script
</span>
</dt>
<dd>
<p>
Executed once on the coordinating node after all shards have returned their results. This is a required script. The
script is provided with access to a variable <code class="literal">states</code> which is an array of the result of the combine_script on each
shard.
</p>
<p>In the above example, the <code class="literal">reduce_script</code> iterates through the <code class="literal">profit</code> returned by each shard summing the values before returning the
final combined profit which will be returned in the response of the aggregation.</p>
</dd>
</dl>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="scripted-metric-aggregation-example"></a>Worked example<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/scripted-metric-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Imagine a situation where you index the following documents into an index with 2 shards:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /transactions/_bulk?refresh
{"index":{"_id":1}}
{"type": "sale","amount": 80}
{"index":{"_id":2}}
{"type": "cost","amount": 10}
{"index":{"_id":3}}
{"type": "cost","amount": 30}
{"index":{"_id":4}}
{"type": "sale","amount": 130}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1416.console"></div>
<p>Lets say that documents 1 and 3 end up on shard A and documents 2 and 4 end up on shard B. The following is a breakdown of what the aggregation result is
at each stage of the example above.</p>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_before_init_script"></a>Before init_script<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/scripted-metric-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p><code class="literal">state</code> is initialized as a new empty object.</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">"state" : {}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_after_init_script"></a>After init_script<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/scripted-metric-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>This is run once on each shard before any document collection is performed, and so we will have a copy on each shard:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
Shard A
</span>
</dt>
<dd>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">"state" : {
    "transactions" : []
}</pre>
</div>
</dd>
<dt>
<span class="term">
Shard B
</span>
</dt>
<dd>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">"state" : {
    "transactions" : []
}</pre>
</div>
</dd>
</dl>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_after_map_script"></a>After map_script<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/scripted-metric-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>Each shard collects its documents and runs the map_script on each document that is collected:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
Shard A
</span>
</dt>
<dd>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">"state" : {
    "transactions" : [ 80, -30 ]
}</pre>
</div>
</dd>
<dt>
<span class="term">
Shard B
</span>
</dt>
<dd>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">"state" : {
    "transactions" : [ -10, 130 ]
}</pre>
</div>
</dd>
</dl>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_after_combine_script"></a>After combine_script<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/scripted-metric-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>The combine_script is executed on each shard after document collection is complete and reduces all the transactions down to a single profit figure for each
shard (by summing the values in the transactions array) which is passed back to the coordinating node:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
Shard A
</span>
</dt>
<dd>
50
</dd>
<dt>
<span class="term">
Shard B
</span>
</dt>
<dd>
120
</dd>
</dl>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_after_reduce_script"></a>After reduce_script<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/scripted-metric-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>The reduce_script receives a <code class="literal">states</code> array containing the result of the combine script for each shard:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">"states" : [
    50,
    120
]</pre>
</div>
<p>It reduces the responses for the shards down to a final overall profit figure (by summing the values) and returns this as the result of the aggregation to
produce the response:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  ...

  "aggregations": {
    "profit": {
      "value": 170
    }
  }
}</pre>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="scripted-metric-aggregation-parameters"></a>Other parameters<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/scripted-metric-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<div class="informaltable">
<table border="0" cellpadding="4px">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody valign="top">
<tr>
<td valign="top">
<p>
params
</p>
</td>
<td valign="top">
<p>
<p>
Optional. An object whose contents will be passed as variables to the  <code class="literal">init_script</code>, <code class="literal">map_script</code> and <code class="literal">combine_script</code>. This can be
useful to allow the user to control the behavior of the aggregation and for storing state between the scripts. If this is not specified,
the default is the equivalent of providing:
</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">"params" : {}</pre>
</div>
</p>
</td>
</tr>
</tbody>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="scripted-metric-aggregation-empty-buckets"></a>Empty buckets<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/scripted-metric-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>If a parent bucket of the scripted metric aggregation does not collect any documents an empty aggregation response will be returned from the
shard with a <code class="literal">null</code> value. In this case the <code class="literal">reduce_script</code>'s <code class="literal">states</code> variable will contain <code class="literal">null</code> as a response from that shard.
<code class="literal">reduce_script</code>'s should therefore expect and deal with <code class="literal">null</code> responses from shards.</p>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-metrics-stats-aggregation"></a>Stats aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/stats-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A <code class="literal">multi-value</code> metrics aggregation that computes stats over numeric values extracted from the aggregated documents.</p>
<p>The stats that are returned consist of: <code class="literal">min</code>, <code class="literal">max</code>, <code class="literal">sum</code>, <code class="literal">count</code> and <code class="literal">avg</code>.</p>
<p>Assuming the data consists of documents representing exams grades (between 0 and 100) of students</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /exams/_search?size=0
{
  "aggs": {
    "grades_stats": { "stats": { "field": "grade" } }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1417.console"></div>
<p>The above aggregation computes the grades statistics over all documents. The aggregation type is <code class="literal">stats</code> and the <code class="literal">field</code> setting defines the numeric field of the documents the stats will be computed on. The above will return the following:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...

  "aggregations": {
    "grades_stats": {
      "count": 2,
      "min": 50.0,
      "max": 100.0,
      "avg": 75.0,
      "sum": 150.0
    }
  }
}</pre>
</div>
<p>The name of the aggregation (<code class="literal">grades_stats</code> above) also serves as the key by which the aggregation result can be retrieved from the returned response.</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_script_12"></a>Script<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/stats-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>If you need to get the <code class="literal">stats</code> for something more complex than a single field,
run the aggregation on a <a class="xref" href="runtime.html" title="Runtime fields">runtime field</a>.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /exams/_search
{
  "size": 0,
  "runtime_mappings": {
    "grade.weighted": {
      "type": "double",
      "script": """
        emit(doc['grade'].value * doc['weight'].value)
      """
    }
  },
  "aggs": {
    "grades_stats": {
      "stats": {
        "field": "grade.weighted"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1418.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_missing_value_15"></a>Missing value<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/stats-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">missing</code> parameter defines how documents that are missing a value should be treated.
By default they will be ignored but it is also possible to treat them as if they
had a value.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /exams/_search?size=0
{
  "aggs": {
    "grades_stats": {
      "stats": {
        "field": "grade",
        "missing": 0      <a id="CO328-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1419.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO328-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Documents without a value in the <code class="literal">grade</code> field will fall into the same bucket as documents that have the value <code class="literal">0</code>.</p>
</td>
</tr>
</table>
</div>
</div>

</div>

<div class="section xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-metrics-string-stats-aggregation"></a>String stats aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/string-stats-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A <code class="literal">multi-value</code> metrics aggregation that computes statistics over string values extracted from the aggregated documents.
These values can be retrieved either from specific <code class="literal">keyword</code> fields.</p>
<p>The string stats aggregation returns the following results:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<code class="literal">count</code> - The number of non-empty fields counted.
</li>
<li class="listitem">
<code class="literal">min_length</code> - The length of the shortest term.
</li>
<li class="listitem">
<code class="literal">max_length</code> - The length of the longest term.
</li>
<li class="listitem">
<code class="literal">avg_length</code> - The average length computed over all terms.
</li>
<li class="listitem">
<code class="literal">entropy</code> - The <a href="https://en.wikipedia.org/wiki/Entropy_(information_theory)" class="ulink" target="_top">Shannon Entropy</a> value computed over all terms collected by
the aggregation. Shannon entropy quantifies the amount of information contained in the field. It is a very useful metric for
measuring a wide range of properties of a data set, such as diversity, similarity, randomness etc.
</li>
</ul>
</div>
<p>For example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /my-index-000001/_search?size=0
{
  "aggs": {
    "message_stats": { "string_stats": { "field": "message.keyword" } }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1420.console"></div>
<p>The above aggregation computes the string statistics for the <code class="literal">message</code> field in all documents. The aggregation type
is <code class="literal">string_stats</code> and the <code class="literal">field</code> parameter defines the field of the documents the stats will be computed on.
The above will return the following:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...

  "aggregations": {
    "message_stats": {
      "count": 5,
      "min_length": 24,
      "max_length": 30,
      "avg_length": 28.8,
      "entropy": 3.94617750050791
    }
  }
}</pre>
</div>
<p>The name of the aggregation (<code class="literal">message_stats</code> above) also serves as the key by which the aggregation result can be retrieved from
the returned response.</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_character_distribution"></a>Character distribution<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/string-stats-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The computation of the Shannon Entropy value is based on the probability of each character appearing in all terms collected
by the aggregation. To view the probability distribution for all characters, we can add the <code class="literal">show_distribution</code> (default: <code class="literal">false</code>) parameter.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /my-index-000001/_search?size=0
{
  "aggs": {
    "message_stats": {
      "string_stats": {
        "field": "message.keyword",
        "show_distribution": true  <a id="CO329-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1421.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO329-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Set the <code class="literal">show_distribution</code> parameter to <code class="literal">true</code>, so that probability distribution for all characters is returned in the results.</p>
</td>
</tr>
</table>
</div>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...

  "aggregations": {
    "message_stats": {
      "count": 5,
      "min_length": 24,
      "max_length": 30,
      "avg_length": 28.8,
      "entropy": 3.94617750050791,
      "distribution": {
        " ": 0.1527777777777778,
        "e": 0.14583333333333334,
        "s": 0.09722222222222222,
        "m": 0.08333333333333333,
        "t": 0.0763888888888889,
        "h": 0.0625,
        "a": 0.041666666666666664,
        "i": 0.041666666666666664,
        "r": 0.041666666666666664,
        "g": 0.034722222222222224,
        "n": 0.034722222222222224,
        "o": 0.034722222222222224,
        "u": 0.034722222222222224,
        "b": 0.027777777777777776,
        "w": 0.027777777777777776,
        "c": 0.013888888888888888,
        "E": 0.006944444444444444,
        "l": 0.006944444444444444,
        "1": 0.006944444444444444,
        "2": 0.006944444444444444,
        "3": 0.006944444444444444,
        "4": 0.006944444444444444,
        "y": 0.006944444444444444
      }
    }
  }
}</pre>
</div>
<p>The <code class="literal">distribution</code> object shows the probability of each character appearing in all terms. The characters are sorted by descending probability.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_script_13"></a>Script<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/string-stats-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>If you need to get the <code class="literal">string_stats</code> for something more complex than a single
field, run the aggregation on a <a class="xref" href="runtime.html" title="Runtime fields">runtime field</a>.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /my-index-000001/_search
{
  "size": 0,
  "runtime_mappings": {
    "message_and_context": {
      "type": "keyword",
      "script": """
        emit(doc['message.keyword'].value + ' ' + doc['context.keyword'].value)
      """
    }
  },
  "aggs": {
    "message_stats": {
      "string_stats": { "field": "message_and_context" }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1422.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_missing_value_16"></a>Missing value<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/string-stats-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">missing</code> parameter defines how documents that are missing a value should be treated.
By default they will be ignored but it is also possible to treat them as if they had a value.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /my-index-000001/_search?size=0
{
  "aggs": {
    "message_stats": {
      "string_stats": {
        "field": "message.keyword",
        "missing": "[empty message]" <a id="CO330-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1423.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO330-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Documents without a value in the <code class="literal">message</code> field will be treated as documents that have the value <code class="literal">[empty message]</code>.</p>
</td>
</tr>
</table>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-metrics-sum-aggregation"></a>Sum aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/sum-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A <code class="literal">single-value</code> metrics aggregation that sums up numeric values that are extracted from the aggregated documents.
These values can be extracted either from specific numeric or <a class="xref" href="mapping-types.html#histogram" title="Histogram field type">histogram</a> fields.</p>
<p>Assuming the data consists of documents representing sales records we can sum
the sale price of all hats with:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "query": {
    "constant_score": {
      "filter": {
        "match": { "type": "hat" }
      }
    }
  },
  "aggs": {
    "hat_prices": { "sum": { "field": "price" } }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1424.console"></div>
<p>Resulting in:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "hat_prices": {
      "value": 450.0
    }
  }
}</pre>
</div>
<p>The name of the aggregation (<code class="literal">hat_prices</code> above) also serves as the key by which the aggregation result can be retrieved from the returned response.</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_script_14"></a>Script<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/sum-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>If you need to get the <code class="literal">sum</code> for something more complex than a single
field, run the aggregation on a <a class="xref" href="runtime.html" title="Runtime fields">runtime field</a>.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "runtime_mappings": {
    "price.weighted": {
      "type": "double",
      "script": """
        double price = doc['price'].value;
        if (doc['promoted'].value) {
          price *= 0.8;
        }
        emit(price);
      """
    }
  },
  "query": {
    "constant_score": {
      "filter": {
        "match": { "type": "hat" }
      }
    }
  },
  "aggs": {
    "hat_prices": {
      "sum": {
        "field": "price.weighted"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1425.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_missing_value_17"></a>Missing value<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/sum-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">missing</code> parameter defines how documents that are missing a value should
be treated. By default documents missing the value will be ignored but it is
also possible to treat them as if they had a value. For example, this treats
all hat sales without a price as being <code class="literal">100</code>.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "query": {
    "constant_score": {
      "filter": {
        "match": { "type": "hat" }
      }
    }
  },
  "aggs": {
    "hat_prices": {
      "sum": {
        "field": "price",
        "missing": 100 <a id="CO331-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1426.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-metrics-sum-aggregation-histogram-fields"></a>Histogram fields<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/sum-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>When sum is computed on <a class="xref" href="mapping-types.html#histogram" title="Histogram field type">histogram fields</a>, the result of the aggregation is the sum of all elements in the <code class="literal">values</code>
array multiplied by the number in the same position in the <code class="literal">counts</code> array.</p>
<p>For example, for the following index that stores pre-aggregated histograms with latency metrics for different networks:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT metrics_index
{
  "mappings": {
    "properties": {
      "latency_histo": { "type": "histogram" }
    }
  }
}

PUT metrics_index/_doc/1?refresh
{
  "network.name" : "net-1",
  "latency_histo" : {
      "values" : [0.1, 0.2, 0.3, 0.4, 0.5],
      "counts" : [3, 7, 23, 12, 6]
   }
}

PUT metrics_index/_doc/2?refresh
{
  "network.name" : "net-2",
  "latency_histo" : {
      "values" :  [0.1, 0.2, 0.3, 0.4, 0.5],
      "counts" : [8, 17, 8, 7, 6]
   }
}

POST /metrics_index/_search?size=0&amp;filter_path=aggregations
{
  "aggs" : {
    "total_latency" : { "sum" : { "field" : "latency_histo" } }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1427.console"></div>
<p>For each histogram field, the <code class="literal">sum</code> aggregation will add each number in the
<code class="literal">values</code> array, multiplied by its associated count in the <code class="literal">counts</code> array.</p>
<p>Eventually, it will add all values for all histograms and return the following
result:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "aggregations": {
    "total_latency": {
      "value": 28.8
    }
  }
}</pre>
</div>
</div>

</div>

<div class="section xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-metrics-ttest-aggregation"></a>T-test aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/t-test-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A <code class="literal">t_test</code> metrics aggregation that performs a statistical hypothesis test in which the test statistic follows a Student&#8217;s t-distribution
under the null hypothesis on numeric values extracted from the aggregated documents. In practice, this
will tell you if the difference between two population means are statistically significant and did not occur by chance alone.</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_syntax_5"></a>Syntax<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/t-test-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>A <code class="literal">t_test</code> aggregation looks like this in isolation:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "t_test": {
    "a": "value_before",
    "b": "value_after",
    "type": "paired"
  }
}</pre>
</div>
<p>Assuming that we have a record of node start up times before and after upgrade, let&#8217;s look at a t-test to see if upgrade affected
the node start up time in a meaningful way.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET node_upgrade/_search
{
  "size": 0,
  "aggs": {
    "startup_time_ttest": {
      "t_test": {
        "a": { "field": "startup_time_before" },  <a id="CO331-2"></a><i class="conum" data-value="1"></i>
        "b": { "field": "startup_time_after" },   <a id="CO331-3"></a><i class="conum" data-value="2"></i>
        "type": "paired"                          <a id="CO331-4"></a><i class="conum" data-value="3"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1428.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO331-1"><i class="conum" data-value="1"></i></a><a href="#CO331-2"></a></p>
</td>
<td align="left" valign="top">
<p>The field <code class="literal">startup_time_before</code> must be a numeric field.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO331-3"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>The field <code class="literal">startup_time_after</code> must be a numeric field.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO331-4"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>Since we have data from the same nodes, we are using paired t-test.</p>
</td>
</tr>
</table>
</div>
<p>The response will return the p-value or probability value for the test. It is the probability of obtaining results at least as extreme as
the result processed by the aggregation, assuming that the null hypothesis is correct (which means there is no difference between
population means). Smaller p-value means the null hypothesis is more likely to be incorrect and population means are indeed different.</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...

 "aggregations": {
    "startup_time_ttest": {
      "value": 0.1914368843365979 <a id="CO332-1"></a><i class="conum" data-value="1"></i>
    }
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO332-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The p-value.</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_t_test_types"></a>T-Test Types<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/t-test-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">t_test</code> aggregation supports unpaired and paired two-sample t-tests. The type of the test can be specified using the <code class="literal">type</code> parameter:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">"type": "paired"</code>
</span>
</dt>
<dd>
performs paired t-test
</dd>
<dt>
<span class="term">
<code class="literal">"type": "homoscedastic"</code>
</span>
</dt>
<dd>
performs two-sample equal variance test
</dd>
<dt>
<span class="term">
<code class="literal">"type": "heteroscedastic"</code>
</span>
</dt>
<dd>
performs two-sample unequal variance test (this is default)
</dd>
</dl>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_filters"></a>Filters<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/t-test-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>It is also possible to run unpaired t-test on different sets of records using filters. For example, if we want to test the difference
of startup times before upgrade between two different groups of nodes, we use the same field <code class="literal">startup_time_before</code> by separate groups of
nodes using terms filters on the group name field:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET node_upgrade/_search
{
  "size": 0,
  "aggs": {
    "startup_time_ttest": {
      "t_test": {
        "a": {
          "field": "startup_time_before",         <a id="CO333-1"></a><i class="conum" data-value="1"></i>
          "filter": {
            "term": {
              "group": "A"                        <a id="CO333-2"></a><i class="conum" data-value="2"></i>
            }
          }
        },
        "b": {
          "field": "startup_time_before",         <a id="CO333-3"></a><i class="conum" data-value="3"></i>
          "filter": {
            "term": {
              "group": "B"                        <a id="CO333-4"></a><i class="conum" data-value="4"></i>
            }
          }
        },
        "type": "heteroscedastic"                 <a id="CO333-5"></a><i class="conum" data-value="5"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1429.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO333-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The field <code class="literal">startup_time_before</code> must be a numeric field.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO333-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>Any query that separates two groups can be used here.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO333-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>We are using the same field</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO333-4"><i class="conum" data-value="4"></i></a></p>
</td>
<td align="left" valign="top">
<p>but we are using different filters.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO333-5"><i class="conum" data-value="5"></i></a></p>
</td>
<td align="left" valign="top">
<p>Since we have data from different nodes, we cannot use paired t-test.</p>
</td>
</tr>
</table>
</div>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...

 "aggregations": {
    "startup_time_ttest": {
      "value": 0.2981858007281437 <a id="CO334-1"></a><i class="conum" data-value="1"></i>
    }
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO334-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The p-value.</p>
</td>
</tr>
</table>
</div>
<p>Populations don&#8217;t have to be in the same index. If data sets are located in different
indices, the term filter on the <a class="xref" href="mapping-fields.html#mapping-index-field" title="_index field"><code class="literal">_index</code></a> field can be used to select populations.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_script_15"></a>Script<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/t-test-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>If you need to run the <code class="literal">t_test</code> on values that aren&#8217;t represented cleanly
by a field you should, run the aggregation on a <a class="xref" href="runtime.html" title="Runtime fields">runtime field</a>.
For example, if you want to adjust out load times for the before values:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET node_upgrade/_search
{
  "size": 0,
  "runtime_mappings": {
    "startup_time_before.adjusted": {
      "type": "long",
      "script": {
        "source": "emit(doc['startup_time_before'].value - params.adjustment)",
        "params": {
          "adjustment": 10
        }
      }
    }
  },
  "aggs": {
    "startup_time_ttest": {
      "t_test": {
        "a": {
          "field": "startup_time_before.adjusted"
        },
        "b": {
          "field": "startup_time_after"
        },
        "type": "paired"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1430.console"></div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-metrics-top-hits-aggregation"></a>Top hits aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/tophits-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A <code class="literal">top_hits</code> metric aggregator keeps track of the most relevant document being aggregated. This aggregator is intended
to be used as a sub aggregator, so that the top matching documents can be aggregated per bucket.</p>
<div class="tip admon">
<div class="icon"></div>
<div class="admon_content">
<p>We do not recommend using <code class="literal">top_hits</code> as a top-level aggregation. If you
want to group search hits, use the <a class="xref" href="collapse-search-results.html" title="Collapse search results"><code class="literal">collapse</code></a>
parameter instead.</p>
</div>
</div>
<p>The <code class="literal">top_hits</code> aggregator can effectively be used to group result sets by certain fields via a bucket aggregator.
One or more bucket aggregators determines by which properties a result set get sliced into.</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_options_6"></a>Options<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/tophits-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<code class="literal">from</code> - The offset from the first result you want to fetch.
</li>
<li class="listitem">
<code class="literal">size</code> - The maximum number of top matching hits to return per bucket. By default the top three matching hits are returned.
</li>
<li class="listitem">
<code class="literal">sort</code> - How the top matching hits should be sorted. By default the hits are sorted by the score of the main query.
</li>
</ul>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_supported_per_hit_features"></a>Supported per hit features<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/tophits-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The top_hits aggregation returns regular search hits, because of this many per hit features can be supported:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<a class="xref" href="highlighting.html" title="Highlighting">Highlighting</a>
</li>
<li class="listitem">
<a class="xref" href="search.html#request-body-search-explain">Explain</a>
</li>
<li class="listitem">
<a class="xref" href="compound-queries.html#named-queries" title="Named queries">Named queries</a>
</li>
<li class="listitem">
<a class="xref" href="search-fields.html#search-fields-param" title="The fields option">Search fields</a>
</li>
<li class="listitem">
<a class="xref" href="search-fields.html#source-filtering" title="The _source option">Source filtering</a>
</li>
<li class="listitem">
<a class="xref" href="search-fields.html#stored-fields" title="Stored fields">Stored fields</a>
</li>
<li class="listitem">
<a class="xref" href="search-fields.html#script-fields" title="Script fields">Script fields</a>
</li>
<li class="listitem">
<a class="xref" href="search-fields.html#docvalue-fields" title="Doc value fields">Doc value fields</a>
</li>
<li class="listitem">
<a class="xref" href="search.html#request-body-search-version">Include versions</a>
</li>
<li class="listitem">
<a class="xref" href="search.html#request-body-search-seq-no-primary-term">Include Sequence Numbers and Primary Terms</a>
</li>
</ul>
</div>
<div class="important admon">
<div class="icon"></div>
<div class="admon_content">
<p>If you <span class="strong strong"><strong>only</strong></span> need <code class="literal">docvalue_fields</code>, <code class="literal">size</code>, and <code class="literal">sort</code> then
<a class="xref" href="search-aggregations-metrics.html#search-aggregations-metrics-top-metrics" title="Top metrics aggregation">Top metrics</a> might be a more efficient choice than the Top Hits Aggregation.</p>
</div>
</div>
<p><code class="literal">top_hits</code> does not support the <a class="xref" href="filter-search-results.html#rescore" title="Rescore filtered search results"><code class="literal">rescore</code></a> parameter. Query rescoring
applies only to search hits, not aggregation results. To change the scores used
by aggregations, use a <a class="xref" href="compound-queries.html#query-dsl-function-score-query" title="Function score query"><code class="literal">function_score</code></a> or
<a class="xref" href="specialized-queries.html#query-dsl-script-score-query" title="Script score query"><code class="literal">script_score</code></a> query.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_example_6"></a>Example<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/tophits-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>In the following example we group the sales by type and per type we show the last sale.
For each sale only the date and price fields are being included in the source.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "top_tags": {
      "terms": {
        "field": "type",
        "size": 3
      },
      "aggs": {
        "top_sales_hits": {
          "top_hits": {
            "sort": [
              {
                "date": {
                  "order": "desc"
                }
              }
            ],
            "_source": {
              "includes": [ "date", "price" ]
            },
            "size": 1
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1431.console"></div>
<p>Possible response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "top_tags": {
       "doc_count_error_upper_bound": 0,
       "sum_other_doc_count": 0,
       "buckets": [
          {
             "key": "hat",
             "doc_count": 3,
             "top_sales_hits": {
                "hits": {
                   "total" : {
                       "value": 3,
                       "relation": "eq"
                   },
                   "max_score": null,
                   "hits": [
                      {
                         "_index": "sales",
                         "_id": "AVnNBmauCQpcRyxw6ChK",
                         "_source": {
                            "date": "2015/03/01 00:00:00",
                            "price": 200
                         },
                         "sort": [
                            1425168000000
                         ],
                         "_score": null
                      }
                   ]
                }
             }
          },
          {
             "key": "t-shirt",
             "doc_count": 3,
             "top_sales_hits": {
                "hits": {
                   "total" : {
                       "value": 3,
                       "relation": "eq"
                   },
                   "max_score": null,
                   "hits": [
                      {
                         "_index": "sales",
                         "_id": "AVnNBmauCQpcRyxw6ChL",
                         "_source": {
                            "date": "2015/03/01 00:00:00",
                            "price": 175
                         },
                         "sort": [
                            1425168000000
                         ],
                         "_score": null
                      }
                   ]
                }
             }
          },
          {
             "key": "bag",
             "doc_count": 1,
             "top_sales_hits": {
                "hits": {
                   "total" : {
                       "value": 1,
                       "relation": "eq"
                   },
                   "max_score": null,
                   "hits": [
                      {
                         "_index": "sales",
                         "_id": "AVnNBmatCQpcRyxw6ChH",
                         "_source": {
                            "date": "2015/01/01 00:00:00",
                            "price": 150
                         },
                         "sort": [
                            1420070400000
                         ],
                         "_score": null
                      }
                   ]
                }
             }
          }
       ]
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_field_collapse_example"></a>Field collapse example<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/tophits-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Field collapsing or result grouping is a feature that logically groups a result set into groups and per group returns
top documents. The ordering of the groups is determined by the relevancy of the first document in a group. In
Elasticsearch this can be implemented via a bucket aggregator that wraps a <code class="literal">top_hits</code> aggregator as sub-aggregator.</p>
<p>In the example below we search across crawled webpages. For each webpage we store the body and the domain the webpage
belong to. By defining a <code class="literal">terms</code> aggregator on the <code class="literal">domain</code> field we group the result set of webpages by domain. The
<code class="literal">top_hits</code> aggregator is then defined as sub-aggregator, so that the top matching hits are collected per bucket.</p>
<p>Also a <code class="literal">max</code> aggregator is defined which is used by the <code class="literal">terms</code> aggregator&#8217;s order feature to return the buckets by
relevancy order of the most relevant document in a bucket.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search
{
  "query": {
    "match": {
      "body": "elections"
    }
  },
  "aggs": {
    "top_sites": {
      "terms": {
        "field": "domain",
        "order": {
          "top_hit": "desc"
        }
      },
      "aggs": {
        "top_tags_hits": {
          "top_hits": {}
        },
        "top_hit" : {
          "max": {
            "script": {
              "source": "_score"
            }
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1432.console"></div>
<p>At the moment the <code class="literal">max</code> (or <code class="literal">min</code>) aggregator is needed to make sure the buckets from the <code class="literal">terms</code> aggregator are
ordered according to the score of the most relevant webpage per domain. Unfortunately the <code class="literal">top_hits</code> aggregator
can&#8217;t be used in the <code class="literal">order</code> option of the <code class="literal">terms</code> aggregator yet.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_top_hits_support_in_a_nested_or_reverse_nested_aggregator"></a>top_hits support in a nested or reverse_nested aggregator<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/tophits-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>If the <code class="literal">top_hits</code> aggregator is wrapped in a <code class="literal">nested</code> or <code class="literal">reverse_nested</code> aggregator then nested hits are being returned.
Nested hits are in a sense hidden mini documents that are part of regular document where in the mapping a nested field type
has been configured. The <code class="literal">top_hits</code> aggregator has the ability to un-hide these documents if it is wrapped in a <code class="literal">nested</code>
or <code class="literal">reverse_nested</code> aggregator. Read more about nested in the <a class="xref" href="mapping-types.html#nested" title="Nested field type">nested type mapping</a>.</p>
<p>If nested type has been configured a single document is actually indexed as multiple Lucene documents and they share
the same id. In order to determine the identity of a nested hit there is more needed than just the id, so that is why
nested hits also include their nested identity. The nested identity is kept under the <code class="literal">_nested</code> field in the search hit
and includes the array field and the offset in the array field the nested hit belongs to. The offset is zero based.</p>
<p>Let&#8217;s see how it works with a real sample. Considering the following mapping:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /sales
{
  "mappings": {
    "properties": {
      "tags": { "type": "keyword" },
      "comments": {                           <a id="CO335-1"></a><i class="conum" data-value="1"></i>
        "type": "nested",
        "properties": {
          "username": { "type": "keyword" },
          "comment": { "type": "text" }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1433.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO335-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">comments</code> is an array that holds nested documents under the <code class="literal">product</code> object.</p>
</td>
</tr>
</table>
</div>
<p>And some documents:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /sales/_doc/1?refresh
{
  "tags": [ "car", "auto" ],
  "comments": [
    { "username": "baddriver007", "comment": "This car could have better brakes" },
    { "username": "dr_who", "comment": "Where's the autopilot? Can't find it" },
    { "username": "ilovemotorbikes", "comment": "This car has two extra wheels" }
  ]
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1434.console"></div>
<p>It&#8217;s now possible to execute the following <code class="literal">top_hits</code> aggregation (wrapped in a <code class="literal">nested</code> aggregation):</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search
{
  "query": {
    "term": { "tags": "car" }
  },
  "aggs": {
    "by_sale": {
      "nested": {
        "path": "comments"
      },
      "aggs": {
        "by_user": {
          "terms": {
            "field": "comments.username",
            "size": 1
          },
          "aggs": {
            "by_nested": {
              "top_hits": {}
            }
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1435.console"></div>
<p>Top hits response snippet with a nested hit, which resides in the first slot of array field <code class="literal">comments</code>:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "by_sale": {
      "by_user": {
        "buckets": [
          {
            "key": "baddriver007",
            "doc_count": 1,
            "by_nested": {
              "hits": {
                "total" : {
                   "value": 1,
                   "relation": "eq"
                },
                "max_score": 0.3616575,
                "hits": [
                  {
                    "_index": "sales",
                    "_id": "1",
                    "_nested": {
                      "field": "comments",  <a id="CO336-1"></a><i class="conum" data-value="1"></i>
                      "offset": 0 <a id="CO336-2"></a><i class="conum" data-value="2"></i>
                    },
                    "_score": 0.3616575,
                    "_source": {
                      "comment": "This car could have better brakes", <a id="CO336-3"></a><i class="conum" data-value="3"></i>
                      "username": "baddriver007"
                    }
                  }
                ]
              }
            }
          }
          ...
        ]
      }
    }
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO336-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Name of the array field containing the nested hit</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO336-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>Position if the nested hit in the containing array</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO336-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>Source of the nested hit</p>
</td>
</tr>
</table>
</div>
<p>If <code class="literal">_source</code> is requested then just the part of the source of the nested object is returned, not the entire source of the document.
Also stored fields on the <span class="strong strong"><strong>nested</strong></span> inner object level are accessible via <code class="literal">top_hits</code> aggregator residing in a <code class="literal">nested</code> or <code class="literal">reverse_nested</code> aggregator.</p>
<p>Only nested hits will have a <code class="literal">_nested</code> field in the hit, non nested (regular) hits will not have a <code class="literal">_nested</code> field.</p>
<p>The information in <code class="literal">_nested</code> can also be used to parse the original source somewhere else if <code class="literal">_source</code> isn&#8217;t enabled.</p>
<p>If there are multiple levels of nested object types defined in mappings then the <code class="literal">_nested</code> information can also be hierarchical
in order to express the identity of nested hits that are two layers deep or more.</p>
<p>In the example below a nested hit resides in the first slot of the field <code class="literal">nested_grand_child_field</code> which then resides in
the second slow of the <code class="literal">nested_child_field</code> field:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">...
"hits": {
 "total" : {
     "value": 2565,
     "relation": "eq"
 },
 "max_score": 1,
 "hits": [
   {
     "_index": "a",
     "_id": "1",
     "_score": 1,
     "_nested" : {
       "field" : "nested_child_field",
       "offset" : 1,
       "_nested" : {
         "field" : "nested_grand_child_field",
         "offset" : 0
       }
     }
     "_source": ...
   },
   ...
 ]
}
...</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_use_in_pipeline_aggregations"></a>Use in pipeline aggregations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/tophits-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p><code class="literal">top_hits</code> can be used in pipeline aggregations that consume a single value per bucket, such as <code class="literal">bucket_selector</code>
that applies per bucket filtering, similar to using a HAVING clause in SQL. This requires setting <code class="literal">size</code> to 1, and
specifying the right path for the value to be passed to the wrapping aggregator. The latter can be a <code class="literal">_source</code>, a
<code class="literal">_sort</code> or a <code class="literal">_score</code> value. For example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs": {
    "top_tags": {
      "terms": {
        "field": "type",
        "size": 3
      },
      "aggs": {
        "top_sales_hits": {
          "top_hits": {
            "sort": [
              {
                "date": {
                  "order": "desc"
                }
              }
            ],
            "_source": {
              "includes": [ "date", "price" ]
            },
            "size": 1
          }
        },
        "having.top_salary": {
          "bucket_selector": {
            "buckets_path": {
              "tp": "top_sales_hits[_source.price]"
            },
            "script": "params.tp &lt; 180"
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1436.console"></div>
<p>The <code class="literal">bucket_path</code> uses the <code class="literal">top_hits</code> name <code class="literal">top_sales_hits</code> and a keyword for the field providing the aggregate value,
namely <code class="literal">_source</code> field <code class="literal">price</code> in the example above. Other options include <code class="literal">top_sales_hits[_sort]</code>, for filtering on the
sort value <code class="literal">date</code> above, and <code class="literal">top_sales_hits[_score]</code>, for filtering on the score of the top hit.</p>
</div>

</div>

<div class="section xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-metrics-top-metrics"></a>Top metrics aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/top-metrics-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>The <code class="literal">top_metrics</code> aggregation selects metrics from the document with the largest or smallest "sort"
value. For example, this gets the value of the <code class="literal">m</code> field on the document with the largest value of <code class="literal">s</code>:</p>
<a id="search-aggregations-metrics-top-metrics-simple"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /test/_bulk?refresh
{"index": {}}
{"s": 1, "m": 3.1415}
{"index": {}}
{"s": 2, "m": 1.0}
{"index": {}}
{"s": 3, "m": 2.71828}
POST /test/_search?filter_path=aggregations
{
  "aggs": {
    "tm": {
      "top_metrics": {
        "metrics": {"field": "m"},
        "sort": {"s": "desc"}
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1437.console"></div>
<p>Which returns:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "aggregations": {
    "tm": {
      "top": [ {"sort": [3], "metrics": {"m": 2.718280076980591 } } ]
    }
  }
}</pre>
</div>
<p><code class="literal">top_metrics</code> is fairly similar to <a class="xref" href="search-aggregations-metrics.html#search-aggregations-metrics-top-hits-aggregation" title="Top hits aggregation"><code class="literal">top_hits</code></a>
in spirit but because it is more limited it is able to do its job using less memory and is often
faster.</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_sort"></a><code class="literal">sort</code><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/top-metrics-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">sort</code> field in the metric request functions exactly the same as the <code class="literal">sort</code> field in the
<a class="xref" href="sort-search-results.html" title="Sort search results">search</a> request except:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
It can&#8217;t be used on <a class="xref" href="mapping-types.html#binary" title="Binary field type">binary</a>, <a class="xref" href="mapping-types.html#flattened" title="Flattened field type">flattened</a>, <a class="xref" href="mapping-types.html#ip" title="IP field type">ip</a>,
<a class="xref" href="mapping-types.html#keyword" title="Keyword type family">keyword</a>, or <a class="xref" href="mapping-types.html#text" title="Text type family">text</a> fields.
</li>
<li class="listitem">
It only supports a single sort value so which document wins ties is not specified.
</li>
</ul>
</div>
<p>The metrics that the aggregation returns is the first hit that would be returned by the search
request. So,</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">"sort": {"s": "desc"}</code>
</span>
</dt>
<dd>
gets metrics from the document with the highest <code class="literal">s</code>
</dd>
<dt>
<span class="term">
<code class="literal">"sort": {"s": "asc"}</code>
</span>
</dt>
<dd>
gets the metrics from the document with the lowest <code class="literal">s</code>
</dd>
<dt>
<span class="term">
<code class="literal">"sort": {"_geo_distance": {"location": "POINT (-78.6382 35.7796)"}}</code>
</span>
</dt>
<dd>
gets metrics from the documents with <code class="literal">location</code> <span class="strong strong"><strong>closest</strong></span> to <code class="literal">35.7796, -78.6382</code>
</dd>
<dt>
<span class="term">
<code class="literal">"sort": "_score"</code>
</span>
</dt>
<dd>
gets metrics from the document with the highest score
</dd>
</dl>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_metrics"></a><code class="literal">metrics</code><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/top-metrics-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p><code class="literal">metrics</code> selects the fields of the "top" document to return. You can request
a single metric with something like <code class="literal">"metrics": {"field": "m"}</code> or multiple
metrics by requesting a list of metrics like <code class="literal">"metrics": [{"field": "m"}, {"field": "i"}</code>.</p>
<p><code class="literal">metrics.field</code> supports the following field types:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<a class="xref" href="mapping-types.html#boolean" title="Boolean field type"><code class="literal">boolean</code></a>
</li>
<li class="listitem">
<a class="xref" href="mapping-types.html#ip" title="IP field type"><code class="literal">ip</code></a>
</li>
<li class="listitem">
<a class="xref" href="mapping-types.html#keyword" title="Keyword type family">keywords</a>
</li>
<li class="listitem">
<a class="xref" href="mapping-types.html#number" title="Numeric field types">numbers</a>
</li>
</ul>
</div>
<p>Except for keywords, <a class="xref" href="runtime.html" title="Runtime fields">runtime fields</a> for corresponding types are also
supported. <code class="literal">metrics.field</code> doesn&#8217;t support fields with <a class="xref" href="mapping-types.html#array" title="Arrays">array values</a>. A
<code class="literal">top_metric</code> aggregation on array values may return inconsistent results.</p>
<p>The following example runs a <code class="literal">top_metrics</code> aggregation on several field types.</p>
<a id="search-aggregations-metrics-top-metrics-list-of-metrics"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /test
{
  "mappings": {
    "properties": {
      "d": {"type": "date"}
    }
  }
}
POST /test/_bulk?refresh
{"index": {}}
{"s": 1, "m": 3.1415, "i": 1, "d": "2020-01-01T00:12:12Z", "t": "cat"}
{"index": {}}
{"s": 2, "m": 1.0, "i": 6, "d": "2020-01-02T00:12:12Z", "t": "dog"}
{"index": {}}
{"s": 3, "m": 2.71828, "i": -12, "d": "2019-12-31T00:12:12Z", "t": "chicken"}
POST /test/_search?filter_path=aggregations
{
  "aggs": {
    "tm": {
      "top_metrics": {
        "metrics": [
          {"field": "m"},
          {"field": "i"},
          {"field": "d"},
          {"field": "t.keyword"}
        ],
        "sort": {"s": "desc"}
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1438.console"></div>
<p>Which returns:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "aggregations": {
    "tm": {
      "top": [ {
        "sort": [3],
        "metrics": {
          "m": 2.718280076980591,
          "i": -12,
          "d": "2019-12-31T00:12:12.000Z",
          "t.keyword": "chicken"
        }
      } ]
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_missing"></a><code class="literal">missing</code><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/top-metrics-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">missing</code> parameter defines how documents with a missing value are treated.
By default, if any of the key components are missing, the entire document is
ignored. It is possible to treat the missing components as if they had a value
by using the <code class="literal">missing</code> parameter.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /my-index
{
  "mappings": {
    "properties": {
      "nr":    { "type": "integer" },
      "state":  { "type": "keyword"  } <a id="CO337-1"></a><i class="conum" data-value="1"></i>
    }
  }
}
POST /my-index/_bulk?refresh
{"index": {}}
{"nr": 1, "state": "started"}
{"index": {}}
{"nr": 2, "state": "stopped"}
{"index": {}}
{"nr": 3, "state": "N/A"}
{"index": {}}
{"nr": 4} <a id="CO337-2"></a><i class="conum" data-value="2"></i>
POST /my-index/_search?filter_path=aggregations
{
  "aggs": {
    "my_top_metrics": {
      "top_metrics": {
        "metrics": {
          "field": "state",
          "missing": "N/A"}, <a id="CO337-3"></a><i class="conum" data-value="3"></i>
        "sort": {"nr": "desc"}
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1439.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO337-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>If you want to use an aggregation on textual content, it must be a <code class="literal">keyword</code>
type field or you must enable fielddata on that field.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO337-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>This document has a missing <code class="literal">state</code> field value.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO337-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">missing</code> parameter defines that if <code class="literal">state</code> field has a missing value,
it should be treated as if it had the <code class="literal">N/A</code> value.</p>
</td>
</tr>
</table>
</div>
<p>The request results in the following response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "aggregations": {
    "my_top_metrics": {
      "top": [
        {
          "sort": [
            4
          ],
          "metrics": {
            "state": "N/A"
          }
        }
      ]
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_size_2"></a><code class="literal">size</code><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/top-metrics-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p><code class="literal">top_metrics</code> can return the top few document&#8217;s worth of metrics using the size parameter:</p>
<a id="search-aggregations-metrics-top-metrics-size"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /test/_bulk?refresh
{"index": {}}
{"s": 1, "m": 3.1415}
{"index": {}}
{"s": 2, "m": 1.0}
{"index": {}}
{"s": 3, "m": 2.71828}
POST /test/_search?filter_path=aggregations
{
  "aggs": {
    "tm": {
      "top_metrics": {
        "metrics": {"field": "m"},
        "sort": {"s": "desc"},
        "size": 3
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1440.console"></div>
<p>Which returns:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "aggregations": {
    "tm": {
      "top": [
        {"sort": [3], "metrics": {"m": 2.718280076980591 } },
        {"sort": [2], "metrics": {"m": 1.0 } },
        {"sort": [1], "metrics": {"m": 3.1414999961853027 } }
      ]
    }
  }
}</pre>
</div>
<p>The default <code class="literal">size</code> is 1. The maximum default size is <code class="literal">10</code> because the aggregation&#8217;s
working storage is "dense", meaning we allocate <code class="literal">size</code> slots for every bucket. <code class="literal">10</code>
is a <span class="strong strong"><strong>very</strong></span> conservative default maximum and you can raise it if you need to by
changing the <code class="literal">top_metrics_max_size</code> index setting. But know that large sizes can
take a fair bit of memory, especially if they are inside of an aggregation which
makes many buckes like a large
<a class="xref" href="search-aggregations-metrics.html#search-aggregations-metrics-top-metrics-example-terms" title="Use with terms">terms aggregation</a>. If
you till want to raise it, use something like:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /test/_settings
{
  "top_metrics_max_size": 100
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1441.console"></div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>If <code class="literal">size</code> is more than <code class="literal">1</code> the <code class="literal">top_metrics</code> aggregation can&#8217;t be the <span class="strong strong"><strong>target</strong></span> of a sort.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_examples"></a>Examples<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/top-metrics-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="search-aggregations-metrics-top-metrics-example-terms"></a>Use with terms<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/top-metrics-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>This aggregation should be quite useful inside of <a class="xref" href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation" title="Terms aggregation"><code class="literal">terms</code></a>
aggregation, to, say, find the last value reported by each server.</p>
<a id="search-aggregations-metrics-top-metrics-terms"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /node
{
  "mappings": {
    "properties": {
      "ip": {"type": "ip"},
      "date": {"type": "date"}
    }
  }
}
POST /node/_bulk?refresh
{"index": {}}
{"ip": "192.168.0.1", "date": "2020-01-01T01:01:01", "m": 1}
{"index": {}}
{"ip": "192.168.0.1", "date": "2020-01-01T02:01:01", "m": 2}
{"index": {}}
{"ip": "192.168.0.2", "date": "2020-01-01T02:01:01", "m": 3}
POST /node/_search?filter_path=aggregations
{
  "aggs": {
    "ip": {
      "terms": {
        "field": "ip"
      },
      "aggs": {
        "tm": {
          "top_metrics": {
            "metrics": {"field": "m"},
            "sort": {"date": "desc"}
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1442.console"></div>
<p>Which returns:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "aggregations": {
    "ip": {
      "buckets": [
        {
          "key": "192.168.0.1",
          "doc_count": 2,
          "tm": {
            "top": [ {"sort": ["2020-01-01T02:01:01.000Z"], "metrics": {"m": 2 } } ]
          }
        },
        {
          "key": "192.168.0.2",
          "doc_count": 1,
          "tm": {
            "top": [ {"sort": ["2020-01-01T02:01:01.000Z"], "metrics": {"m": 3 } } ]
          }
        }
      ],
      "doc_count_error_upper_bound": 0,
      "sum_other_doc_count": 0
    }
  }
}</pre>
</div>
<p>Unlike <code class="literal">top_hits</code>, you can sort buckets by the results of this metric:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /node/_search?filter_path=aggregations
{
  "aggs": {
    "ip": {
      "terms": {
        "field": "ip",
        "order": {"tm.m": "desc"}
      },
      "aggs": {
        "tm": {
          "top_metrics": {
            "metrics": {"field": "m"},
            "sort": {"date": "desc"}
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1443.console"></div>
<p>Which returns:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "aggregations": {
    "ip": {
      "buckets": [
        {
          "key": "192.168.0.2",
          "doc_count": 1,
          "tm": {
            "top": [ {"sort": ["2020-01-01T02:01:01.000Z"], "metrics": {"m": 3 } } ]
          }
        },
        {
          "key": "192.168.0.1",
          "doc_count": 2,
          "tm": {
            "top": [ {"sort": ["2020-01-01T02:01:01.000Z"], "metrics": {"m": 2 } } ]
          }
        }
      ],
      "doc_count_error_upper_bound": 0,
      "sum_other_doc_count": 0
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_mixed_sort_types"></a>Mixed sort types<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/top-metrics-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>Sorting <code class="literal">top_metrics</code> by a field that has different types across different
indices producs somewhat surprising results: floating point fields are
always sorted independently of whole numbered fields.</p>
<a id="search-aggregations-metrics-top-metrics-mixed-sort"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /test/_bulk?refresh
{"index": {"_index": "test1"}}
{"s": 1, "m": 3.1415}
{"index": {"_index": "test1"}}
{"s": 2, "m": 1}
{"index": {"_index": "test2"}}
{"s": 3.1, "m": 2.71828}
POST /test*/_search?filter_path=aggregations
{
  "aggs": {
    "tm": {
      "top_metrics": {
        "metrics": {"field": "m"},
        "sort": {"s": "asc"}
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1444.console"></div>
<p>Which returns:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "aggregations": {
    "tm": {
      "top": [ {"sort": [3.0999999046325684], "metrics": {"m": 2.718280076980591 } } ]
    }
  }
}</pre>
</div>
<p>While this is better than an error it <span class="strong strong"><strong>probably</strong></span> isn&#8217;t what you were going for.
While it does lose some precision, you can explicitly cast the whole number
fields to floating points with something like:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /test*/_search?filter_path=aggregations
{
  "aggs": {
    "tm": {
      "top_metrics": {
        "metrics": {"field": "m"},
        "sort": {"s": {"order": "asc", "numeric_type": "double"}}
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1445.console"></div>
<p>Which returns the much more expected:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "aggregations": {
    "tm": {
      "top": [ {"sort": [1.0], "metrics": {"m": 3.1414999961853027 } } ]
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_use_in_pipeline_aggregations_2"></a>Use in pipeline aggregations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/top-metrics-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p><code class="literal">top_metrics</code> can be used in pipeline aggregations that consume a single value per bucket, such as <code class="literal">bucket_selector</code>
that applies per bucket filtering, similar to using a HAVING clause in SQL. This requires setting <code class="literal">size</code> to 1, and
specifying the right path for the (single) metric to be passed to the wrapping aggregator. For example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /test*/_search?filter_path=aggregations
{
  "aggs": {
    "ip": {
      "terms": {
        "field": "ip"
      },
      "aggs": {
        "tm": {
          "top_metrics": {
            "metrics": {"field": "m"},
            "sort": {"s": "desc"},
            "size": 1
          }
        },
        "having_tm": {
          "bucket_selector": {
            "buckets_path": {
              "top_m": "tm[m]"
            },
            "script": "params.top_m &lt; 1000"
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1446.console"></div>
<p>The <code class="literal">bucket_path</code> uses the <code class="literal">top_metrics</code> name <code class="literal">tm</code> and a keyword for the metric providing the aggregate value,
namely <code class="literal">m</code>.</p>
</div>

</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-metrics-valuecount-aggregation"></a>Value count aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/valuecount-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A <code class="literal">single-value</code> metrics aggregation that counts the number of values that are extracted from the aggregated documents.
These values can be extracted either from specific fields in the documents, or be generated by a provided script. Typically,
this aggregator will be used in conjunction with other single-value aggregations. For example, when computing the <code class="literal">avg</code>
one might be interested in the number of values the average is computed over.</p>
<p><code class="literal">value_count</code> does not de-duplicate values, so even if a field has duplicates each value will be counted individually.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search?size=0
{
  "aggs" : {
    "types_count" : { "value_count" : { "field" : "type" } }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1447.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "types_count": {
      "value": 7
    }
  }
}</pre>
</div>
<p>The name of the aggregation (<code class="literal">types_count</code> above) also serves as the key by which the aggregation result can be
retrieved from the returned response.</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_script_16"></a>Script<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/valuecount-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>If you need to count something more complex than the values in a single field
you should run the aggregation on a <a class="xref" href="runtime.html" title="Runtime fields">runtime field</a>.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search
{
  "size": 0,
  "runtime_mappings": {
    "tags": {
      "type": "keyword",
      "script": """
        emit(doc['type'].value);
        if (doc['promoted'].value) {
          emit('hot');
        }
      """
    }
  },
  "aggs": {
    "tags_count": {
      "value_count": {
        "field": "tags"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1448.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-metrics-valuecount-aggregation-histogram-fields"></a>Histogram fields<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/valuecount-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>When the <code class="literal">value_count</code> aggregation is computed on <a class="xref" href="mapping-types.html#histogram" title="Histogram field type">histogram fields</a>, the result of the aggregation is the sum of all numbers
in the <code class="literal">counts</code> array of the histogram.</p>
<p>For example, for the following index that stores pre-aggregated histograms with latency metrics for different networks:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT metrics_index/_doc/1
{
  "network.name" : "net-1",
  "latency_histo" : {
      "values" : [0.1, 0.2, 0.3, 0.4, 0.5],
      "counts" : [3, 7, 23, 12, 6] <a id="CO338-1"></a><i class="conum" data-value="1"></i>
   }
}

PUT metrics_index/_doc/2
{
  "network.name" : "net-2",
  "latency_histo" : {
      "values" :  [0.1, 0.2, 0.3, 0.4, 0.5],
      "counts" : [8, 17, 8, 7, 6] <a id="CO338-2"></a><i class="conum" data-value="1"></i>
   }
}

POST /metrics_index/_search?size=0
{
  "aggs": {
    "total_requests": {
      "value_count": { "field": "latency_histo" }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1449.console"></div>
<p>For each histogram field the <code class="literal">value_count</code> aggregation will sum all numbers in the <code class="literal">counts</code> array &lt;1&gt;.
Eventually, it will add all values for all histograms and return the following result:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "total_requests": {
      "value": 97
    }
  }
}</pre>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-metrics-weight-avg-aggregation"></a>Weighted avg aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/weighted-avg-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A <code class="literal">single-value</code> metrics aggregation that computes the weighted average of numeric values that are extracted from the aggregated documents.
These values can be extracted either from specific numeric fields in the documents.</p>
<p>When calculating a regular average, each datapoint has an equal "weight" &#8230;&#8203; it contributes equally to the final value. Weighted averages,
on the other hand, weight each datapoint differently. The amount that each datapoint contributes to the final value is extracted from the
document.</p>
<p>As a formula, a weighted average is the <code class="literal">∑(value * weight) / ∑(weight)</code></p>
<p>A regular average can be thought of as a weighted average where every value has an implicit weight of <code class="literal">1</code>.</p>
<div class="table">
<a id="weighted-avg-params"></a>
<p class="title"><strong>Table 51. <code class="literal">weighted_avg</code> Parameters</strong></p>
<div class="table-contents">
<table border="1" cellpadding="4px" summary="weighted_avg Parameters">
<colgroup>
<col class="col_1"/>
<col class="col_2"/>
<col class="col_3"/>
<col class="col_4"/>
</colgroup>
<thead>
<tr>
<th align="left" valign="top">Parameter Name</th>
<th align="left" valign="top">Description</th>
<th align="left" valign="top">Required</th>
<th align="left" valign="top">Default Value</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p><code class="literal">value</code></p></td>
<td align="left" valign="top"><p>The configuration for the field or script that provides the values</p></td>
<td align="left" valign="top"><p>Required</p></td>
<td align="left" valign="top"><p></p></td>
</tr>
<tr>
<td align="left" valign="top"><p><code class="literal">weight</code></p></td>
<td align="left" valign="top"><p>The configuration for the field or script that provides the weights</p></td>
<td align="left" valign="top"><p>Required</p></td>
<td align="left" valign="top"><p></p></td>
</tr>
<tr>
<td align="left" valign="top"><p><code class="literal">format</code></p></td>
<td align="left" valign="top"><p>The numeric response formatter</p></td>
<td align="left" valign="top"><p>Optional</p></td>
<td align="left" valign="top"><p></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<p>The <code class="literal">value</code> and <code class="literal">weight</code> objects have per-field specific configuration:</p>
<div class="table">
<a id="value-params"></a>
<p class="title"><strong>Table 52. <code class="literal">value</code> Parameters</strong></p>
<div class="table-contents">
<table border="1" cellpadding="4px" summary="value Parameters">
<colgroup>
<col class="col_1"/>
<col class="col_2"/>
<col class="col_3"/>
<col class="col_4"/>
</colgroup>
<thead>
<tr>
<th align="left" valign="top">Parameter Name</th>
<th align="left" valign="top">Description</th>
<th align="left" valign="top">Required</th>
<th align="left" valign="top">Default Value</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p><code class="literal">field</code></p></td>
<td align="left" valign="top"><p>The field that values should be extracted from</p></td>
<td align="left" valign="top"><p>Required</p></td>
<td align="left" valign="top"><p></p></td>
</tr>
<tr>
<td align="left" valign="top"><p><code class="literal">missing</code></p></td>
<td align="left" valign="top"><p>A value to use if the field is missing entirely</p></td>
<td align="left" valign="top"><p>Optional</p></td>
<td align="left" valign="top"><p></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="table">
<a id="weight-params"></a>
<p class="title"><strong>Table 53. <code class="literal">weight</code> Parameters</strong></p>
<div class="table-contents">
<table border="1" cellpadding="4px" summary="weight Parameters">
<colgroup>
<col class="col_1"/>
<col class="col_2"/>
<col class="col_3"/>
<col class="col_4"/>
</colgroup>
<thead>
<tr>
<th align="left" valign="top">Parameter Name</th>
<th align="left" valign="top">Description</th>
<th align="left" valign="top">Required</th>
<th align="left" valign="top">Default Value</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p><code class="literal">field</code></p></td>
<td align="left" valign="top"><p>The field that weights should be extracted from</p></td>
<td align="left" valign="top"><p>Required</p></td>
<td align="left" valign="top"><p></p></td>
</tr>
<tr>
<td align="left" valign="top"><p><code class="literal">missing</code></p></td>
<td align="left" valign="top"><p>A weight to use if the field is missing entirely</p></td>
<td align="left" valign="top"><p>Optional</p></td>
<td align="left" valign="top"><p></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_examples_2"></a>Examples<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/weighted-avg-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>If our documents have a <code class="literal">"grade"</code> field that holds a 0-100 numeric score, and a <code class="literal">"weight"</code> field which holds an arbitrary numeric weight,
we can calculate the weighted average using:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /exams/_search
{
  "size": 0,
  "aggs": {
    "weighted_grade": {
      "weighted_avg": {
        "value": {
          "field": "grade"
        },
        "weight": {
          "field": "weight"
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1450.console"></div>
<p>Which yields a response like:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "weighted_grade": {
      "value": 70.0
    }
  }
}</pre>
</div>
<p>While multiple values-per-field are allowed, only one weight is allowed. If the aggregation encounters
a document that has more than one weight (e.g. the weight field is a multi-valued field) it will abort the search.
If you have this situation, you should build a <a class="xref" href="search-aggregations-metrics.html#search-aggregations-metrics-weight-avg-aggregation-runtime-field" title="Runtime field">Runtime field</a>
to combine those values into a single weight.</p>
<p>This single weight will be applied independently to each value extracted from the <code class="literal">value</code> field.</p>
<p>This example show how a single document with multiple values will be averaged with a single weight:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /exams/_doc?refresh
{
  "grade": [1, 2, 3],
  "weight": 2
}

POST /exams/_search
{
  "size": 0,
  "aggs": {
    "weighted_grade": {
      "weighted_avg": {
        "value": {
          "field": "grade"
        },
        "weight": {
          "field": "weight"
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1451.console"></div>
<p>The three values (<code class="literal">1</code>, <code class="literal">2</code>, and <code class="literal">3</code>) will be included as independent values, all with the weight of <code class="literal">2</code>:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "weighted_grade": {
      "value": 2.0
    }
  }
}</pre>
</div>
<p>The aggregation returns <code class="literal">2.0</code> as the result, which matches what we would expect when calculating by hand:
<code class="literal">((1*2) + (2*2) + (3*2)) / (2+2+2) == 2</code></p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-metrics-weight-avg-aggregation-runtime-field"></a>Runtime field<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/weighted-avg-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>If you have to sum or weigh values that don&#8217;t quite line up with the indexed
values, run the aggregation on a <a class="xref" href="runtime.html" title="Runtime fields">runtime field</a>.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /exams/_doc?refresh
{
  "grade": 100,
  "weight": [2, 3]
}
POST /exams/_doc?refresh
{
  "grade": 80,
  "weight": 3
}

POST /exams/_search?filter_path=aggregations
{
  "size": 0,
  "runtime_mappings": {
    "weight.combined": {
      "type": "double",
      "script": """
        double s = 0;
        for (double w : doc['weight']) {
          s += w;
        }
        emit(s);
      """
    }
  },
  "aggs": {
    "weighted_grade": {
      "weighted_avg": {
        "value": {
          "script": "doc.grade.value + 1"
        },
        "weight": {
          "field": "weight.combined"
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1452.console"></div>
<p>Which should look like:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "aggregations": {
    "weighted_grade": {
      "value": 93.5
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_missing_values_4"></a>Missing values<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/weighted-avg-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>By default, the aggregation excludes documents with a missing or <code class="literal">null</code> value for the <code class="literal">value</code> or <code class="literal">weight</code> field. Use the
 <code class="literal">missing</code> parameter to specify a default value for these documents instead.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /exams/_search
{
  "size": 0,
  "aggs": {
    "weighted_grade": {
      "weighted_avg": {
        "value": {
          "field": "grade",
          "missing": 2
        },
        "weight": {
          "field": "weight",
          "missing": 3
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1453.console"></div>
</div>

</div>

</div>
<div class="navfooter">
<span class="prev">
<a href="search-aggregations-bucket.html">« Bucket aggregations</a>
</span>
<span class="next">
<a href="search-aggregations-pipeline.html">Pipeline aggregations »</a>
</span>
</div>
</div>
</body>
</html>
